# 第七章。测试、分析和处理异常

|  | *“未经测试的代码被设计破坏。”* |  |
|  | --*雅各布·卡普兰·莫斯* |

Jacob Kaplan Moss 是 Django web 框架的核心开发人员之一。我们将在下一章中探讨它。我非常同意他的这句话。我认为没有测试的代码不应该部署到生产环境中。

为什么考试如此重要？首先，它们给了你可预测性。或者，至少，它们可以帮助您实现高可预测性。不幸的是，总是有一些 bug 潜入我们的代码中。但我们确实希望我们的代码尽可能可预测。我们不想让人惊讶的是，我们的代码以一种不可预测的方式运行。你会高兴地知道，检查带你去度假的飞机传感器的软件有时会变得疯狂吗？不，可能不会。

因此，我们需要测试我们的代码，我们需要检查它的行为是否正确，它在处理边缘情况时是否如预期的那样工作，它在与之交谈的组件停机时是否挂起，性能是否在可接受的范围内，等等。

这一章都是关于这个主题的，确保您的代码准备好面对可怕的外部世界，足够快，并且可以处理意外或异常情况。

我们将探讨测试，包括对**测试驱动开发**（**TDD**）的简要介绍，这是我最喜欢的工作方法之一。然后，我们将探索异常的世界，最后我们将讨论一点性能和分析。深呼吸，我们走了。。。

# 测试您的应用程序

有许多不同类型的测试，事实上，很多公司通常都有一个专门的部门，称为**质量保证**（**质量保证**），由个人组成，他们每天都在测试公司开发人员生产的软件。

为了开始进行初始分类，我们可以将测试分为两大类：白盒测试和黑盒测试。

**白盒测试**是那些对代码内部进行测试的测试，它们将代码检查到非常精细的粒度级别。另一方面，To.T3 黑箱测试 AUTT4 是 T5 T. 5.那些被认为是在一个盒子内的测试软件被忽略。即使是黑盒测试中使用的技术或语言也不重要。他们所做的是将输入插入到盒子的一端，并在另一端验证输出，就这样。

### 注

还有一个介于两者之间的类别，称为**灰盒**测试，它涉及以与黑盒方法相同的方式测试系统，但对用于编写软件的算法和数据结构有一些了解，并且只对其源代码有部分访问。

在这些类别中有许多不同类型的测试，每个测试都有不同的用途。为了给你一个想法，这里有几个：

*   **前端测试**确保应用程序的客户端公开了它应该公开的信息、所有链接、按钮、广告以及需要向客户端显示的所有内容。它还可以验证是否可以通过用户界面走特定的路径。
*   **场景测试**利用故事（或场景）帮助测试人员解决复杂问题或测试系统的一部分。
*   **集成测试**验证应用程序的各个组件在通过接口发送消息时的行为。
*   当您在应用程序上部署新的更新时，**冒烟测试**特别有用。他们会检查您的应用程序中最重要、最重要的部分是否仍在正常工作，以及它们是否*着火*。这个术语来自工程师测试电路时确保没有冒烟。
*   **验收测试**或**用户验收测试**（**UAT**）是开发人员与产品所有者进行的工作（例如，在 SCRUM环境中），以确定委托的工作是否正确执行。
*   **功能测试**验证您的软件的特性或功能。
*   **破坏性测试**取下系统的部分，模拟故障，以便确定系统其余部分的性能。这些类型的测试由需要提供极其可靠服务的公司广泛执行，例如亚马逊。
*   **性能测试**旨在验证系统在特定数据或流量负载下的性能，例如，工程师可以更好地了解哪些是系统中的瓶颈，在重负载情况下可能导致系统瘫痪，哪些是阻碍可伸缩性的瓶颈。
*   **可用性测试**和密切相关的**用户体验****UX**测试，旨在检查用户界面是否简单易懂和使用。他们的目标是为设计师提供投入，从而改善用户体验。
*   **安全和渗透测试**旨在验证系统对攻击和入侵的保护程度。
*   **单元测试**帮助开发人员以健壮、一致的方式编写代码，为提供第一行反馈，防止编码错误、重构错误等。
*   **回归测试**为开发人员提供了更新后系统中受损功能的有用信息。一个系统被称为有回归的一些原因是一个旧的 bug 复活了，一个现有的特性被破坏了，或者一个新的问题被引入。

已经有很多关于测试的书籍和文章，如果您想了解更多关于各种测试的信息，我必须向您指出这些资源。在本章中，我们将集中讨论单元测试，因为它们是软件制作的支柱，并且构成了绝大多数由开发人员编写的测试。

考试是一门*艺术*，恐怕你不会从书本上学到这门艺术。您可以学习所有的定义（而且您应该），并尽可能多地收集测试方面的知识，但我向您保证，只有当您在该领域已经做了足够长的时间后，您才能正确地测试您的软件。

当你在重构一段代码时遇到困难，因为你碰到的每一件小事都会使测试失败，你会学习如何编写不那么严格和限制性的测试，这些测试仍然会验证你的代码的正确性，但同时，允许你自由和快乐地使用它，随心所欲地塑造它。

当您经常被调用以修复代码中意外的错误时，您将学习如何更彻底地编写测试，如何提出更全面的边缘情况列表，以及在它们变成错误之前应对它们的策略。

当您花费太多时间阅读测试并试图重构它们以更改代码中的一个小特性时，您将学会编写更简单、更短、更专注的测试。

当你。。。你学会了。。。，但我想你明白了。你需要把手弄脏，积累经验。我的建议？尽可能多地学习理论，然后用不同的方法进行实验。此外，尽量向有经验的程序员学习；它非常有效。

## 测试的解剖

在我们专注于单元测试之前，让我们先看看什么是测试，以及它的目的是什么。

**测试**是一段代码，其目的是验证系统中的某些内容。这可能是因为我们调用了一个传递两个整数的函数，一个对象有一个名为`donald_duck`的属性，或者当您对某个 API 下订单时，一分钟后您可以看到它在数据库中被分解为基本元素。

测试通常包括三个部分：

*   **准备**：这是你设置场景的地方。在需要的地方准备好所有数据、对象和服务，以便随时可以使用。
*   **执行**：这是您执行要检查的逻辑位的地方。您可以使用在准备阶段设置的数据和接口执行操作。
*   **验证**：这是验证结果并确保结果符合您的预期的地方。您可以检查函数的返回值，或者检查某些数据是否在数据库中，某些数据是否在数据库中，某些数据是否已更改，是否发出了请求，是否发生了什么事情，是否调用了方法，等等。

## 检测指南

像软件一样，测试可以是好的或坏的，整个色调在中间。为了编写好测试，以下是一些指导原则：

*   **尽量简单**：违反一些好的编码规则是可以的，比如硬编码值或复制代码。测试首先需要尽可能可读并且易于理解。当测试难以阅读或理解时，您永远无法确定它们是否确实确保了代码的正确执行。
*   **测试应该验证一件事，而且只能验证一件事**：保持测试的简短和完整是非常重要的。编写多个测试来执行单个对象或函数是非常好的。只要确保每个测试都有一个且只有一个目的。
*   **测试在验证数据**时不应做出任何不必要的假设：这一点一开始很难理解，但假设您正在测试函数的返回值，它是一个无序的数字列表（如`[2, 3, 1]`。如果该列表中的顺序是随机的，那么在测试中，您可能会尝试对其进行排序，并将其与`[1, 2, 3]`进行比较。如果您这样做，您将对函数调用结果的顺序引入额外的假设，*这是一种糟糕的做法*。您应该始终找到一种方法来验证事物，而不引入任何假设或任何不属于您在测试中描述的用例的特性。
*   **测试应该练习 what，而不是 how**：测试应该专注于检查*一个函数应该做什么，而不是*它是如何做的。例如，关注它正在计算一个数字的平方根（即*什么*），而不是它正在调用`math.sqrt`来做这件事（即*如何做*）。除非您正在编写性能测试，或者您特别需要验证某个操作是如何执行的，否则请尽量避免此类测试，并将重点放在*什么*上。测试*如何*导致限制性测试并使重构变得困难。此外，当您专注于*如何*时，您必须编写的测试类型更有可能在您频繁修改软件时降低测试代码库的质量（稍后将详细介绍）。**
*   **测试应在准备阶段尽可能少地假设**：假设您有 10 个测试正在检查函数如何操作数据结构。假设这个数据结构是一个有五个键/值对的 dict。如果你在每一个测试中都放上完整的口述，当你必须改变口述中的某些内容时，你也必须修改所有十个测试。另一方面，如果您尽可能地剥离测试数据，您会发现，在大多数情况下，大多数测试可能只检查部分版本的数据，而只有少数测试使用完整版本的数据运行。这意味着，当您需要更改数据时，您必须只修改那些实际使用数据的测试。
*   **测试应该尽可能快地运行**：一个好的测试代码库可能会比被测试的代码本身长很多。它根据情况和开发人员的不同而有所不同，但无论长度如何，最终都会有数百个（如果不是数千个）测试要运行，这意味着它们运行得越快，您就可以越快地重新编写代码。例如，当使用 TDD 时，您经常运行测试，因此速度是必不可少的。
*   **Tests should use up the least possible amount of resources**: The reason for this is that every developer who checks out your code should be able to run your tests, no matter how powerful their box is. It could be a skinny virtual machine or a neglected Jenkins box, your tests should run without chewing up too many resources.

    ### 注

    一个**Jenkins**盒子是一台运行 Jenkins 的机器，该软件能够自动运行您的测试。Jenkins 经常用于开发人员使用持续集成、极限编程等实践的公司。

## 单元测试

既然您已经了解了什么是测试以及我们为什么需要它，那么最后让我们介绍一下开发人员最好的朋友：**单元测试**。

在我们继续进行示例之前，请允许我说几句谨慎的话：我将尝试向您介绍单元测试的基本原理，但我不会完全遵循任何特定的思想流派或方法。多年来，我尝试了许多不同的测试方法，最终提出了我自己的做事方式，这是不断发展的。正如李小龙所说：

> *“吸收有用的东西，丢弃无用的东西，增加你自己的东西”。*

### 编写单元测试

为了解释如何编写单元测试，让我们用一个简单的片段来帮助自己：

`data.py`

```py
def get_clean_data(source):
    data = load_data(source)
    cleaned_data = clean_data(data)
    return cleaned_data
```

函数`get_clean_data`负责从`source`获取数据，清理数据，并将数据返回给调用者。我们如何测试这个函数？

一种方法是调用它，然后确保调用了一次`load_data`，并将`source`作为其唯一参数。然后我们必须验证调用了一次`clean_data`，返回值为`load_data`。最后，我们需要确保`clean_data`的返回值也是`get_clean_data`函数返回的值。

为了做到这一点，我们需要设置源代码并运行此代码，这可能是一个问题。单元测试的黄金法则之一是*任何跨越应用程序边界的东西都需要模拟*。我们不想与真实的数据源交谈，如果实际函数与应用程序中未包含的任何内容进行通信，我们也不想实际运行这些函数。有几个例子是数据库、搜索服务、外部 API、文件系统中的文件，等等。

我们需要这些限制作为屏障，这样我们就可以始终安全地运行测试，而不用担心破坏真实数据源中的某些内容。

另一个原因是单个开发人员可能很难在他们的机器上复制整个体系结构。它可能需要设置数据库、API、服务、文件和文件夹等，这可能很困难、很耗时，有时甚至不可能。

### 注

非常简单地说，**应用程序编程接口**（**API**）是一套用于构建软件应用程序的工具。API 根据软件组件的操作、输入和输出以及底层类型来表示软件组件。例如，如果您创建了一个需要与数据提供程序服务接口的软件，则很可能需要通过其 API 才能访问数据。

因此，在我们的单元测试中，我们需要以某种方式模拟所有这些事情。单元测试需要由任何开发人员运行，而不需要在他们的机器上设置整个系统。

另一种方法是模拟实体，不使用假对象，而是使用特殊用途的测试对象，如果可能的话，我总是喜欢这种方法。例如，如果您的代码与数据库对话，与其伪造与数据库对话的所有函数和方法，并对假对象进行编程，以便它们返回真实对象所返回的内容，我更愿意生成一个测试数据库，设置我需要的表和数据，然后修补连接设置，使我的测试针对测试数据库运行真正的代码，从而不会造成任何伤害。对于这些情况，内存中的数据库是很好的选择。

### 注

Django 是允许您生成用于测试的数据库的应用程序之一。在`django.test`软件包中，您可以找到一些工具来帮助您编写测试，这样您就不必用数据库模拟对话框。通过以这种方式编写测试，您还可以检查事务、编码和编程的所有其他与数据库相关的方面。这种方法的另一个优点在于能够检查从一个数据库到另一个数据库可能发生的变化。

不过，有时这仍然是不可能的，我们需要使用假货，所以让我们来谈谈它们。

### 模拟对象和修补

首先在 Python 中，这些伪对象被称为**mock**。在版本 3.3 之前，`mock`库是一个第三方库，基本上每个项目都会通过`pip`安装，但从版本 3.3 开始，它已经包含在`unittest`模块下的标准库中，考虑到它的重要性和广泛性，这是理所当然的。

用模拟替换真实对象或函数（或一般情况下，任何数据结构）的行为称为修补。`mock`库提供了`patch`工具，该工具可以作为函数或类装饰器，甚至可以作为上下文管理器（详见[第 8 章](07.html "Chapter 8\. The Edges – GUIs and Scripts")、*边缘–GUI 和脚本*），您可以使用它来模拟事物。一旦用合适的模拟替换了不需要运行的所有内容，就可以进入测试的第二阶段并运行正在运行的代码。执行后，您将能够检查这些模拟，以验证代码是否正常工作。

### 断言

验证阶段通过使用断言来完成。**断言**是一个函数（或方法），可用于验证对象之间的相等性以及其他条件。当一个条件不满足时，断言将引发一个异常，该异常将使您的测试失败。您可以在`unittest`模块文档中找到断言列表，并在 nose 第三方库中找到相应的 Pythonic 版本，它比纯粹的`unittest`模块提供了一些优势，从改进的测试发现策略开始（这是测试运行者在应用程序中检测和发现测试的方式）。

### 一个经典的单元测试示例

mock、补丁和断言是我们用来编写测试的基本工具。最后，让我们看一个例子。我要写一个函数，它取一个整数列表，过滤掉所有非正的。

`filter_funcs.py`

```py
def filter_ints(v):
    return [num for num in v if is_positive(num)]

def is_positive(n):
    return n > 0
```

在前面的示例中，我们定义了`filter_ints`函数，它基本上使用列表理解来保留`v`中所有正的数字，丢弃零和负的数字。我希望，到目前为止，对该准则的任何进一步解释都将是一种侮辱。

然而，有趣的是，我们开始思考如何测试它。那么，我们用一系列号码打电话给`filter_ints`怎么样？我们要确保每个号码都有`is_positive`的呼叫？当然，我们也必须测试`is_positive`，但稍后我将向您展示如何进行测试。现在让我们为`filter_ints`编写一个简单的测试。

### 注

为了确保我们在同一页上，我将本章的代码放在一个名为`ch7`的文件夹中，该文件夹位于我们项目的根目录中。在`ch7`的同一级别，我创建了一个名为`tests`的文件夹，其中我放置了一个名为`test_ch7`的文件夹。在这个文件夹中，我有一个测试文件，名为`test_filter_func.py`。

基本上，在`tests`文件夹中，我将重新创建我正在测试的代码的树结构，用`test_`作为所有内容的前缀。通过这种方式，找到测试非常容易，而且可以保持它们的整洁。

`tests/test_ch7/test_filter_funcs.py`

```py
from unittest import TestCase  # 1
from unittest.mock import patch, call  # 2
from nose.tools import assert_equal  # 3
from ch7.filter_funcs import filter_ints  # 4

class FilterIntsTestCase(TestCase):  # 5

    @patch('ch7.filter_funcs.is_positive')  # 6
    def test_filter_ints(self, is_positive_mock):  # 7
        # preparation
        v = [3, -4, 0, 5, 8]

        # execution
        filter_ints(v)  # 8

        # verification
        assert_equal(
            [call(3), call(-4), call(0), call(5), call(8)],
            is_positive_mock.call_args_list
        )  # 9
```

我的，哦，我的，这么少的代码，还有这么多的话要说。首先：`#1`。`TestCase`类是基类，我们使用它拥有一个包含的实体来运行测试。它不仅仅是一个光秃秃的容器；它为您提供了更容易编写测试的方法。

在`#2`上，我们从`unittest.mock`模块导入`patch`和`call`。`patch`负责用`Mock`实例替换对象，从而使我们能够在执行阶段完成后对其进行检查。`call`为我们提供了一种表达（例如，函数）调用的好方法。

在`#3`上，您可以看到，我更喜欢使用`nose`中的断言，而不是`unittest`模块附带的断言。举个例子，`assert_equal(...)`如果我不使用`nose`就会变成`self.assertEqual(...)`。我不喜欢为任何断言键入`self.`，如果有办法避免的话，我也不特别喜欢**驼色案例**，因此我总是喜欢使用`nose`来进行断言。

`assert_equal`是一个函数，它接受两个参数（以及作为消息的可选第三个参数），并验证它们是否相同。如果它们相等，则什么也不会发生，但如果它们不同，则会引发`AssertionError`异常，告诉我们有问题。当我编写测试时，我总是将期望值作为第一个参数，将真实值作为第二个参数。当我阅读测试时，这个惯例节省了我的时间。

在`#4`上，我们导入我们想要测试的函数，然后（`#5`我们继续创建我们的测试将驻留的类。此类中以`test_`开头的每个方法都将被解释为测试。如你所见，我们需要用`patch`（`#6`来装饰`test_filter_ints`。理解这一部分至关重要，我们需要在实际使用的地方修补对象。在这种情况下，路径非常简单：`ch7.filter_func.is_positive`。

### 提示

修补可能非常棘手，因此我建议您阅读模拟文档中的*哪里修补*部分：[https://docs.python.org/3/library/unittest.mock.html#where-给](https://docs.python.org/3/library/unittest.mock.html#where-to-patch)打补丁。

当我们使用`patch`修饰函数时，就像在我们的示例中一样，我们在测试签名（`#7`中得到了一个额外的参数，我喜欢将其称为修补后的函数名，加上`_mock`后缀，以明确对象已经修补（或模拟）。

最后，我们进入测试主体，我们有一个非常简单的准备阶段，在这个阶段，我们建立了一个列表，其中至少有一个代表所有整数类别（负、零和正）。

然后，在`#8`中，我们执行执行阶段，运行`filter_ints`函数，而不收集其结果。如果一切都按预期进行，则必须使用`v`中的每个整数调用伪`is_positive`函数。

我们可以通过比较调用对象列表和模拟（`#9`上的`call_args_list`属性来验证这一点。此属性是自对象创建以来对其执行的所有调用的列表。

让我们运行这个测试。首先，确保您安装了`nose`（`$ pip freeze`会告诉您是否已经安装了它）：

```py
$ pip install nose

```

然后，切换到项目的根目录（我的名为`learning.python`，并运行如下测试：

```py
$ nosetests tests/test_ch7/
.
------------------------------------------------------------
Ran 1 test in 0.006s
OK

```

输出显示一个点（每个点都是一个测试）、一条分隔线以及运行整个测试套件所需的时间。最后还写着`OK`，这意味着我们的测试都成功了。

### 使测试失败

很好，所以为了好玩，让我们做一个失败。在测试文件中，将最后一次调用从`call(8)`更改为`call(9)`，然后再次运行测试：

```py
$ nosetests tests/test_ch7/
F
============================================================
FAIL: test_filter_ints (test_filter_funcs.FilterIntsTestCase)
------------------------------------------------------------
Traceback (most recent call last):
 File "/usr/lib/python3.4/unittest/mock.py", line 1125, in patched
 return func(*args, **keywargs)
 File "/home/fab/srv/learning.python/tests/test_ch7/test_filter_funcs.py", line 21, in test_filter_ints
 is_positive_mock.call_args_list
AssertionError: [call(3), call(-4), call(0), call(5), call(9)] != [call(3), call(-4), call(0), call(5), call(8)]
------------------------------------------------------------
Ran 1 test in 0.008s
FAILED (failures=1)

```

哇，我们让野兽生气了！不过，有这么多精彩的信息。这告诉您测试`test_filter_ints`（及其路径）已经运行，并且失败了（顶部的大`F`，点在前面）。它给你一个`Traceback`，告诉你在`test_filter_funcs.py`模块中，在第 21 行，当在`is_positive_mock.call_args_list`上断言时，我们有一个差异。测试期望调用列表以`call(9)`实例结尾，但实际列表以`call(8)`结尾。这简直太棒了。

如果你有这样一个测试，你能想象如果你重构并错误地将一个 bug 引入到你的函数中会发生什么吗？好吧，你的测试会失败的！他们会告诉你*你把事情搞砸了，下面是细节*。所以，你去看看你打破了什么。

### 接口测试

让我们添加另一个检查返回值的测试。这是类中的另一个方法，因此我不再重复整个代码：

`tests/test_ch7/test_filter_funcs.py`

```py
def test_filter_ints_return_value(self):
    v = [3, -4, 0, -2, 5, 0, 8, -1]

    result = filter_ints(v)

    assert_list_equal([3, 5, 8], result)
```

这项测试与前一项有点不同。首先，我们不能模拟`is_positive`函数，否则我们将无法检查结果。第二，我们不检查调用，而只检查给定输入时函数的结果。

我比上一次更喜欢这次考试。这种类型的测试称为**接口测试**，因为它检查我们正在测试的函数的接口（输入和输出集）。它不使用任何模拟，这就是为什么我比前一个使用这种技术更多的原因。让我们运行新的测试套件，然后让我们看看为什么我更喜欢界面测试，而不是模拟测试。

```py
$ nosetests tests/test_ch7/
..
------------------------------------------------------------
Ran 2 tests in 0.006s
OK

```

运行了两次测试，都很好（当然，我在第一次测试中将`9`改回了`8`）。

### 比较有模拟和无模拟的试验

现在，让我们看看为什么我不喜欢模仿，只有在我没有选择的时候才使用它们。让我们以这种方式重构代码：

`filter_funcs_refactored.py`

```py
def filter_ints(v):
    v = [num for num in v if num != 0]  # 1
    return [num for num in v if is_positive(num)]
```

`is_positive`的代码与之前相同。但是`filter_ints`中的逻辑现在已经发生了变化，不再使用`0`调用`is_positive`，因为它们都在`#1`中过滤掉了。这将导致一个有趣的结果，因此让我们再次运行测试：

```py
$ nosetests tests/test_ch7/test_filter_funcs_refactored.py 
F.
============================================================
FAIL: test_filter_ints (test_filter_funcs_refactored.FilterIntsTestCase)
------------------------------------------------------------
... omit ...
AssertionError: [call(3), call(-4), call(0), call(5), call(8)] != [call(3), call(-4), call(5), call(8)]
------------------------------------------------------------
Ran 2 tests in 0.002s
FAILED (failures=1)

```

一个测试成功，但另一个测试（具有模拟`is_positive`功能的测试）失败。`AssertionError`消息显示我们现在需要修改预期呼叫列表，删除`call(0)`，因为它不再执行。

这不好。我们既没有改变函数的接口，也没有改变函数的行为。该功能仍保持其*原始合同*。我们用一个模拟对象来测试它所做的是限制我们自己。事实上，为了使用新的逻辑，我们现在必须修改测试。

这只是一个简单的示例，但它显示了整个模拟机制中的一个重要缺陷。*您必须使您的模型保持最新，并与他们正在替换的代码*保持同步，否则您可能会遇到与前一个问题类似的问题，甚至更糟。您的测试可能不会失败，因为它们使用的是性能良好的模拟对象，但因为现在不再同步的真实对象实际上失败了。

因此*仅在必要时*使用模拟，只有在没有其他方法测试您的函数时。当您在测试中跨越应用程序的边界时，请尝试使用替换，如测试数据库或伪 API，并且只有在不可能的情况下，才诉诸模拟。它们非常强大，但如果处理不当，也非常危险。

所以，让我们删除第一个测试，只保留第二个测试，这样我就可以向您展示编写测试时可能遇到的另一个问题。整个测试模块现在如下所示：

`tests/test_ch7/test_filter_funcs_final.py`

```py
from unittest import TestCase
from nose.tools import assert_list_equal
from ch7.filter_funcs import filter_ints

class FilterIntsTestCase(TestCase):
    def test_filter_ints_return_value(self):
        v = [3, -4, 0, -2, 5, 0, 8, -1]
        result = filter_ints(v)
        assert_list_equal([3, 5, 8], result)
```

如果我们运行它，它将通过。

关于三角测量的简短交谈。现在让我问你：如果我把我的`filter_ints`函数改成这个会发生什么？

`filter_funcs_triangulation.py`

```py
def filter_ints(v):
    return [3, 5, 8]
```

如果您运行测试套件，我们的测试仍然会通过！你们可能认为我疯了，但我给你们看这个是因为我想谈谈一个叫做**三角测量**的概念，这在使用 TDD 进行接口测试时非常重要。

整个想法是通过从不同角度（比如从另两个角度到三角形的一个顶点）精确定位代码，从而消除作弊代码或性能差的代码，从而使我们的代码不可能作弊，从而暴露错误。我们可以简单地修改测试，如下所示：

`tests/test_ch7/test_filter_funcs_final_triangulation.py`

```py
def test_filter_ints_return_value(self):
    v1 = [3, -4, 0, -2, 5, 0, 8, -1]
    v2 = [7, -3, 0, 0, 9, 1]

    assert_list_equal([3, 5, 8], filter_ints(v1))
    assert_list_equal([7, 9, 1], filter_ints(v2))
```

我已经直接在断言中移动了执行部分，您可以看到，我们现在从两个不同的角度确定了我们的函数，因此要求真正的代码在其中。我们的函数不可能再作弊了。

三角剖分是一种非常强大的技术，它教会我们始终尝试从许多不同的角度练习代码，以覆盖所有可能的边缘情况，从而暴露任何问题。

### 边界和粒度

现在让我们为`is_positive`函数添加一个测试。我知道这是一条直线，但它为我们提供了讨论两个非常重要的概念的机会：**边界**和**粒度**。

函数体中的`0`是一个**边界**，不等式中的`>`是我们在关于这个边界的行为。通常，设置边界时，会将空间划分为三个区域：边界前、边界后和边界本身上的区域。在这个例子中，在边界之前，我们找到负数，边界是元素`0`，在边界之后，我们找到正数。我们需要测试这些区域中的每一个，以确保我们正确地测试了功能。因此，让我们来看一个可能的解决方案（我将向类中添加测试，但不会显示重复的代码）：

`tests/test_ch7/test_filter_funcs_is_positive_loose.py`

```py
def test_is_positive(self):
    assert_equal(False, is_positive(-2))  # before boundary
    assert_equal(False, is_positive(0))  # on the boundary
    assert_equal(True, is_positive(2))  # after the boundary
```

您可以看到，我们正在为边界周围的每个不同区域使用一个数字。你认为这个测试好吗？在继续阅读之前先想一分钟。

答案是否定的，这个测试不好。无论如何，这还不够好。如果我将`is_positive`函数的主体更改为`return n > 1`，我预计我的测试会失败，但不会。`-2`仍然是`False`，以及`0`，并且`2`仍然是`True`。为什么会这样？这是因为我们没有适当地考虑粒度。我们处理的是整数，那么当我们从一个整数移动到下一个整数时，最小粒度是多少？是 1。因此，当我们围绕边界时，仅考虑这三个方面是不够的。我们需要以尽可能小的粒度来完成。让我们更改测试：

`tests/test_ch7/test_filter_funcs_is_positive_correct.py`

```py
def test_is_positive(self):
    assert_equal(False, is_positive(-1))
    assert_equal(False, is_positive(0))
    assert_equal(True, is_positive(1))
```

啊，现在好多了。现在，如果我们将`is_positive`的主体改为`return n > 1`，那么第三个断言将失败，这正是我们想要的。你能想出更好的办法吗？

`tests/test_ch7/test_filter_funcs_is_positive_better.py`

```py
def test_is_positive(self):
    assert_equal(False, is_positive(0))
    for n in range(1, 10 ** 4):
        assert_equal(False, is_positive(-n))
        assert_equal(True, is_positive(n))
```

这个测试甚至更好。我们测试前一万个整数（正整数和负整数）和 0。它基本上为我们提供了比跨越边界的更好的覆盖范围。所以，记住这一点。以最小的粒度围绕每个边界进行放大，但也要尝试扩展，在最佳覆盖率和执行速度之间找到一个很好的折衷方案。我们很想检查前 10 亿个整数，但我们不能等几天测试才能运行。

### 一个更有趣的例子

好的，这是我能给你的最温和的介绍，所以让我们继续看一些更有趣的东西。让我们编写并测试一个函数，该函数可以展平嵌套字典结构。几年来，我一直与 Twitter 和 Facebook API 密切合作。处理如此庞大的数据结构并不容易，特别是因为它们通常嵌套得很深。事实证明，以一种在不丢失原始结构信息的情况下处理它们的方式展平它们，然后从展平结构重新创建嵌套结构，要容易得多。举个例子，我们想要这样的东西：

`data_flatten.py`

```py
nested = {
    'fullname': 'Alessandra',
    'age': 41,
    'phone-numbers': ['+447421234567', '+447423456789'],
    'residence': {
        'address': {
            'first-line': 'Alexandra Rd',
            'second-line': '',
        },
        'zip': 'N8 0PP',
        'city': 'London',
        'country': 'UK',
    },
}

flat = {
    'fullname': 'Alessandra',
    'age': 41,
    'phone-numbers': ['+447421234567', '+447423456789'],
    'residence.address.first-line': 'Alexandra Rd',
    'residence.address.second-line': '',
    'residence.zip': 'N8 0PP',
    'residence.city': 'London',
    'residence.country': 'UK',
}
```

像`flat`这样的结构更易于操作。在编写压扁器之前，让我们做一些假设：键是字符串，我们保持每个数据结构不变，除非它是字典，在这种情况下，我们压扁它，我们使用点作为分隔符，但我们希望能够将不同的一个传递给我们的函数。代码如下：

`data_flatten.py`

```py
def flatten(data, prefix='', separator='.'):
    """Flattens a nested dict structure. """
    if not isinstance(data, dict):
        return {prefix: data} if prefix else data

    result = {}
    for (key, value) in data.items():
        result.update(
            flatten(
                value,
                _get_new_prefix(prefix, key, separator),
                separator=separator))
    return result

def _get_new_prefix(prefix, key, separator):
    return (separator.join((prefix, str(key)))
            if prefix else str(key))
```

前面的例子并不难，但也不琐碎，所以让我们来看一下。首先，我们检查`data`是否是词典。如果它不是字典，那么它就是不需要展平的数据；因此，我们只需返回`data`或者，如果`prefix`不是空字符串，则返回一个具有一个键/值对的字典：`prefix`/`data`。

如果`data`是一个 dict，我们准备一个空的`result`dict 返回，然后我们解析`data`项的列表，我相信您会记得，它是两元组*（键，值）*。对于每个*（key，value）*对，我们递归地调用`flatten`，并用调用返回的内容更新`result`dict。当运行嵌套结构时，递归非常好。

乍一看，你能理解`_get_new_prefix`函数的作用吗？让我们再次使用由内而外的技术。我看到一个三元运算符，当`prefix`是空字符串时，它返回字符串化的`key`。另一方面，当`prefix`是非空字符串时，我们使用`separator`到`join`以及`key`的字符串化版本的`prefix`。注意，`join`调用中的括号不是多余的，我们需要它们。你能找出原因吗？

让我们为这个函数编写两个测试：

`tests/test_ch7/test_data_flatten.py`

```py
# ... imports omitted ...
class FlattenTestCase(TestCase):

    def test_flatten(self):
        test_cases = [
            ({'A': {'B': 'C', 'D': [1, 2, 3], 'E': {'F': 'G'}},
 'H': 3.14,
 'J': ['K', 'L'],
 'M': 'N'},
             {'A.B': 'C',
              'A.D': [1, 2, 3],
              'A.E.F': 'G',
              'H': 3.14,
              'J': ['K', 'L'],
              'M': 'N'}),
            (0, 0),
            ('Hello', 'Hello'),
            ({'A': None}, {'A': None}),
        ]
        for (nested, flat) in test_cases:
            assert_equal(flat, flatten(nested))

    def test_flatten_custom_separator(self):
        nested = {'A': {'B': {'C': 'D'}}}
        assert_equal(
            {'A#B#C': 'D'}, flatten(nested, separator='#'))
```

让我们从`test_flatten`开始。我定义了一个 2 元组的列表`(nested, flat)`，每个元组代表一个测试用例（为了便于阅读，我突出显示了`nested`。我有一个有三层嵌套的大 dict，然后是一些较小的数据结构，当传递到`flatten`函数时不会改变。这些测试用例可能不足以覆盖所有的边缘用例，但它们应该能让您很好地了解如何构建这样的测试。通过一个简单的`for`循环，我循环了每个测试用例，并断言`flatten(nested)`的结果等于`flat`。

### 提示

关于这个例子，有一点需要说明，当您运行它时，它将向您显示已经运行了两个测试。这实际上是不正确的，因为即使在技术上只有两个测试在运行，在其中一个测试中我们也有多个测试用例。最好让它们以一种被认为是独立的方式运行。这可以通过使用`nose-parameterized`之类的库来实现，我鼓励您查看。在[上 https://pypi.python.org/pypi/nose-parameterized](https://pypi.python.org/pypi/nose-parameterized) 。

我还提供了第二个测试，以确保自定义分隔符功能正常工作。如您所见，我只使用了一个数据结构，它要小得多。我们不需要再大做文章，也不需要测试其他边缘案例。记住，测试应该只确定一件事和一件事，而`test_flatten_custom_separator`只是负责验证我们是否可以为`flatten`函数提供不同的`separator`。

如果我有足够的空间，我可以继续喋喋不休地谈论另一本书的测试，但不幸的是，我们需要停在这里。我还没有告诉你关于**doctests**（文档中使用 Python 交互式 shell 风格编写的测试）以及关于这个主题的另外 50 万件事情。你必须自己去发现。

请查看`unittest`模块、`nose`和`nose-parameterized`库以及`pytest`（[的文档 http://pytest.org/](http://pytest.org/) ），你会没事的。根据我的经验，对于新手来说，模仿和修补似乎很难掌握，所以给自己一点时间来消化这些技术。试着慢慢地学习。

# 测试驱动开发

让我们简单谈谈关于**测试驱动开发**或**TDD**。肯特·贝克（Kent Beck）重新发现了这一方法论，他编写了*通过示例进行测试驱动开发*、*Addison Wesley–2002*，如果你想了解这门学科的基础知识，我鼓励你去看看，我对此非常着迷。

> *TDD 是一种基于持续重复非常短的开发周期的软件开发方法。*

首先，开发人员编写一个测试，并让它运行。测试应该检查尚未成为代码一部分的特性。可能是要添加的新功能，或者要删除或修改的内容。运行测试将使其失败，因此此阶段称为**红色**。

当测试失败时，开发人员编写最少的代码使其通过。当运行测试成功时，我们有所谓的**绿色**阶段。在这个阶段，编写作弊代码是可以的，只是为了让测试通过（这就是为什么要使用三角测量）。这种技术叫做*假装，直到你成功*。

这个周期的最后一部分是开发人员负责代码和测试（在不同的时间）并重构它们，直到它们处于所需的状态。最后一个阶段被称为**重构**。

因此**TDD 咒语**背诵了**红绿重构**。

起初，在编写代码之前编写测试感觉很奇怪，我必须承认我花了一段时间才习惯。但是，如果你坚持下去，强迫自己学习这种稍微违反直觉的工作方式，在某个时刻，一些几乎不可思议的事情发生了，你会看到代码的质量以一种不可能的方式提高。

当你在测试前编写代码时，你必须同时考虑*代码必须做什么*以及*它必须如何做*。另一方面，当您在编写代码之前编写测试时，您可以在编写测试时将注意力集中在*什么*部分。当您在之后编写代码时，您将主要考虑*代码如何实现*测试所需的*。这种注意力的转移可以让你的注意力集中在*什么*和*如何*部分在不同的时刻，从而提高大脑的能力，这将让你感到惊讶。*

采用这种技术还有其他几个好处：

*   **你将更加自信地进行重构**：因为当你接触代码时，你知道如果你把事情搞砸了，你至少会破坏一个测试。此外，您将能够在重构阶段处理架构设计，在重构阶段，作为守护者的测试将允许您享受对代码的处理，直到代码达到满足您的状态。
*   **代码将更具可读性**：这在我们这个时代是至关重要的，因为编码是一项社会活动，每个专业开发人员花在阅读代码上的时间比写代码要多得多。
*   **代码将更加松散耦合，更易于测试和维护**：这仅仅是因为编写测试首先会迫使您更深入地思考其结构。
*   **编写测试首先要求您更好地理解业务需求**：这是交付实际需求的基础。如果你对需求的理解缺乏信息，你会发现编写一个测试非常具有挑战性，这种情况对你来说就像一个哨兵。
*   **对所有内容进行单元测试意味着代码将更易于调试**：此外，小型测试非常适合提供替代文档。英语可能会产生误导，但在一个简单的测试中，Python 的五行代码很难被误解。
*   **更高的速度**：编写测试和代码比先编写代码，然后再浪费时间调试要快。如果您不编写测试，您可能会更快地交付代码，但随后您将不得不跟踪 bug 并解决它们（而且，请放心，将会有 bug）。编写代码然后进行调试所花费的时间通常比使用 TDD 开发代码所花费的时间要长，在 TDD 中，在编写代码之前要运行测试，以确保代码中的 bug 数量比其他情况下少得多。

另一方面，这种技术的主要缺点是：

*   **整个公司都需要相信它**：否则你将不得不不断与你的老板争论，老板不会理解你为什么要花这么长时间才能完成任务。事实是，短期内交付可能需要更长的时间，但从长远来看，TDD 会让您获益匪浅。然而，很难看到长期，因为它不像短期那样在我们的眼皮底下。在我的职业生涯中，为了能够使用 TDD 进行编码，我与顽固的老板进行过斗争。有时这是痛苦的，但总是值得的，我从不后悔，因为最终，结果的质量总是得到赞赏。
*   **如果您无法理解业务需求，这将反映在您编写的测试中，因此也会反映在代码中**：在您进行 UAT 之前，很难发现此类问题，但您可以做一件事来降低发生这种情况的可能性，那就是与其他开发人员合作。配对不可避免地需要讨论业务需求，这将有助于在编写测试之前更好地了解它们。
*   **糟糕的笔试很难维持**：这是事实。带有太多模拟、额外假设或结构不良数据的测试很快就会成为负担。不要因此而气馁；只要不断尝试并改变编写它们的方式，直到找到一种不需要每次接触代码都要做大量工作的方式。

我对 TDD 如此热情，以至于当我面试一份工作时，我总是问我即将加入的公司是否采纳了它。如果答案是否定的，这对我来说是一种破坏。我鼓励您查看并使用它。使用它，直到你感觉到有东西在你的脑海中点击。你不会后悔的，我保证。

# 例外情况

即使虽然我还没有正式介绍给你们，但我希望你们至少对**例外**有一个模糊的概念。在前面的章节中，我们已经看到当迭代器耗尽时，对其调用`next`会引发`StopIteration`异常。我们在尝试访问超出有效范围的位置的列表时遇到了`IndexError`。当我们试图访问一个没有属性的对象上的属性时，我们也遇到了`AttributeError`，当我们使用一个键和一个字典进行同样的操作时，我们也遇到了`KeyError`。我们在运行测试时也遇到了`AssertionError`。

现在，是我们讨论例外的时候了。

有时，即使一个操作或一段代码是正确的，也有可能出现错误的情况。例如，如果我们将用户输入从`string`转换为`int`，用户可能会意外地键入一个字母来代替数字，这使得我们无法将该值转换为数字。在除数时，我们可能事先不知道是否尝试用零除法。打开文件时，文件可能丢失或损坏。

在执行过程中检测到错误时，称为**异常**。例外不一定是致命的；事实上，我们已经看到，`StopIteration`被深入集成到 Python 生成器和迭代器机制中。但是，通常情况下，如果不采取必要的预防措施，异常将导致应用程序中断。有时，这是理想的行为，但在其他情况下，我们希望预防和控制此类问题。对于示例，我们可能会提醒用户，他们试图打开的文件已损坏或丢失，以便他们可以修复该文件或提供另一个文件，而无需应用程序因此问题而死亡。让我们来看几个例外的例子：

`exceptions/first.example.py`

```py
>>> gen = (n for n in range(2))
>>> next(gen)
0
>>> next(gen)
1
>>> next(gen)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>> print(undefined_var)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'undefined_var' is not defined
>>> mylist = [1, 2, 3]
>>> mylist[5]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
>>> mydict = {'a': 'A', 'b': 'B'}
>>> mydict['c']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'c'
>>> 1 / 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
```

正如您所看到的，pythonshell 非常宽容。我们可以看到`Traceback`，这样我们就有了关于错误的信息，但是程序没有死。这是一种特殊的行为，如果不处理异常，常规程序或脚本通常会死亡。

为了处理异常，Python 提供了`try`语句。当您输入`try`子句时，Python 将注意一种或多种不同类型的异常（根据您的指示），如果出现异常，它将允许您做出反应。`try`语句由打开该语句的`try`子句组成；一个或多个`except`条款（所有可选），定义捕获异常时的操作；`else`条款（可选），在`try`条款退出时执行，无任何例外提出；还有一个`finally`子句（可选），它的代码将被执行，而不管其他子句中发生了什么。`finally`子句通常用于清理资源。注意秩序，这很重要。此外，`try`后面必须至少有一个`except`子句或一个`finally`子句。让我们看一个例子：

`exceptions/try.syntax.py`

```py
def try_syntax(numerator, denominator):
    try:
        print('In the try block: {}/{}'
              .format(numerator, denominator))
        result = numerator / denominator
    except ZeroDivisionError as zde:
        print(zde)
    else:
        print('The result is:', result)
        return result
    finally:
        print('Exiting')

print(try_syntax(12, 4))
print(try_syntax(11, 0))
```

前面的示例定义了一个简单的`try_syntax`函数。我们执行两个数的除法。如果我们使用`denominator = 0`调用函数，我们准备捕获`ZeroDivisionError`异常。最初，代码进入`try`块。如果`denominator`不是`0`，则计算`result`并在离开`try`块后在`else`块中继续执行。我们打印`result`并返回。看看输出，您会注意到，在返回函数的退出点`result`之前，Python 执行`finally`子句。

当`denominator`为`0`时，情况会发生变化。我们进入`except`块并打印`zde`。`else`块未执行，因为在`try`块中引发了异常。在（隐式）返回`None`之前，我们仍然执行`finally`块。查看输出，看看它是否对您有意义：

```py
$ python exceptions/try.syntax.py 
In the try block: 12/4
The result is: 3.0
Exiting
3.0
In the try block: 11/0
division by zero
Exiting
None

```

当您执行`try`块时，您可能希望捕获多个异常。例如，当试图解码一个 JSON 对象时，您可能会因为格式错误的 JSON 而导致进入`ValueError`，或者如果您输入给`json.loads()`的数据类型不是字符串，则可能导致进入`TypeError`。在这种情况下，您可以这样构造代码：

`exceptions/json.example.py`

```py
import json
json_data = '{}'
try:
    data = json.loads(json_data)
except (ValueError, TypeError) as e:
    print(type(e), e)
```

此代码将捕获`ValueError`和`TypeError`。尝试将`json_data = '{}'`更改为`json_data = 2`或`json_data = '{{'`，您将看到不同的输出。

### 注

**JSON**代表**JavaScript 对象表示法**，是使用人类可读文本传输由键/值对组成的数据对象的开放标准格式。它是一种在应用程序之间移动数据时广泛使用的交换格式，尤其是当数据需要以与语言或平台无关的方式处理时。

如果您想以不同的方式处理多个异常，只需添加更多的`except`子句，如下所示：

`exceptions/multiple.except.py`

```py
try:
    # some code
except Exception1:
    # react to Exception1
except (Exception2, Exception3):
    # react to Exception2 and Exception3
except Exception3:
    # react to Exception3
...
```

请记住，异常是在定义该异常类或其任何基的第一个块中处理的。因此，当您像我们刚刚做的那样堆叠多个`except`子句时，请确保将特定异常放在顶部，将一般异常放在底部。用面向对象的术语来说，孩子在上面，祖父母在下面。此外，请记住，当引发异常时，只执行一个`except`处理程序。

您还可以编写**自定义异常**。为了做到这一点，您只需从任何其他异常类继承。Python 内置异常太多，无法在此列出，因此我必须向您指出官方文档。需要知道的一件重要事情是，每个 Python 异常都源自`BaseException`，但您的自定义异常永远不应该直接从该异常继承。原因是处理这样的异常也会捕获**系统退出**的异常如`SystemExit`和`KeyboardInterrupt`，这些异常源于`BaseException`，这可能会导致严重的问题。如果发生灾难，您希望能够*Ctrl*+*C*退出应用程序。

您可以通过从`Exception`继承来轻松解决问题，该`Exception`继承自`BaseException`，但其子项中不包含任何系统退出异常，因为它们是内置异常层次结构中的同级（请参见[https://docs.python.org/3/library/exceptions.html#exception-层次结构](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)。

使用异常编程可能非常棘手。您可能会无意中消除错误，或捕获不需要处理的异常。为了安全起见，请记住一些准则：始终只在`try`子句中输入可能导致您要处理的异常的代码。当你写`except`条款时，要尽可能具体，不要因为简单就诉诸`except Exception`。使用测试确保您的代码以尽可能少的异常处理量处理边缘情况。编写不指定任何异常的`except`语句将捕获任何异常，因此，当您从`BaseException`派生自定义异常时，您的代码将面临相同的风险。

你可以在网上到处找到关于异常的信息。一些编码人员大量使用它们，而另一些则很少使用（我属于后一类）。通过从别人的源代码中获取示例，找到自己处理这些问题的方法。有大量的有趣的项目，它们的来源是开放的，你可以在任何一个 GitHub（[上找到它们 https://github.com](https://github.com) 或比特桶（[https://bitbucket.org/](https://bitbucket.org/) ）。

在我们讨论关于**评测**之前，让我向您展示异常的一种非常规用法，只是为了给您一些帮助，帮助您扩展对异常的看法。它们不仅仅是错误。

`exceptions/for.loop.py`

```py
n = 100
found = False
for a in range(n):
    if found: break
    for b in range(n):
        if found: break
        for c in range(n):
            if 42 * a + 17 * b + c == 5096:
                found = True
                print(a, b, c)  # 79 99 95
```

如果处理数字，前面的代码是一个非常常见的习惯用法。您必须迭代几个嵌套范围，并查找满足条件的`a`、`b`和`c` 的特定组合。在这个例子中，条件是一个简单的线性方程，但想象一下比这个更酷的东西。让我感到困扰的是，在每个循环开始时都必须检查是否找到了解决方案，以便在找到解决方案时尽快摆脱它们。中断逻辑会干扰代码的其余部分，我不喜欢它，所以我为此想出了一个不同的解决方案。看看它，看看你是否也能把它应用到其他情况。

`exceptions/for.loop.py`

```py
class ExitLoopException(Exception):
 pass

try:
    n = 100
    for a in range(n):
        for b in range(n):
            for c in range(n):
                if 42 * a + 17 * b + c == 5096:
                    raise ExitLoopException(a, b, c)
except ExitLoopException as ele:
    print(ele)  # (79, 99, 95)
```

你能看到它有多优雅吗？现在，突破逻辑完全由一个简单的异常来处理，该异常的名称甚至暗示了它的用途。一旦发现结果，我们就提出它，并立即将控制权交给处理它的 EXPECT 子句。这是值得深思的。这个例子间接地向您展示了如何引发自己的异常。阅读官方文件，深入了解这个主题的美丽细节。

# 剖析 Python

有几种不同的方法来评测 Python 应用程序。评测意味着让应用程序运行，同时跟踪几个不同的参数，如函数的调用次数、函数内部花费的时间等。分析可以帮助我们发现应用程序中的瓶颈，这样我们就可以只改进真正让我们慢下来的东西。

如果您查看标准库官方文档中的评测部分，您将看到相同评测接口有两种不同的实现：`profile`和`cProfile`。

*   `cProfile`建议大多数用户使用，它是一个具有合理开销的 C 扩展，适合评测长时间运行的程序
*   `profile`是一个纯 Python 模块，其接口被`cProfile`模仿，但这会给分析程序增加大量开销

此接口执行**决定论评测**，这意味着所有函数调用、函数返回和异常事件都会被监控，并对这些事件之间的间隔进行精确计时。另一种称为**统计分析**的方法，对有效的指令指针进行随机采样，并推断时间花费在何处。

后者通常涉及较少的开销，但只提供近似的结果。此外，由于 Python 解释器运行代码的方式，确定性评测不会像人们想象的那样增加那么多开销，因此我将从命令行向您展示一个使用`cProfile`的简单示例。

我们将使用以下代码计算毕达哥拉斯三元组（我知道，您错过了它们…）：

`profiling/triples.py`

```py
def calc_triples(mx):
    triples = []
    for a in range(1, mx + 1):
        for b in range(a, mx + 1):
            hypotenuse = calc_hypotenuse(a, b)
            if is_int(hypotenuse):
                triples.append((a, b, int(hypotenuse)))
    return triples

def calc_hypotenuse(a, b):
    return (a**2 + b**2) ** .5

def is_int(n):  # n is expected to be a float
    return n.is_integer()

triples = calc_triples(1000)
```

剧本非常简单；我们使用`a`和`b`（通过设置`b >= a`避免成对重复）在区间[1、*mx*上迭代，并检查它们是否属于直角三角形。我们用`calc_hypotenuse`得到`a`和`b`的`hypotenuse`，然后用`is_int`检查它是否是整数，这意味着（*a*、*b*、*c*是毕达哥拉斯三元组。当我们分析这个脚本时，我们以表格形式获得信息。列为`ncalls`、`tottime`、`percall`、`cumtime`、`percall`和`filename:lineno(function)`。它们表示我们对一个函数调用的数量，我们在其中花费的时间，等等。我将修剪两列以节省空间，因此，如果您自己运行分析，请不要担心是否会得到不同的结果。

```py
$ python -m cProfile profiling/triples.py
1502538 function calls in 0.750 seconds
Ordered by: standard name
ncalls  tottime  percall filename:lineno(function)
500500    0.469    0.000 triples.py:14(calc_hypotenuse)
500500    0.087    0.000 triples.py:18(is_int)
 1    0.000    0.000 triples.py:4(<module>)
 1    0.163    0.163 triples.py:4(calc_triples)
 1    0.000    0.000 {built-in method exec}
 1034    0.000    0.000 {method 'append' of 'list' objects}
 1    0.000    0.000 {method 'disable' of '_lsprof.Profil...
500500    0.032    0.000 {method 'is_integer' of 'float' objects}

```

即使数据量有限，我们仍然可以推断出有关此代码的一些有用信息。首先，我们可以看到我们选择的算法的时间复杂度随着输入大小的平方而增长。我们进入内环体的次数正好是*mx（mx+1）/2*。我们使用`mx = 1000`运行脚本，这意味着我们在内部`for`循环中得到`500500`次。在这个循环中发生了三件主要的事情，我们称之为`calc_hypotenuse`，我们称之为`is_int`，如果条件满足，我们将附加到`triples`列表中。

查看分析报告，我们注意到算法在`calc_hypotenuse`中花费了`0.469`秒，这比在`is_int`中花费的`0.087`秒要多，因为它们被调用的次数相同，所以让我们看看是否可以稍微提高`calc_hypotenuse`。

事实证明，我们可以。正如我在本书前面提到的，power operator`**`非常昂贵，在`calc_hypotenuse,`中我们使用了三次。幸运的是，我们可以很容易地将其中两个转换为简单的乘法，如下所示：

`profiling/triples.py`

```py
def calc_hypotenuse(a, b):
    return (a*a + b*b) ** .5
```

这个简单的改变应该会有所改善。如果我们再次运行分析，我们会看到，`0.469`现在下降到`0.177`。不错！这意味着现在我们在`calc_hypotenuse`内的时间与以前一样只有 37%。

让我们看看我们是否也可以通过如下方式来改进`is_int`：

`profiling/triples.py`

```py
def is_int(n):
    return n == int(n)
```

这种实现是不同的，优点是当`n`是整数时它也可以工作。唉，当我们对它运行评测时，我们看到在`is_int`函数中花费的时间已经上升到`0.141`秒。这意味着它比以前大约翻了一番。在这种情况下，我们需要恢复到以前的实现。

当然，这个示例并不重要，但足以向您展示如何分析应用程序。对函数执行的调用数量有助于我们更好地理解算法的时间复杂性。例如，你不会相信有多少编码器看不到这两个`for`循环与输入大小的平方成比例地运行。

值得一提的是：根据您使用的系统，结果可能会有所不同。因此，能够在一个尽可能接近软件部署的系统上（如果不是在该系统上）评测软件是非常重要的。

## 什么时候进行简介？

剖析非常酷，但我们需要知道什么时候适合这样做，以及我们需要用什么方法来解决我们从中得到的结果。

Donald Knuth 曾经说过，*过早优化是万恶之源*，尽管我不会这么彻底地否定它，但我确实同意他的观点。毕竟，我是谁，不同意那个给我们*计算机编程艺术*、*TeX*和一些我在大学时学习过的最酷的算法的人？

所以，首先也是最重要的是：*正确性*。您希望您的代码能够正确地交付结果，因此需要编写测试、查找边缘案例，并以您认为有意义的方式强调您的代码。不要保护自己，不要因为你认为事情不太可能发生，就把事情放在你的后脑勺里等着以后再做。要彻底。

其次，注意编码*最佳实践*。记住可读性、可扩展性、松耦合性、模块化和设计。应用 OOP 原则：封装、抽象、单一责任、打开/关闭等。仔细阅读这些概念。它们将为您打开视野，并扩展您思考代码的方式。

第三，*像野兽一样重构！*童子军规则要求*始终保持营地比你发现的干净*。将此规则应用于代码。

最后，当以上所有的问题都解决了，然后，也只有到了那时，你才能处理分析。

运行探查器并确定瓶颈。当你对需要解决的瓶颈有了一个想法后，首先从最糟糕的瓶颈开始。有时，修复瓶颈会产生连锁反应，从而扩展并改变其余代码的工作方式。根据代码的设计和实现方式，有时这只是一点点，有时甚至更多。因此，首先从最大的问题开始。

Python 如此流行的原因之一是，可以用多种不同的方式实现它。因此，如果您发现自己在使用纯粹的 Python 增强代码的某些部分时遇到困难，那么没有什么可以阻止您卷起袖子，买几百升咖啡，然后用 C 重写缓慢的代码。这肯定很有趣！

# 总结

在本章中，我们探讨了测试、异常和分析的世界。

我试图给你一个相当全面的测试概述，特别是单元测试，这是开发人员通常做的测试。我希望我已经成功地传达了这样一个信息：测试并不是一个完美定义的东西，你可以从一本书中学习。在你感到舒适之前，你需要做很多实验。在程序员在研究和实验方面必须做出的所有努力中，我认为测试是最值得的。

我们简要介绍了如何防止程序因运行时发生的错误（称为异常）而死亡。为了避开通常的情况，我给了你们一个例子，有点非常规地使用异常来打破嵌套的`for`循环。这不是唯一的情况，我相信随着你成为一名程序员，你会发现其他的情况。

最后，我们用一个简单的例子和一些指导原则简要地讨论了基于概要分析的基础。为了完整性起见，我想谈谈评测，这样至少你可以玩转它。

我们现在即将进入[第 8 章](07.html "Chapter 8\. The Edges – GUIs and Scripts")*边缘——GUI 和脚本*，在这里我们将用脚本和 GUI 弄脏我们的手，希望能想出一些有趣的东西。

### 注

我知道我在这一章中给了你很多指示，没有任何链接或方向。恐怕这是我的选择。作为一名编码员，在工作的每一天里，你都不必在文档页面、手册、网站等上查找内容。我认为对于一个程序员来说，能够有效地搜索他们需要的信息是至关重要的，所以我希望你能原谅我的额外培训。毕竟，这都是为了你的利益。