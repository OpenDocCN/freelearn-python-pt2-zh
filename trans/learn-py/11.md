# 第 12 章。总结——一个完整的例子

|  | *“不要停留在过去，不要梦想未来，将注意力集中在当下。”* |  |
|  | --*释迦牟尼佛* |

在本章中，我将向您展示最后一个项目。如果你在本书的其余部分做得很好，这个例子应该很简单。我尽了最大的努力来设计它，这样对那些只读过这本书的人来说，它既不会太难，也不会太简单，对于那些花时间做例子的人来说，也许已经阅读了我建议的链接和主题。

# 挑战

现在我们都有一个问题，就是记住密码。我们拥有所有东西的密码：网站、电话、卡、银行账户等等。我们需要记住的信息太多了，所以很多人都会一次又一次地使用同一个密码。当然，这是非常糟糕的，所以在某个时候，人们发明了工具来缓解这个问题。其中一个工具叫做**KeepassX**，它的工作原理基本上是这样的：您通过设置一个名为**主密码**的特殊密码来启动软件。一旦进入，您将为需要记住的每个密码存储一个记录，例如，您的电子邮件帐户、银行网站、信用卡信息等。当您关闭软件时，它会加密用于存储所有这些信息的数据库，因此数据只能由主密码的所有者访问。因此，在某种*指环王*的方式下，只要拥有一个密码，你就可以统治所有密码。

# 我们的实施

本章中我们的目标是创建类似但基于 web 的内容，而我想要实现它的方式是编写两个应用程序。

一个是用 Falcon 编写的 API。它的用途有两个，它将能够生成和验证密码。它将向调用者提供有关密码有效性的信息和一个分数，该分数应指示密码的强度。

第二个应用程序是 Django 网站，它将提供处理记录的界面。每个记录将保留诸如用户名、电子邮件、密码、URL 等信息。它将显示所有记录的列表，并允许用户创建、更新和删除这些记录。密码将在存储到数据库之前进行加密。

因此，整个项目的目的是模仿 KeepassX 的工作方式，尽管它的工作方式要简单得多。如果您喜欢这个想法，您将决定进一步开发它，以便添加其他功能并使其更加安全。最后，我一定会给你一些关于如何扩展它的建议。

因此，本章将非常密集，代码方面。这是我为在有限的空间里给你一个有趣的例子所付出的代价。

在我们开始之前，请确保您对[第 10 章](09.html "Chapter 10\. Web Development Done Right")*Web 开发正确*中介绍的项目感到满意，以便您熟悉 Web 开发的基础知识。确保您已经安装了本项目所需的所有`pip`软件包：`django`、`falcon`、`cryptography`和`nose-parameterized`。如果您下载本书的源代码，您将在`requirements`文件夹中找到需要安装的所有内容，而本章的代码将在`ch12`文件夹中。

# 实现 Django 接口

我希望您对[第 10 章](09.html "Chapter 10\. Web Development Done Right")中提出的概念感到满意*Web 开发正确*主要是关于 Django 的。如果你还没有读过，这可能是一个很好的时间，在这里阅读之前。

## 设置

在您的根文件夹（`ch12`，对于我来说），其中将包含接口的根目录和 API 的根目录，首先运行以下命令：

```py
$ django-admin startproject pwdweb

```

这将为 Django 项目创建一个结构，我们现在已经很清楚了。我将在这里向您展示接口项目的最终结构：

```py
$ tree -A pwdweb
pwdweb
├── db.sqlite3
├── manage.py
├── pwdweb
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── records
 ├── admin.py
 ├── forms.py
 ├── __init__.py
 ├── migrations
 │   ├── 0001_initial.py
 │   └── __init__.py
 ├── models.py
 ├── static
 │   └── records
 │       ├── css
 │       │   └── main.css
 │       └── js
 │           ├── api.js
 │           └── jquery-2.1.4.min.js
 ├── templates
 │   └── records
 │       ├── base.html
 │       ├── footer.html
 │       ├── home.html
 │       ├── list.html
 │       ├── messages.html
 │       ├── record_add_edit.html
 │       └── record_confirm_delete.html
 ├── templatetags
 │   └── record_extras.py
 ├── urls.py
 └── views.py

```

像往常一样，不要担心如果你没有所有的文件，我们会逐渐添加它们。更改到`pwdweb`文件夹，并确保 Django 已正确设置：`$ python manage.py runserver`（忽略有关未应用迁移的警告）。

关闭服务器并创建应用程序：`$ python manage.py startapp records`。太好了，现在我们可以开始编码了。首先，让我们打开`pwdweb/settings.py`并在`INSTALLED_APP`元组的末尾添加`'records'`（请注意，代码中包含逗号）。然后，继续并根据您的偏好修复`LANGUAGE_CODE`和`TIME_ZONE`设置，最后在底部添加以下行：

```py
ENCRYPTION_KEY = b'qMhPGx-ROWUDr4veh0ybPRL6viIUNe0vcPDmy67x6CQ='
```

这是一个与 Django 设置无关的自定义加密密钥，但我们稍后将需要它，这是它的最佳位置。现在别担心，我们会回去的。

## 模型层

我们只需要为记录应用程序添加一个模型：`Record`。此模型将表示我们要存储在数据库中的每条记录：

`records/models.py`

```py
from cryptography.fernet import Fernet
from django.conf import settings
from django.db import models

class Record(models.Model):
    DEFAULT_ENCODING = 'utf-8'

    title = models.CharField(max_length=64, unique=True)
    username = models.CharField(max_length=64)
    email = models.EmailField(null=True, blank=True)
    url = models.URLField(max_length=255, null=True, blank=True)
    password = models.CharField(max_length=2048)
    notes = models.TextField(null=True, blank=True)
    created = models.DateTimeField(auto_now_add=True)
    last_modified = models.DateTimeField(auto_now=True)

    def encrypt_password(self):
        self.password = self.encrypt(self.password)

    def decrypt_password(self):
        self.password = self.decrypt(self.password)

    def encrypt(self, plaintext):
        return self.cypher('encrypt', plaintext)

    def decrypt(self, cyphertext):
        return self.cypher('decrypt', cyphertext)

    def cypher(self, cypher_func, text):
        fernet = Fernet(settings.ENCRYPTION_KEY)
        result = getattr(fernet, cypher_func)(
            self._to_bytes(text))
        return self._to_str(result)

    def _to_str(self, bytes_str):
        return bytes_str.decode(self.DEFAULT_ENCODING)

    def _to_bytes(self, s):
        return s.encode(self.DEFAULT_ENCODING)
```

首先，我们将`DEFAULT_ENCODING`类属性设置为`'utf-8'`，这是 web（不仅仅是 web）最流行的编码类型。我们在类上设置此属性以避免在多个位置硬编码字符串。

然后，我们继续设置模型的所有字段。如您所见，Django 允许您指定非常特定的字段，例如`EmailField`和`URLField`。使用这些特定字段而不是简单明了的`CharField`更好的原因是，当我们为这个模型创建表单时，我们将免费获得电子邮件和 URL 验证，这非常棒。

所有选项都非常标准，我们在[第 10 章](09.html "Chapter 10\. Web Development Done Right")中看到了这些选项，*Web 开发做得很好*，但我还是想指出一些事情。首先，`title`需要是唯一的，这样每个`Record`对象都有一个唯一的标题，我们不想冒双重的风险。每个数据库对字符串的处理都略有不同，这取决于它的设置方式、运行的引擎等等，所以我没有将`title`字段作为这个模型的主键，这是很自然的事情。我更喜欢避免处理奇怪的字符串错误的痛苦，我很高兴让 Django 自动向模型添加主键。

你应该了解的另一个选择是`null=True, blank=True`夫妇。前者允许字段为`NULL`，这使其非强制性，而第二个允许字段为*空白*（即空字符串）。它们在 Django 中的使用非常特殊，因此我建议您查看官方文档，以准确了解如何使用它们。

最后，日期：`created`需要有`auto_add_now=True`，这将在创建对象时设置对象的当前时间。另一方面，`last_modified`需要在每次保存模型时更新，因此我们设置了`auto_now=True`。

在字段定义之后，有几种加密和解密密码的方法。将密码保存在数据库中总是一个非常糟糕的主意，因此在保存密码之前，您应该始终对其进行加密。

通常情况下，当保存密码时，使用**单向加密**算法（也称为**单向散列函数**进行加密）。这意味着，一旦创建了哈希，就无法将其恢复为原始密码。

这种加密通常用于身份验证：用户将用户名和密码放入表单中，提交时，代码从数据库中的用户记录中获取哈希值，并将其与用户刚刚放入表单中的密码哈希值进行比较。如果两个哈希匹配，则表示它们是由相同的密码生成的，因此授予身份验证。

但是在这种情况下，我们需要能够恢复密码，否则整个应用程序将不会非常有用。因此，我们将使用所谓的**对称加密**算法对其进行加密。的工作方式非常简单：密码（称为**明文**）与*密钥*一起传递给*加密*函数。该算法从它们中生成一个加密的字符串（称为**cyphertext**），这就是您存储在数据库中的内容。当您想要恢复密码时，需要密码和密钥。你把它们输入到一个*解密*函数，然后你就可以找回你原来的密码。这正是我们需要的。

为了执行对称加密，我们需要`cryptography`包，这就是我指示您安装它的原因。

`Record`类中的所有方法都非常简单。`encrypt_password`和`decrypt_password`是`encrypt`和`decrypt`到`password`字段的快捷方式，并将结果重新分配给自身。

`encrypt`和`decrypt`方法是`cypher`方法的调度器，`_to_str`和`_to_bytes`只是一对助手。`cryptography`库处理*字节*对象，因此我们需要这些助手使用通用编码在字节和字符串之间来回移动。

唯一有趣的逻辑是`cypher`方法。我可以直接在`encrypt`和`decrypt`中进行编码，但这会导致一些冗余，而且我没有机会向您展示访问对象属性的不同方式，所以让我们分析`cypher`的主体。

我们首先创建一个`Fernet`类的实例，它为我们提供了所需的对称加密功能。我们通过在设置（`ENCRYPTION_KEY`中传递密钥来设置实例。创建`fernet`后，我们需要使用它。根据`cypher_func`参数的值，我们可以使用它进行加密或解密。我们使用`getattr`从给定对象本身和属性名称的对象中获取属性。这种技术允许我们动态地从对象中获取任何属性。

`getattr(fernet, cypher_func)`的结果，例如`cyper_func`为`'encrypt'`，与`fernet.encrypt`相同。`getattr`函数返回一个方法，然后使用文本参数的字节表示调用该方法。然后以字符串格式返回结果。

以下是加密调度器调用此函数时的等效功能：

```py
def cypher_encrypt(self, text):
        fernet = Fernet(settings.ENCRYPTION_KEY)
        result = fernet.encrypt(
            self._to_bytes(text))
        return self._to_str(result)
```

当你花时间去正确理解它时，你会发现它并不像听起来那么难。

因此，我们有了我们的模型，因此是时候迁移了（我希望您记住，这将在数据库中为您的应用程序创建表）：

```py
$ python manage.py makemigrations
$ python manage.py migrate

```

现在，您应该有一个很好的数据库，其中包含运行接口应用程序所需的所有表。继续并创建一个超级用户（`$ python manage.py createsuperuser`。

顺便说一句，如果您想生成自己的加密密钥，它非常简单，如下所示：

```py
>>> from cryptography.fernet import Fernet
>>> Fernet.generate_key()

```

## 简单的形式

我们需要一个`Record`模型的表单，所以我们将使用[第 10 章](09.html "Chapter 10\. Web Development Done Right")中看到的`ModelForm`技术，*Web 开发完成正确*。

`records/forms.py`

```py
from django.forms import ModelForm, Textarea
from .models import Record

class RecordForm(ModelForm):
    class Meta:
        model = Record
        fields = ['title', 'username', 'email', 'url',
                  'password', 'notes']
        widgets = {'notes': Textarea(
            attrs={'cols': 40, 'rows': 4})}
```

我们创建了一个继承自`ModelForm`的`RecordForm`类，由于 Django 的内省功能，表单可以自动创建。我们只指定要使用的模型、要显示的字段（我们不包括日期，这些字段是自动处理的），并且我们为 notes 字段的维度提供最小样式，这些字段将使用`Textarea`（HTML 中的多行文本字段）显示。

## 视图层

接口应用共有五页：首页、记录列表、记录创建、记录更新、记录删除确认。因此，我们必须写五种观点。稍后您将看到，Django 为我们提供了许多视图，这些视图可以以最少的定制重复使用。下面的所有代码都属于`records/views.py`文件。

### 导入和主视图

为了打破僵局，这里是主页的导入和视图：

```py
from django.contrib import messages
from django.contrib.messages.views import SuccessMessageMixin
from django.core.urlresolvers import reverse_lazy
from django.views.generic import TemplateView
from django.views.generic.edit import (
    CreateView, UpdateView, DeleteView)
from .forms import RecordForm
from .models import Record

class HomeView(TemplateView):
    template_name = 'records/home.html'
```

我们从 Django 进口了一些工具。有两个与消息传递相关的对象、一个 URL 延迟反向器和四种不同类型的视图。我们还进口了我们的`Record`型号和`RecordForm`型号。正如您所看到的，`HomeView`类只包含两行代码，因为我们只需要指定要使用的模板，其余的只是重用`TemplateView`中的代码。这太容易了，感觉就像作弊一样。

### 列出所有记录

在主视图之后，我们可以编写一个视图来列出数据库中的所有`Record`实例。

```py
class RecordListView(TemplateView):
    template_name = 'records/list.html'

    def get(self, request, *args, **kwargs):
        context = self.get_context_data(**kwargs)
        records = Record.objects.all().order_by('title')  #1
        for record in records:
            record.plaintext = record.decrypt(record.password) #2
        context['records'] = records
        return self.render_to_response(context)
```

我们需要做的就是再次子类`TemplateView`，并重写`get`方法。我们需要做两件事：我们从数据库中获取所有记录，并按`title`（`#1`）对它们进行排序，然后解析所有记录，以便在每个记录上添加`plaintext`（`#2`）属性，在页面上显示原始密码。另一种方法是向`Record`模型添加只读属性，以便动态解密。作为一个有趣的练习，我将把修改代码的任务留给您。

恢复和扩充记录后，我们将它们放入`context`dict 中，并通过调用`render_to_response`像往常一样完成。

### 创建记录

以下是创建视图的代码：

```py
class EncryptionMixin:
    def form_valid(self, form):
        self.encrypt_password(form)
        return super(EncryptionMixin, self).form_valid(form)

    def encrypt_password(self, form):
        self.object = form.save(commit=False)
        self.object.encrypt_password()
        self.object.save()

class RecordCreateView(
        EncryptionMixin, SuccessMessageMixin, CreateView):
    template_name = 'records/record_add_edit.html'
    form_class = RecordForm
    success_url = reverse_lazy('records:add')
    success_message = 'Record was created successfully'
```

它的一部分逻辑已经分解出来，以便以后在更新视图中重用。让我们从`EncryptionMixin`开始。它所做的只是重写`form_valid`方法，这样，在将新的`Record`实例保存到数据库之前，我们确保对保存表单后产生的对象调用`encrypt_password`。换句话说，当用户提交表单以创建新的`Record`时，如果表单验证成功，则调用`form_valid`方法。在该方法中，通常会发生的情况是从`ModelForm`实例创建一个对象，如下所示：

```py
self.object = form.save()
```

我们需要干预此行为，因为按原样运行此代码将使用未加密的原始密码保存记录。所以我们将其更改为在`form`传递`commit=False`时调用`save`，这会在`form`之外创建`Record`实例，但不会尝试将其保存在数据库中。紧接着，我们对该实例上的密码进行加密，然后我们最终可以对其调用 save，实际上将其提交到数据库。

因为我们在创建和更新记录时都需要这种行为，所以我在 mixin 中对其进行了分析。

### 注

也许，这个密码加密逻辑更好的解决方案是创建一个自定义的`Field`（从`CharField`继承是最简单的方法），并向其添加必要的逻辑，这样当我们处理数据库中的`Record`实例时，加密和解密逻辑会自动为我们执行。虽然这个解决方案更加优雅，但需要我离题，对 Django 内部进行更多的解释，这对于本例来说太多了。像往常一样，如果你想挑战的话，你可以试着自己去做。

创建`EncryptionMixin`类后，我们可以在`RecordCreateView`类中使用它。我们还继承了另外两个类：`SuccessMessageMixin`和`CreateView`。消息 mixin 为我们提供了在创建成功时快速设置消息的逻辑，`CreateView`为我们提供了从表单创建对象所需的逻辑。

您可以看到，我们需要编写的只是一些定制：模板名称、表单类以及成功消息和 URL。其他一切都由 Django 优雅地为我们处理。

### 更新记录

更新`Record`实例的代码只是稍微复杂一点。在用记录数据填充表单之前，我们只需要添加一些逻辑来解密密码。

```py
class RecordUpdateView(
        EncryptionMixin, SuccessMessageMixin, UpdateView):
    template_name = 'records/record_add_edit.html'
    form_class = RecordForm
    model = Record
    success_message = 'Record was updated successfully'

    def get_context_data(self, **kwargs):
        kwargs['update'] = True
        return super(
            RecordUpdateView, self).get_context_data(**kwargs)

    def form_valid(self, form):
        self.success_url = reverse_lazy(
            'records:edit',
            kwargs={'pk': self.object.pk}
        )
        return super(RecordUpdateView, self).form_valid(form)

    def get_form_kwargs(self):
        kwargs = super(RecordUpdateView, self).get_form_kwargs()
        kwargs['instance'].decrypt_password()
        return kwargs
```

在这个视图中，我们仍然从`EncryptionMixin`和`SuccessMessageMixin`继承，但是我们使用的视图类是`UpdateView`。

前四行和前面一样是定制，我们设置了模板名称、表单类、`Record`模型和成功消息。我们无法将`success_url`设置为类属性，因为我们希望将成功的编辑重定向到该记录的同一编辑页面，为此，我们需要正在编辑的实例的 ID。别担心，我们会用另一种方式。

首先，我们重写`get_context_data`，以便在`kwargs`参数中将`'update'`设置为`True`，这意味着一个键`'update'`将在`context`dict 中结束，该 dict 被传递给模板以呈现页面。我们这样做是因为我们希望使用相同的模板来创建和更新记录，因此我们将在上下文中使用此变量，以便能够理解我们所处的情况。有其他方法可以做到这一点，但这一个是快速和简单的，我喜欢它，因为它是明确的。

重写`get_context_data,`后，我们需要处理 URL 重定向。我们在`form_valid`方法中这样做，因为我们知道，如果我们到达那里，这意味着`Record`实例已经成功更新。我们反转`'records:edit'`视图，这正是我们正在处理的视图，传递相关对象的主键。我们从`self.object.pk`中获取该信息。

将对象保存在视图实例上很有帮助的原因之一是，我们可以在需要时使用它，而不必为了传递对象而更改视图中许多方法的签名。这种设计非常有帮助，允许我们用很少的代码行实现很多功能。

我们需要做的最后一件事是在为用户填充表单之前解密实例上的密码。在`get_form_kwargs`方法中进行此操作非常简单，您可以访问`kwargs`dict 中的`Record`实例，并对其调用`decrypt_password`。

这就是更新记录所需要做的一切。如果您仔细想想，由于基于 Django 类的视图，我们必须编写的代码量实际上非常少。

### 提示

了解哪种方法是最好的重写方法的一个好方法是查看 Django 官方文档，或者在本例中更好地查看源代码并查看基于类的视图部分。您将能够了解 Django 开发人员在这方面做了多少工作，因此您只需使用最少的代码即可自定义视图。

### 删除记录

在三个动作中，删除记录绝对是最简单的一个。我们只需要以下代码：

```py
class RecordDeleteView(SuccessMessageMixin, DeleteView):
    model = Record
    success_url = reverse_lazy('records:list')

    def delete(self, request, *args, **kwargs):
        messages.success(
            request, 'Record was deleted successfully')
        return super(RecordDeleteView, self).delete(
            request, *args, **kwargs)
```

我们只需要继承`SuccessMessageMixin`和`DeleteView`，这就给了我们所需要的一切。我们将模型和成功 URL 设置为类属性，然后重写`delete`方法，只添加一条显示在列表视图中的好消息（删除后重定向到列表视图）。

我们不需要指定模板名称，因为我们将使用 Django 默认推断的名称：`record_confirm_delete.html`。

有了这最后一个视图，我们都有了一个很好的界面，可以用来处理`Record`实例。

## 设置 URL

在进入模板层之前，让我们先设置 URL。这一次，我想向大家展示我在[第 10 章](09.html "Chapter 10\. Web Development Done Right")中提到的包含技术，*Web 开发正确*。

`pwdweb/urls.py`

```py
from django.conf.urls import include, url
from django.contrib import admin
from records import urls as records_url
from records.views import HomeView

urlpatterns = [
    url(r'^admin/', include(admin.site.urls)),
    url(r'^records/', include(records_url, namespace='records')),
    url(r'^$', HomeView.as_view(), name='home'),
]
```

这些是主项目的 URL。我们有一个普通的管理员，一个主页，然后对于记录部分，我们包括另一个`urls.py`文件，我们在`records`应用程序中定义了这个文件。这种技术允许应用程序可重用且自包含。请注意，当包含另一个`urls.py`文件时，可以传递名称空间信息，然后可以在`reverse`或`url`模板标记等函数中使用。例如，我们已经看到通往`RecordUpdateView`的路径是`'records:edit'`。该字符串的第一部分是名称空间，第二部分是我们为视图指定的名称，如以下代码所示：

`records/urls.py`

```py
from django.conf.urls import include, url
from django.contrib import admin
from .views import (RecordCreateView, RecordUpdateView,
                    RecordDeleteView, RecordListView)

urlpatterns = [
    url(r'^add/$', RecordCreateView.as_view(), name='add'),
    url(r'^edit/(?P<pk>[0-9]+)/$', RecordUpdateView.as_view(),
        name='edit'),
    url(r'^delete/(?P<pk>[0-9]+)/$', RecordDeleteView.as_view(),
        name='delete'),
    url(r'^$', RecordListView.as_view(), name='list'),
]
```

我们定义了四个不同的`url`实例。有一个用于添加记录，它不需要主键信息，因为对象还不存在。然后我们有两个`url`实例用于更新和删除记录，对于这些实例，我们还需要指定要传递给视图的主键信息。由于`Record`实例具有整数 ID，我们可以按照良好的 URL 设计实践，在 URL 上安全地传递它们。最后，我们为记录列表定义一个`url`实例。

所有`url`实例都有`name`信息，用于视图和模板中。

## 模板层

让我们从模板开始，我们将使用该模板作为其余部分的基础：

`records/templates/records/base.html`

```py
{% load static from staticfiles %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">
    <link href="{% static "records/css/main.css" %}"
          rel="stylesheet">
    <title>{% block title %}Title{% endblock title %}</title>
  </head>

  <body>
    <div id="page-content">
      {% block page-content %}{% endblock page-content %}
    </div>
    <div id="footer">{% block footer %}{% endblock footer %}</div>
    {% block scripts %}
 <script
 src="{% static "records/js/jquery-2.1.4.min.js" %}">
 </script>
 {% endblock scripts %}
  </body>
</html>
```

它与我在[第 10 章](09.html "Chapter 10\. Web Development Done Right")中使用的*Web 开发正确*中使用的非常相似，尽管它有点压缩，并且有一个主要区别。我们将在每个页面中导入 jQuery。

### 注

jQuery 是最流行的 JavaScript 库。它允许您编写适用于所有主要浏览器的代码，并为您提供了许多额外的工具，例如从浏览器本身执行异步调用（**AJAX**的功能。我们将使用这个库来执行对 API 的调用，以生成和验证密码。您可以在[下载 https://jquery.com/](https://jquery.com/) ，并将其放入`pwdweb/records/static/records/js/`文件夹中（您可能需要修改模板中的导入）。

我为您强调了模板中唯一有趣的部分。注意，我们在最后加载 JavaScript 库。这是一种常见的做法，因为 JavaScript 用于操作页面，所以在最后加载库有助于避免出现 JavaScript 代码失败等情况，因为所需的元素尚未在页面上呈现。

### 主页和页脚模板

主模板非常简单：

`records/templates/records/home.html`

```py
{% extends "records/base.html" %}
{% block title %}Welcome to the Records website.{% endblock %}

{% block page-content %}
  <h1>Welcome {{ user.first_name }}!</h1>
  <div class="home-option">To create a record click
    <a href="{% url "records:add" %}">here.</a>
  </div>
  <div class="home-option">To see all records click
    <a href="{% url "records:list" %}">here.</a>
  </div>
{% endblock page-content %}
```

与我们在[第 10 章](09.html "Chapter 10\. Web Development Done Right")中看到的`home.html`模板相比，这里没有什么新东西，*Web 开发做得不错*。页脚模板实际上完全相同：

`records/templates/records/footer.html`

```py
<div class="footer">
  Go back <a href="{% url "home" %}">home</a>.
</div>
```

### 列出所有记录

这个列出所有记录的模板相当简单：

`records/templates/records/list.html`

```py
{% extends "records/base.html" %}
{% load record_extras %}
{% block title %}Records{% endblock title %}

{% block page-content %}
  <h1>Records</h1><span name="top"></span>
  {% include "records/messages.html" %}

  {% for record in records %}
  <div class="record {% cycle 'row-light-blue' 'row-white' %}"
       id="record-{{ record.pk }}">
    <div class="record-left">
      <div class="record-list">
        <span class="record-span">Title</span>{{ record.title }}
      </div>
      <div class="record-list">
        <span class="record-span">Username</span>
        {{ record.username }}
      </div>
      <div class="record-list">
        <span class="record-span">Email</span>{{ record.email }}
      </div>
      <div class="record-list">
        <span class="record-span">URL</span>
          <a href="{{ record.url }}" target="_blank">
            {{ record.url }}</a>
      </div>
      <div class="record-list">
        <span class="record-span">Password</span>
        {% hide_password record.plaintext %}
      </div>
    </div>
    <div class="record-right">
      <div class="record-list">
        <span class="record-span">Notes</span>
        <textarea rows="3" cols="40" class="record-notes"
                  readonly>{{ record.notes }}</textarea>
      </div>
      <div class="record-list">
        <span class="record-span">Last modified</span>
        {{ record.last_modified }}
      </div>
      <div class="record-list">
        <span class="record-span">Created</span>
        {{ record.created }}
      </div>

    </div>
    <div class="record-list-actions">
      <a href="{% url "records:edit" pk=record.pk %}">» edit</a>
      <a href="{% url "records:delete" pk=record.pk %}">» delete
      </a>
    </div>
  </div>
  {% endfor %}
{% endblock page-content %}

{% block footer %}
  <p><a href="#top">Go back to top</a></p>
  {% include "records/footer.html" %}
{% endblock footer %}
```

对于这个模板，我也强调了我希望您关注的部分。首先，我加载了一个自定义标记模块，`record_extras`，我们稍后需要它。我还在顶部添加了一个锚，这样我们就可以在页面底部添加一个指向它的链接，以避免一路向上滚动。

然后，我加入了一个模板，为我提供了显示 Django 消息的 HTML 代码。这是一个非常简单的模板，我将很快向您展示。

然后，我们定义一个`div`元素列表。每个`Record`实例都有一个容器`div`，其中还有两个主要的`div`元素：`record-left`和`record-right`。为了并列显示，我在`main.css`文件中设置了这个类：

```py
.record-left { float: left; width: 300px;}
```

最外层的`div`容器（类为`record`的容器）有一个`id`属性，我已经将其用作锚点。这允许我们点击记录删除页面上的**取消**，这样，如果我们改变主意，不想删除记录，我们可以回到列表页面，并在正确的位置。

记录的每个属性随后显示在类为`record-list`的`div`元素中。这些类中的大多数只是允许我在 HTML 元素上设置一些填充和维度。

下一个有趣的位是`hide_password`标记，它接受明文，这是未加密的密码。这个自定义标记的目的是显示一系列的`'*'`字符，与原始密码一样长，这样当你在页面上时，如果有人路过，他们就看不到你的密码。但是，将鼠标悬停在`'*'`字符序列上将在工具提示中显示原始密码。以下是`hide_password`标签的代码：

`records/templatetags/record_extras.py`

```py
from django import template
from django.utils.html import escape

register = template.Library()

@register.simple_tag
def hide_password(password):
    return '<span title="{0}">{1}</span>'.format(
        escape(password), '*' * len(password))
```

这里没有什么新奇的东西。我们只需将这个函数注册为一个简单的标记，然后就可以在任何需要的地方使用它。它取一个`password`作为一个`span`元素的`tooltip`，其主要内容是一个`'*'` 字符序列。只需注意一件事：我们需要对密码进行转义，以确保它不会破坏我们的 HTML（想想如果密码包含双引号``"``，例如，会发生什么情况）。

就`list.html`模板而言，下一个有趣的地方是我们将`readonly`属性设置为`textarea`元素，这样就不会给用户留下他们可以动态修改笔记的印象。

然后，我们为每个`Record`实例设置了几个链接，就在容器`div`的底部。一个用于编辑页面，另一个用于删除页面。请注意，我们不仅需要传递`url`标记`namespace:name`字符串，还需要传递主键信息，这是我们在`urls.py`模块中为这些视图所做的 URL 设置所要求的。

最后，我们导入页脚并将链接设置为页面顶部的锚点。

现在，正如承诺的那样，以下是消息的代码：

`records/templates/records/messages.html`

```py
{% if messages %}
  {% for message in messages %}
    <p class="{{ message.tags }}">{{ message }}</p>
  {% endfor %}
{% endif %}
```

此代码只负责在至少有一条消息要显示时显示消息。我们给出`p`标记`class`信息，以绿色显示成功消息，以红色显示错误消息。

如果您从该书的源代码中获取`main.css`文件，您现在将能够可视化列表页面（您的列表页面将为空，您仍然需要在其中插入数据），它应该如下所示：

![Listing all records](img/4715_12_01.jpg)

正如您所见，我目前在数据库中有两条记录。我将鼠标悬停在第一个密码上，这是我姐姐学校的平台帐户，密码显示在工具提示中。分为两个`div`元素*左*和*右*，有助于缩小行数，从而使整体结果更美观。重要信息在左侧，辅助信息在右侧。行颜色在非常浅的蓝色和白色之间交替。

每一行的左下角都有一个**编辑**和**删除**链接。在看到创建这两个链接的模板的代码之后，我们将立即显示这两个链接的页面。

保存此接口所有信息的 CSS 代码如下所示：

`records/static/records/css/main.css`

```py
html, body, * {
  font-family: 'Trebuchet MS', Helvetica, sans-serif; }
a { color: #333; }
.record {
  clear: both; padding: 1em; border-bottom: 1px solid #666;}
.record-left { float: left; width: 300px;}
.record-list { padding: 2px 0; }
.fieldWrapper { padding: 5px; }
.footer { margin-top: 1em; color: #333; }
.home-option { padding: .6em 0; }
.record-span { font-weight: bold; padding-right: 1em; }
.record-notes { vertical-align: top; }
.record-list-actions { padding: 4px 0; clear: both; }
.record-list-actions a { padding: 0 4px; }
#pwd-info { padding: 0 6px; font-size: 1.1em; font-weight: bold;}
#id_notes { vertical-align: top; }
/* Messages */
.success, .errorlist {font-size: 1.2em; font-weight: bold; }
.success {color: #25B725; }
.errorlist {color: #B12B2B; }
/* colors */
.row-light-blue { background-color: #E6F0FA; }
.row-white { background-color: #fff; }
.green { color: #060; }
.orange { color: #FF3300; }
.red { color: #900; }
```

请记住，我不是 CSS 大师，所以请接受这个文件，这是为我们的界面提供样式的一种相当天真的方式。

### 创建和编辑记录

现在来看有趣的部分。创建和更新记录。我们将对这两种情况使用相同的模板，因此我们希望会有一些决策逻辑来告诉我们在这两种情况下我们处于哪种情况。事实证明，代码不会太多。然而，这个模板最令人兴奋的部分是它的相关 JavaScript 文件，我们将在后面检查它。

`records/templates/records/record_add_edit.html`

```py
{% extends "records/base.html" %}
{% load static from staticfiles %}
{% block title %}
  {% if update %}Update{% else %}Create{% endif %} Record
{% endblock title %}

{% block page-content %}
  <h1>{% if update %}Update a{% else %}Create a new{% endif %}
    Record
  </h1>
  {% include "records/messages.html" %}

  <form action="." method="post">{% csrf_token %}
    {{ form.non_field_errors }}

    <div class="fieldWrapper">{{ form.title.errors }}
      {{ form.title.label_tag }} {{ form.title }}</div>

    <div class="fieldWrapper">{{ form.username.errors }}
      {{ form.username.label_tag }} {{ form.username }}</div>

    <div class="fieldWrapper">{{ form.email.errors }}
      {{ form.email.label_tag }} {{ form.email }}</div>

    <div class="fieldWrapper">{{ form.url.errors }}
      {{ form.url.label_tag }} {{ form.url }}</div>

    <div class="fieldWrapper">{{ form.password.errors }}
      {{ form.password.label_tag }} {{ form.password }}
      <span id="pwd-info"></span></div>

    <button type="button" id="validate-btn">
 Validate Password</button>
 <button type="button" id="generate-btn">
 Generate Password</button>

    <div class="fieldWrapper">{{ form.notes.errors }}
      {{ form.notes.label_tag }} {{ form.notes }}</div>

    <input type="submit"
      value="{% if update %}Update{% else %}Insert{% endif %}">
  </form>
{% endblock page-content %}

{% block footer %}
  <br>{% include "records/footer.html" %}<br>
  Go to <a href="{% url "records:list" %}">the records list</a>.
{% endblock footer %}

{% block scripts %}
  {{ block.super }}
  <script src="{% static "records/js/api.js" %}"></script>
{% endblock scripts %}
```

和一样，我已经强调了重要的部分，所以让我们一起看一下这段代码。

您可以在`title`块中看到第一位决策逻辑。类似的决策逻辑稍后也会显示在页面的标题中（HTML 标记为`h1`），以及表单末尾的`submit`按钮中。

除了这个逻辑，我想让你们关注的是形式及其内部内容。我们将 action 属性设置为一个点，这意味着*这个页面*，因此我们不需要根据哪个视图为页面提供服务来定制它。此外，我们立即处理*跨站点请求伪造*令牌，如[第 10 章](09.html "Chapter 10\. Web Development Done Right")所述，*网站开发完成*正确。

请注意，这一次，我们不能将整个表单的呈现留给 Django，因为我们想添加一些额外的东西，所以我们降低了一个粒度级别，让 Django 为我们呈现每个单独的字段，以及任何错误及其标签。这样我们仍然可以节省大量的精力，同时，我们还可以根据自己的喜好定制表单。在这种情况下，编写一个小模板来渲染字段并不少见，这样可以避免对每个字段重复这三行。不过在本例中，表单非常小，我决定避免进一步提高复杂性。

`span`元素`pwd-info`包含我们从 API 获得的密码信息。之后的两个按钮，`validate-btn`和`generate-btn`与对 API 的 AJAX 调用相连接。

在模板的末尾，在`scripts`块中，我们需要加载包含 API 代码的`api.js`JavaScript 文件。我们还需要使用`block.super`，它将加载父模板中同一块中的任何代码（例如 jQuery）。`block.super`基本上是 Python 中调用`super(ClassName, self)`的模板。在我们的库之前加载 jQuery 很重要，因为后者基于前者。

### 与 API 对话

现在让我们来看一下 JavaScript。我不指望你什么都懂。首先，这是一本 Python 书籍，其次，你应该是一个初学者（尽管现在，*忍者训练了*，所以不要害怕。然而，由于 JavaScript 现在已经成为处理 web 环境的必要工具，因此即使对于 Python 开发人员来说，掌握 JavaScript 的工作知识也是极其重要的，所以请尝试充分利用我将要向您展示的内容。我们将首先看到密码生成：

`records/static/records/js/api.js`

```py
var baseURL = 'http://127.0.0.1:5555/password';

var getRandomPassword = function() {
  var apiURL = '{url}/generate'.replace('{url}', baseURL);
  $.ajax({
    type: 'GET',
    url: apiURL,
    success: function(data, status, request) {
      $('#id_password').val(data[1]);
    },
    error: function() { alert('Unexpected error'); }
  });
}

$(function() {
  $('#generate-btn').click(getRandomPassword);
});
```

首先，我们为基础 API URL 设置了一个变量：`baseURL`。然后，我们定义了`getRandomPassword`函数，它非常简单。首先，它用替换技术定义了`apiURL`扩展`baseURL`。即使语法与 Python 不同，理解这一行也不会有任何问题。

在定义了`apiURL`之后，出现了一个有趣的位。我们调用`$.ajax`，这是执行 AJAX 调用的 jQuery 函数。`$`是 jQuery 的快捷方式。正如您在通话正文中看到的，这是对`apiURL`的`GET`请求。如果成功（`success`：…），将运行一个匿名函数，该函数将`id_password`文本字段的值设置为返回数据的第二个元素。当我们检查 API 代码时，我们将看到数据的结构，所以现在不用担心。如果发生错误，我们只需提醒用户发生了意外错误。

### 注

HTML 中密码字段的 ID 为`id_password`的原因是 Django 呈现表单的方式。例如，可以使用自定义前缀自定义此行为。在这种情况下，我对 Django 的默认值很满意。

在函数定义之后，我们运行几行代码将`generate-btn`按钮上的`click`事件绑定到`getRandomPassword`函数。这意味着，在浏览器引擎运行此代码后，每次单击`generate-btn`按钮时，都会调用`getRandomPassword`函数。

那没那么可怕吧？让我们看看验证部分需要什么。

现在在**密码**字段中有一个值，我们要验证它。我们需要调用 API 并检查其响应。由于密码可能有奇怪的字符，我不想在 URL 上传递它们，因此我将使用一个`POST`请求，它允许我将密码放入它的主体中。为此，我需要以下代码：

```py
var validatePassword = function() {
  var apiURL = '{url}/validate'.replace('{url}', baseURL);
  $.ajax({
    type: 'POST',
    url: apiURL,
    data: JSON.stringify({'password': $('#id_password').val()}),
    contentType: "text/plain",  // Avoid CORS preflight
    success: function(data, status, request) {
      var valid = data['valid'], infoClass, grade;
      var msg = (valid?'Valid':'Invalid') + ' password.';
      if (valid) {
        var score = data['score']['total'];
        grade = (score<10?'Poor':(score<18?'Medium':'Strong'));
        infoClass = (score<10?'red':(score<18?'orange':'green'));
        msg += ' (Score: {score}, {grade})'
          .replace('{score}', score).replace('{grade}', grade);
      }
      $('#pwd-info').html(msg);
      $('#pwd-info').removeClass().addClass(infoClass);
    },
    error: function(data) { alert('Unexpected error'); }
  });
}

$(function() {
  $('#validate-btn').click(validatePassword);
});
```

的概念与之前相同，只是这次是针对`validate-btn`按钮。AJAX 调用的主体与此类似。我们使用`POST`而不是`GET`请求，并将数据定义为 JSON 对象，这相当于在 Python 中使用`json.dumps({'password': 'some_pwd'})`。

`contentType`行是一个快速的破解，以避免浏览器的 CORS 飞行前行为出现问题。**跨源资源共享**（**CORS**是一种允许从发起请求的域之外的另一域请求网页上受限资源的机制。简言之，由于 API 位于`127.0.0.1:5555`且接口运行在`127.0.0.1:8000`处，如果没有此黑客攻击，浏览器将不允许我们执行调用。在生产环境中，您可能需要检查 JSONP 的文档，这是一个更好（尽管更复杂）的解决方案。

调用成功时运行的匿名函数体显然有点复杂。我们需要做的就是了解密码是否有效（从`data['valid']`开始），并根据其分数为其分配等级和 CSS 类。有效性和分数信息来自 API 响应。

这段代码中唯一棘手的一点是 JavaScript 三元运算符，因此让我们看一个比较示例：

```py
# Python
error = 'critical' if error_level > 50 else 'medium'
// JavaScript equivalent
error = (error_level > 50 ? 'critical' : 'medium');
```

在这个示例中，读取函数中的其余逻辑应该不会有任何问题。我知道，我本可以使用一个普通的`if (...)`，但是 JavaScript 程序员一直使用三元运算符，所以你应该习惯它。为了理解代码，更努力地搔搔头是一种很好的训练。

最后，我想让你看看这个函数的结尾。我们将`pwd-info`span 元素的`html`设置为我们组装的消息（`msg`，然后对其进行样式化。在一行中，我们从该元素中删除了所有 CSS 类（`removeClass()`不带参数），并将`infoClass`添加到该元素中。`infoClass`为`'red'`、`'orange'`或`'green'`。如果你回到`main.css`文件，你会在底部看到它们。

现在我们已经看到了进行调用的模板代码和 JavaScript，让我们看一下页面的屏幕截图。我们要编辑第一张唱片，是关于我姐姐学校的。

![Talking to the API](img/4715_12_02.jpg)

在图中，您可以看到我通过点击**生成****密码**按钮更新了密码。然后，我保存了记录（这样你可以在顶部看到漂亮的消息），最后，我点击了**验证****密码**按钮。

结果是**密码**字段右侧的显示为绿色。它很强（23 实际上是我们能得到的最高分数），所以信息显示在一个漂亮的绿色阴影中。

### 删除记录

要删除记录，请转到列表并单击**删除**链接。您将被重定向到要求您确认的页面；然后，您可以选择继续并删除不良记录，或者取消请求并返回列表页面。模板代码如下所示：

`records/templates/records/record_confirm_delete.html`

```py
{% extends "records/base.html" %}
{% block title %}Delete record{% endblock title %}

{% block page-content %}
  <h1>Confirm Record Deletion</h1>
  <form action="." method="post">{% csrf_token %}
    <p>Are you sure you want to delete "{{ object }}"?</p>
    <input type="submit" value="Confirm" />&nbsp;
    <a href="{% url "records:list" %}#record-{{ object.pk }}">
       » cancel</a>
  </form>
{% endblock page-content %}
```

因为这是标准 Django 视图的模板，所以我们需要使用 Django 采用的命名约定。因此，该记录在模板中称为**对象**。`{{ object }}`标记显示对象的字符串表示形式，目前并不十分漂亮，因为整行将显示：**您确定要删除“记录对象”吗？**。

这是因为我们还没有在`Model`类中添加`__str__`方法，这意味着 Python 不知道在我们请求实例的字符串表示时要向我们显示什么。让我们通过完成我们的模型来改变这一点，在类主体的底部添加`__str__`方法：

`records/models.py`

```py
class Record(models.Model):
    ...

    def __str__(self):
 return '{}'.format(self.title)

```

重新启动服务器，现在页面将显示：**您确定要删除“某银行”吗？**其中*某银行*是我点击**删除**链接的记录的`title`。

我们本可以使用`{{ object.title }}`，但我更愿意解决问题的根源，而不仅仅是效果。添加`__str__`方法实际上是所有模型都应该做的事情。

最后一个模板中有趣的部分实际上是用于取消操作的链接。我们使用`url`标记返回列表视图（`records:list`，但我们向其添加锚信息，以便它最终会读取类似的内容（这是针对`pk=2`）：

`http://127.0.0.1:8000/records/#record-2`

这将返回列表页面并向下滚动到 ID 记录为 2 的容器`div`，这很好。

界面到此结束。尽管本节内容与我们在[第 10 章](09.html "Chapter 10\. Web Development Done Right")中看到的内容相似，*Web 开发做得很好*，但我们能够更多地关注本章中的代码。我们已经看到了基于 Django 类的视图是多么有用，我们甚至还提到了一些很酷的 JavaScript。运行`$ python manage.py runserver`时，您的界面应在`http://127.0.0.1:8000`处启动并运行。

### 注

如果您想知道，`127.0.0.1`表示`localhost`-您的计算机，`8000`是服务器绑定到的端口，用于侦听传入的请求。

现在是时候让这个项目的第二部分变得更加有趣了。

# 实现 Falcon API

我们将要编写的 Falcon 项目的结构远没有接口结构那么扩展。我们将总共编写五个文件。在您的`ch12`文件夹中，创建一个名为`pwdapi`的新文件夹。这是它的最终结构：

```py
$ tree -A pwdapi/
pwdapi/
├── core
│   ├── handlers.py
│   └── passwords.py
├── main.py
└── tests
 └── test_core
 ├── test_handlers.py
 └── test_passwords.py

```

API 都是使用 TDD 编码的，所以我们还将探讨测试。然而，我认为如果您首先看到代码，您将更容易理解测试，因此我们将从这个开始。

## 主要应用

这是 Falcon 应用程序的代码：

`main.py`

```py
import falcon
from core.handlers import (
    PasswordValidatorHandler,
    PasswordGeneratorHandler,
)

validation_handler = PasswordValidatorHandler()
generator_handler = PasswordGeneratorHandler()

app = falcon.API()
app.add_route('/password/validate/', validation_handler)
app.add_route('/password/generate/', generator_handler)
```

如[第 10 章](09.html "Chapter 10\. Web Development Done Right")中的例子*Web Development Done Right*，我们首先为每个需要的处理程序创建一个实例，然后创建一个`falcon.API`对象，并通过调用其`add_route`方法，设置到 API URL 的路由。稍后我们将讨论处理程序的定义。首先，我们需要几个帮手。

## 给帮手写信

在部分中，我们将看一看将在处理程序中使用的几个类。按照**单一责任原则**找出一些逻辑总是好的。

### 注

在OOP 中，**单一责任原则**（**SRP**）规定，每个类都应该对软件提供的功能的单个部分负责，并且该责任应该完全由类封装。它的所有服务都应该与这一责任紧密结合。

单一责任原则是**S.O.L.I.D 中的*S*。**，是 Robert Martin 介绍的前五个 OOP 和软件设计原则的首字母缩写。

我衷心建议你打开一个浏览器，仔细阅读这个主题，这是非常重要的。

helpers 部分的所有代码都属于`core/passwords.py`模块。以下是它的开始：

```py
from math import ceil
from random import sample
from string import ascii_lowercase, ascii_uppercase, digits

punctuation = '!#$%&()*+-?@_|'
allchars = ''.join(
    (ascii_lowercase, ascii_uppercase, digits, punctuation))
```

我们需要处理一些随机计算，但这里最重要的部分是允许的字符。我们将允许字母、数字和一组标点符号。为了便于编写代码，我们将这些部分合并到`allchars`字符串中。

### 对密码验证器进行编码

`PasswordValidator`类是整个 API 中我最喜欢的逻辑部分。它公开了一个`is_valid`和一个`score`方法。后者运行所有定义的验证器（“同一类中的私有”方法），并将分数收集到一个 dict 中，该 dict 作为结果返回。我将逐个方法编写这个类方法，这样它就不会变得太复杂：

```py
class PasswordValidator:
    def __init__(self, password):
        self.password = password.strip()
```

它首先将`password`（不带前导空格或尾随空格）设置为实例属性。这样我们就不必在方法之间传递它了。接下来的所有方法都属于此类。

```py
    def is_valid(self):
        return (len(self.password) > 0 and
                all(char in allchars for char in self.password))
```

当密码长度大于 0 且所有字符都属于`allchars`字符串时，密码才有效。当你阅读`is_valid`方法时，它实际上是英语（这就是 Python 的神奇之处）。`all`是一个内置函数，它告诉您输入的 iterable 的所有元素是否都是`True`。

```py
    def score(self):
        result = {
            'length': self._score_length(),
            'case': self._score_case(),
            'numbers': self._score_numbers(),
            'special': self._score_special(),
            'ratio': self._score_ratio(),
        }
        result['total'] = sum(result.values())
        return result
```

这是另一种主要的方法。这很简单，它只是准备了一个包含验证器所有结果的 dict。唯一独立的逻辑位发生在最后，当我们将来自每个验证器的等级相加并将其分配给 dict 中的`'total'`键时，只是为了方便。

正如您所看到的，我们根据长度、字母大小写、数字和特殊字符的存在，以及字母和数字之间的比率为密码打分。字母允许一个字符在*26*2=52*不同的可能选项之间，而数字只允许 10。因此，字母数字比更高的密码更难破解。

让我们看看长度验证器：

```py
    def _score_length(self):
        scores_list = ([0]*4) + ([1]*4) + ([3]*4) + ([5]*4)
        scores = dict(enumerate(scores_list))
        return scores.get(len(self.password), 7)
```

我们为长度小于四个字符的密码分配 0 分，长度小于 8 的密码分配 1 分，长度小于 12 的密码分配 3 分，长度小于 16 的密码分配 5 分，长度大于等于 16 的密码分配 7 分。

为了避免出现大量的`if`/`elif`子句，我在这里采用了功能性风格。我准备了一个`score_list,`，基本上是`[0, 0, 0, 0, 1, 1, 1, 1, 3, ...]`。然后，通过列举，我得到了一对长度小于 16 的（*长度，分数*）对。我把这些对放进一个 dict，这给了我 dict 形式的等价物，所以它应该是这样的：`{0:0, 1:0, 2:0, 3:0, 4:1, 5:1, ...}`。然后，我用密码的长度在这个 dict 上执行一个`get`，将值 7 设置为默认值（如果长度为 16 或更多，则返回该值，而该长度不在 dict 中）。

当然，我并不反对`if`/`elif`子句，但我想借此机会在最后一章中向您展示不同的编码风格，以帮助您习惯于阅读与您通常预期不同的代码。这只是有益的。

```py
    def _score_case(self):
        lower = bool(set(ascii_lowercase) & set(self.password))
        upper = bool(set(ascii_uppercase) & set(self.password))
        return int(lower or upper) + 2 * (lower and upper)
```

我们验证这个案例的方法是用一个很好的技巧。当密码与所有小写字符的交集为非空时，`lower`为`True`，否则为`False`。`upper`的行为方式相同，仅使用大写字符。

为了理解最后一行发生的评估，让我们再次使用由内而外的方法：`lower or upper`是`True`，而两行中至少有一行是`True`。当它是`True`时，会被`int`类转换成`1`。这相当于说，如果至少有一个字符，不管大小写，分数都会得到 1 分，否则将保持为 0。

现在来看第二部分：`lower and upper`是`True`，当它们都是`True`时，这意味着我们至少有一个小写和一个大写字符。这意味着，要破解密码，暴力算法必须循环 52 个字母，而不是 26 个。因此，当这是`True`时，我们会得到额外的两分。

因此，此验证器根据密码的不同，生成范围（0、1、3）内的结果。

```py
    def _score_numbers(self):
        return 2 if (set(self.password) & set(digits)) else 0
```

在数字上打分更简单。如果我们至少有一个数字，我们得到两分，否则我们得到 0。在本例中，我使用三元运算符返回结果。

```py
    def _score_special(self):
        return 4 if (
            set(self.password) & set(punctuation)) else 0
```

特殊字符验证器与前一个验证器具有相同的逻辑，但是，由于特殊字符在破解密码时增加了相当多的复杂性，因此我们得到了四分，而不是两分。

最后一个验证字母和数字之间的比率。

```py
    def _score_ratio(self):
        alpha_count = sum(
            1 if c.lower() in ascii_lowercase else 0
            for c in self.password)
        digits_count = sum(
            1 if c in digits else 0 for c in self.password)
        if digits_count == 0:
            return 0
        return min(ceil(alpha_count / digits_count), 7)
```

我强调了`sum`调用中表达式中的条件逻辑。在第一种情况下，对于小写版本在`ascii_lowercase`中的每个字符，我们得到 1。这意味着把所有的 1 加起来，我们就可以精确地计算出所有字母的数量。然后，我们对数字做同样的处理，只是我们使用数字字符串作为参考，并且不需要将字符小写。当`digits_count`为 0 时，`alpha_count / digits_count`将导致`ZeroDivisionError`，因此我们检查`digits_count`，当为 0 时返回 0。如果我们有数字，我们计算*字母的上限：数字*比率，并返回它，上限为 7。

当然，有许多不同的方法来计算密码的分数。我的目标不是给你最好的算法，而是告诉你如何去实现它。

### 对密码生成器进行编码

密码生成器是一个比验证器简单得多的类。然而，我对它进行了编码，这样我们就不需要创建一个实例来使用它，只是为了再次向您展示一种不同的编码风格。

```py
class PasswordGenerator:

    @classmethod
    def generate(cls, length, bestof=10):
        candidates = sorted([
            cls._generate_candidate(length)
            for k in range(max(1, bestof))
        ])
        return candidates[-1]

    @classmethod
    def _generate_candidate(cls, length):
        password = cls._generate_password(length)
        score = PasswordValidator(password).score()
        return (score['total'], password)

    @classmethod
    def _generate_password(cls, length):
        chars = allchars * (ceil(length / len(allchars)))
        return ''.join(sample(chars, length))
```

在这三种方法中，只有第一种是要使用的。让我们从最后一个开始分析：`_generate_password`。

这个方法只需要获取一个长度，这是我们想要的密码所需的长度，并调用 sample 函数从`chars`字符串中获取一组长度元素。示例函数的返回值是一个长度元素列表，我们需要使用`join`将其设置为字符串。

在我们调用`sample`之前，请考虑一下，如果所需的长度超过`allchars`的长度，该怎么办？该调用将导致`ValueError: Sample larger than the population`。

由于的原因，我们创建`chars`字符串的方式是将`allchars`字符串连接到自身，刚好足够覆盖所需长度。举个例子，假设我们需要一个 27 个字符的密码，让我们假设`allchars`有 10 个字符长。`length / len(allchars)`给出 2.7，当传递给`ceil`函数时，变为 3。这意味着我们将把`chars`分配给`allchars`字符串的三重串联，因此`chars`将是*10*3=30*个字符长，这足以满足我们的要求。

注意，为了在不创建此类实例的情况下调用这些方法，我们需要使用`classmethod`装饰器来装饰它们。约定是调用第一个参数`cls`，而不是`self`，因为 Python 在幕后会将类对象传递给调用。

`_generate_candidate`的代码也很简单。我们只需生成一个密码，并根据长度计算其分数，然后返回一个元组（*分数，密码*。

我们这样做是为了在`generate`方法中，我们可以在每次调用该方法时生成 10 个（默认）密码，并返回得分最高的密码。因为我们的生成逻辑是基于随机函数的，所以使用这样的技术来避免最坏的情况总是一个好方法。

助手的代码到此结束。

## 编写处理程序

正如您可能已经注意到的，助手的代码与与 Falcon 完全无关。它只是纯 Python，我们可以在需要时重用它。另一方面，处理程序的代码当然基于 Falcon。下面的代码属于`core/handlers.py`模块，因此，正如我们之前所做的那样，让我们从前几行开始：

```py
import json
import falcon
from .passwords import PasswordValidator, PasswordGenerator

class HeaderMixin:
    def set_access_control_allow_origin(self, resp):
        resp.set_header('Access-Control-Allow-Origin', '*')
```

这很简单。我们导入`json`、`falcon`和我们的助手，然后设置一个 mixin，这两个处理程序都需要它。这种混合的需要是允许 API 为来自其他地方的请求提供服务。这是 CORS 硬币的另一面，与我们在界面的 JavaScript 代码中看到的不同。在这种情况下，我们大胆地去任何安全专家都不敢去的地方，允许来自任何域的请求（`'*'`。我们这样做是因为这是一个练习，在这种情况下，这很好，但不要在生产中这样做，好吗？

### 对密码验证处理器进行编码

这个处理程序必须响应`POST`请求，因此我编写了一个`on_post`方法，这是您在 Falcon 中响应`POST`请求的方式。

```py
class PasswordValidatorHandler(HeaderMixin):

    def on_post(self, req, resp):
        self.process_request(req, resp)
        password = req.context.get('_body', {}).get('password')
        if password is None:
            resp.status = falcon.HTTP_BAD_REQUEST
            return None

        result = self.parse_password(password)
        resp.body = json.dumps(result)

    def parse_password(self, password):
        validator = PasswordValidator(password)
        return {
            'password': password,
            'valid': validator.is_valid(),
            'score': validator.score(),
        }

    def process_request(self, req, resp):
        self.set_access_control_allow_origin(resp)

        body = req.stream.read()
        if not body:
            raise falcon.HTTPBadRequest('Empty request body',
                'A valid JSON document is required.')
        try:
            req.context['_body'] = json.loads(
 body.decode('utf-8'))
        except (ValueError, UnicodeDecodeError):
            raise falcon.HTTPError(
                falcon.HTTP_753, 'Malformed JSON',
                'JSON incorrect or not utf-8 encoded.')
```

让我们从`on_post`方法开始。首先，我们调用`process_request`方法，它对请求主体进行健全性检查。我不会详细介绍，因为它是从 Falcon 文档中提取的，并且是处理请求的标准方式。让我们说，如果一切顺利（突出显示的部分），我们将在`req.context['_body']`中获得请求主体（已从 JSON 解码）。如果由于任何原因情况不好，我们将返回适当的错误响应。

让我们回到`on_post`。我们从请求上下文获取密码。此时，`process_request`已经成功，但我们仍然不知道尸体的格式是否正确。我们期待类似于：`{'password': 'my_password'}`的东西。

因此，我们谨慎行事。我们得到`'_body'`键的值，如果不存在，我们返回一个空 dict。我们从中得到`'password'`的值。我们使用`get`而不是直接访问来避免`KeyError`问题。

如果密码为`None,`，我们只需返回 400 错误（错误请求）。否则，我们验证它并计算它的分数，然后将结果设置为我们的响应主体。

通过使用我们的助手，您可以看到在`parse_password`方法中验证和计算密码分数是多么容易。

我们返回一个包含三条信息的 dict：`password`、`valid`和`score`。密码信息在技术上是多余的，因为提出请求的人都知道密码，但在本例中，我认为这是一种为日志等提供足够信息的好方法，所以我添加了它。

如果 JSON 解码的主体不是 dict，会发生什么？我将留给您来修复代码，添加一些逻辑以满足边缘情况。

### 对密码生成器处理程序进行编码

生成器处理程序必须使用一个查询参数处理`GET`请求：所需的密码长度。

```py
class PasswordGeneratorHandler(HeaderMixin):

    def on_get(self, req, resp):
        self.process_request(req, resp)
        length = req.context.get('_length', 16)
        resp.body = json.dumps(
            PasswordGenerator.generate(length))

    def process_request(self, req, resp):
        self.set_access_control_allow_origin(resp)
        length = req.get_param('length')
        if length is None:
            return
        try:
            length = int(length)
            assert length > 0
            req.context['_length'] = length
        except (ValueError, TypeError, AssertionError):
            raise falcon.HTTPBadRequest('Wrong query parameter',
                '`length` must be a positive integer.')
```

我们有一个类似的`process_request`方法。它对请求进行健全性检查，尽管与前面的处理程序有点不同。这一次，我们需要确保如果查询字符串上提供了长度（例如，`http://our-api-url/?length=23`），那么它的格式是正确的。这意味着`length`必须是一个正整数。

因此，为了验证这一点，我们做了一个`int`转换（`req.get_param('length')`返回一个字符串），然后我们断言`length`大于零，最后，我们把它放在`context`中的`'_length'`键下。

对不适合整数表示的字符串进行`int`转换将引发`ValueError`，而对非字符串类型的转换将引发`TypeError`，因此我们在`except`子句中捕捉到这两种情况。

我们还捕获了`AssertionError`，当`length`不是正整数时，它由`assert length > 0`行提升。我们可以通过一个`try`/`except`块安全地保证长度符合要求。

### 提示

请注意，当编码一个`try`/`except`块时，您通常应该尽量具体，将出现问题时会引发不同异常的指令分开。这将允许您对问题进行更多的控制，并简化调试。但在本例中，由于这是一个简单的 API，因此可以使用只对`length`格式不正确的请求作出反应的代码。

`on_get`方法的代码非常简单。它首先处理请求，然后提取长度，在未传递时返回到 16（默认值），然后生成密码并转储到 JSON，然后设置为响应的主体。

## 运行 API

为了运行此应用程序，您需要记住，我们将接口中的基本 URL 设置为`http://127.0.0.1:5555`。因此，我们需要以下命令来启动 API：

```py
$ gunicorn -b 127.0.0.1:5555 main:app

```

运行将启动主模块中定义的应用程序，将服务器实例绑定到`localhost`上的端口`5555`。有关 Gunicorn 的更多信息，请参考[第 10 章](09.html "Chapter 10\. Web Development Done Right")、*网站开发正确*或直接访问项目主页（[http://gunicorn.org/](http://gunicorn.org/) 。

API 的代码现在已经完成，因此如果您同时运行了接口和 API，您可以一起尝试。看看是否一切正常。

## 测试 API

在这个 Ty2T2 节中，让我们看一下我为帮助者 To3 T3 和为处理程序编写的测试。助手的测试主要基于`nose_parameterized`库，因为我最喜欢的测试风格是接口测试，尽可能少的修补。使用`nose_parameterized`可以让我编写更容易阅读的测试，因为测试用例非常直观。

另一方面，处理程序的测试必须遵循 Falcon 库的测试约定，因此它们会有所不同。当然，这是非常理想的，因为它允许我向您展示更多。

由于剩下的页面数量有限，我将只向您展示部分测试，因此请确保在源代码中完整地检查它们。

### 测试帮手

让我们看看对`PasswordGenerator`类的测试：

`tests/test_core/test_passwords.py`

```py
class PasswordGeneratorTestCase(TestCase):

    def test__generate_password_length(self):
        for length in range(300):
            assert_equal(
                length,
                len(PasswordGenerator._generate_password(length))
            )

    def test__generate_password_validity(self):
        for length in range(1, 300):
            password = PasswordGenerator._generate_password(
                length)
            assert_true(PasswordValidator(password).is_valid())

    def test__generate_candidate(self):
        score, password = (
            PasswordGenerator._generate_candidate(42))
        expected_score = PasswordValidator(password).score()
        assert_equal(expected_score['total'], score)

    @patch.object(PasswordGenerator, '_generate_candidate')
    def test__generate(self, _generate_candidate_mock):
        # checks `generate` returns the highest score candidate
        _generate_candidate_mock.side_effect = [
            (16, '&a69Ly+0H4jZ'),
            (17, 'UXaF4stRfdlh'),
            (21, 'aB4Ge_KdTgwR'),  # the winner
            (12, 'IRLT*XEfcglm'),
            (16, '$P92-WZ5+DnG'),
            (18, 'Xi#36jcKA_qQ'),
            (19, '?p9avQzRMIK0'),
            (17, '4@sY&bQ9*H!+'),
            (12, 'Cx-QAYXG_Ejq'),
            (18, 'C)RAV(HP7j9n'),
        ]
        assert_equal(
            (21, 'aB4Ge_KdTgwR'), PasswordGenerator.generate(12))
```

在`test__generate_password_length`内，我们确保`_generate_password`方法正确处理长度参数。我们为[0，300]范围内的每个长度生成一个密码，并验证其长度是否正确。

在`test__generate_password_validity`测试中，我们做了类似的事情，但这次，我们确保无论我们要求的长度是多少，生成的密码都是有效的。我们使用`PasswordValidator`类来检查有效性。

最后，我们需要测试`generate`方法。密码生成是随机的，因此为了测试此函数，我们需要模拟`_generate_candidate`，从而控制其输出。我们将模拟中的`side_effect`参数设置为 10 个候选项的列表，我们期望`generate`方法从中选择得分最高的一个。将模拟上的`side_effect`设置为列表会导致该模拟每次调用时返回该列表的元素，一次返回一个。为了避免模棱两可，最高分是 21 分，而且只有一名候选人的分数达到了这么高。我们调用该方法并确保该方法是返回的候选者。

### 注

如果您想知道为什么我在测试名称中使用这些双下划线，那么很简单：第一个是分隔符，第二个是作为测试方法名称一部分的前导下划线。

测试`PasswordValidator`类需要更多的代码行，因此我只展示这些测试的部分：

`pwdapi/tests/test_core/test_passwords.py`

```py
from unittest import TestCase
from unittest.mock import patch
from nose_parameterized import parameterized, param
from nose.tools import (
    assert_equal, assert_dict_equal, assert_true)
from core.passwords import PasswordValidator, PasswordGenerator

class PasswordValidatorTestCase(TestCase):

    @parameterized.expand([
        (False, ''),
        (False, '  '),
        (True, 'abcdefghijklmnopqrstuvwxyz'),
        (True, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'),
        (True, '0123456789'),
        (True, '!#$%&()*+-?@_|'),
    ])
    def test_is_valid(self, valid, password):
        validator = PasswordValidator(password)
        assert_equal(valid, validator.is_valid())
```

我们首先测试`is_valid`方法。我们测试当它输入一个空字符串以及一个仅由空格组成的字符串时，它是否返回`False`，这确保我们在测试分配密码时是否调用`.strip()`。

然后，我们使用我们希望被接受的所有字符来确保函数接受它们。

我理解`parameterize.expand`装饰符背后的语法一开始可能很有挑战性，但实际上，每个元组都由一个独立的测试用例组成，这反过来意味着`test_is_valid`测试针对每个元组单独运行，两个元组元素作为参数传递给方法：`valid`和`password` .

然后我们测试无效字符。我们预计它们都会失败，所以我们使用`param.explicit`，它会对奇怪字符串中的每个字符运行测试。

```py
    @parameterized.expand(
        param.explicit(char) for char in '>]{<`\\;,[^/"\'~:}=.'
    )
    def test_is_valid_invalid_chars(self, password):
        validator = PasswordValidator(password)
        assert_equal(False, validator.is_valid())
```

他们都评估为`False`，所以我们很好。

```py
    @parameterized.expand([
        (0, ''),  # 0-3: score 0
        (0, 'a'),  # 0-3: score 0
        (0, 'aa'),  # 0-3: score 0
        (0, 'aaa'),  # 0-3: score 0
        (1, 'aaab'),  # 4-7: score 1
        ...
        (5, 'aaabbbbccccddd'),  # 12-15: score 5
        (5, 'aaabbbbccccdddd'),  # 12-15: score 5
    ])
    def test__score_length(self, score, password):
        validator = PasswordValidator(password)
        assert_equal(score, validator._score_length())
```

为了测试`_score_length`方法，我创建了 16 个长度为 0 到 15 的测试用例。测试的主体只是确保分数分配适当。

```py
    def test__score_length_sixteen_plus(self):
        # all password whose length is 16+ score 7 points
        password = 'x' * 255
        for length in range(16, len(password)):
            validator = PasswordValidator(password[:length])
            assert_equal(7, validator._score_length())
```

上述测试适用于 16 至 254 的长度。我们只需要确保 15 后的任何长度都得到 7 作为分数。

我将跳过其他内部方法的测试，直接跳到评分方法的测试。为了测试它，我想精确地控制每个`_score_*`方法返回的内容，所以我模拟了它们，在测试中，我为每个方法设置了一个返回值。注意，为了模拟类的方法，我们使用了一个变体`patch`：`patch.object`。当您在 mock 上设置返回值时，重复是不好的，因为您可能不确定哪个方法返回了什么，并且在交换的情况下测试不会失败。因此，始终返回不同的值。在我的例子中，我使用前几个素数来确保没有混淆的可能性。

```py
    @patch.object(PasswordValidator, '_score_length')
    @patch.object(PasswordValidator, '_score_case')
    @patch.object(PasswordValidator, '_score_numbers')
    @patch.object(PasswordValidator, '_score_special')
    @patch.object(PasswordValidator, '_score_ratio')
    def test_score(
            self,
            _score_ratio_mock,
            _score_special_mock,
            _score_numbers_mock,
            _score_case_mock,
            _score_length_mock):

        _score_ratio_mock.return_value = 2
        _score_special_mock.return_value = 3
        _score_numbers_mock.return_value = 5
        _score_case_mock.return_value = 7
        _score_length_mock.return_value = 11

        expected_result = {
            'length': 11,
            'case': 7,
            'numbers': 5,
            'special': 3,
            'ratio': 2,
            'total': 28,
        }

        validator = PasswordValidator('')
        assert_dict_equal(expected_result, validator.score())
```

我想明确指出`_score_*`方法是模拟的，所以我通过向类构造函数传递一个空字符串来设置`validator`实例。这使读者更清楚地看到，类的内部已经被模拟出来了。然后，我只是检查结果是否与我预期的相同。

最后一个测试是这个类中唯一一个我使用 mock 的测试。`_score_*`方法的所有其他测试都采用接口风格，这样读起来更好，通常产生更好的结果。

### 测试处理器

让我们简要地看一个处理程序测试的示例：

`pwdapi/tests/test_core/test_handlers.py`

```py
import json
from unittest.mock import patch
from nose.tools import assert_dict_equal, assert_equal
import falcon
import falcon.testing as testing
from core.handlers import (
    PasswordValidatorHandler, PasswordGeneratorHandler)

class PGHTest(PasswordGeneratorHandler):
    def process_request(self, req, resp):
        self.req, self.resp = req, resp
        return super(PGHTest, self).process_request(req, resp)

class PVHTest(PasswordValidatorHandler):
    def process_request(self, req, resp):
        self.req, self.resp = req, resp
        return super(PVHTest, self).process_request(req, resp)
```

因为 Falcon 提供的测试处理程序的工具中有，所以我为我想要测试的每个类都创建了一个子类。我改变的唯一一件事（通过重写一个方法）是在两个类都调用的`process_request`方法中，在处理请求之前，我确保在实例上设置了`req`和`resp`参数。因此，`process_request`方法的正常行为不会以任何其他方式改变。通过这样做，无论在测试过程中发生什么，我都能够对照这些对象进行检查。

测试时使用这样的技巧是很常见的。我们从不更改代码以适应测试，这将是一种糟糕的做法。我们找到一种方法来调整我们的测试以满足我们的需求。

```py
class TestPasswordValidatorHandler(testing.TestBase):

    def before(self):
        self.resource = PVHTest()
        self.api.add_route('/password/validate/', self.resource)
```

Falcon`TestBase`逻辑调用`before`方法，它允许我们设置要测试的资源（处理程序）及其路由（不一定与生产中使用的相同）。

```py
    def test_post(self):
        self.simulate_request(
            '/password/validate/',
            body=json.dumps({'password': 'abcABC0123#&'}),
            method='POST')
        resp = self.resource.resp

        assert_equal('200 OK', resp.status)
        assert_dict_equal(
            {'password': 'abcABC0123#&',
             'score': {'case': 3, 'length': 5, 'numbers': 2,
                'special': 4, 'ratio': 2, 'total': 16},
             'valid': True},
             json.loads(resp.body))
```

这是对幸福道路的考验。它所做的只是用 JSON 负载作为主体来模拟一个`POST`请求。然后，我们检查响应对象。特别是，我们检查了它的状态和身体。我们确保处理程序已正确调用验证程序并返回其结果。

我们还测试生成器处理程序：

```py
class TestPasswordGeneratorHandler(testing.TestBase):

    def before(self):
        self.resource = PGHTest()
        self.api.add_route('/password/generate/', self.resource)

    @patch('core.handlers.PasswordGenerator')
    def test_get(self, PasswordGenerator):
        PasswordGenerator.generate.return_value = (7, 'abc123')
        self.simulate_request(
            '/password/generate/',
            query_string='length=7',
            method='GET')
        resp = self.resource.resp

        assert_equal('200 OK', resp.status)
        assert_equal([7, 'abc123'], json.loads(resp.body))
```

对于这一条，我将只向您展示快乐之路的测试。我们模拟了`PasswordGenerator`类，因为我们需要控制它将生成哪个密码，除非我们模拟，否则我们将无法执行，因为这是一个随机过程。

一旦我们正确设置了它的返回值，我们就可以再次模拟请求。在本例中，它是一个`GET`请求，所需的长度为 7。我们使用一种类似于我们用于另一个处理程序的技术，并检查响应状态和主体。

这些不是您可以针对 API 编写的唯一测试，样式也可能有所不同。有些人经常嘲笑我，我倾向于只有在我真的不得不嘲笑的时候才去嘲笑。试着看看你能不能从中理解一些道理。我知道这并不容易，但对你来说是很好的训练。测试是非常重要的，所以尽你最大的努力。

# 你将从这里走向何方？

如果您喜欢这个项目，并想扩大它，以下是一些建议：

*   在自定义 Django 字段的机制中实现加密。
*   修改记录列表的模板，以便可以搜索特定记录。
*   修改 JavaScript 以使用 JSONP 和回调来克服 CORS 问题。
*   修改 JavaScript 以在密码字段更改时触发验证调用。
*   编写一个 Django 命令，允许您加密和解密数据库文件。当您从命令行执行此操作时，请将该行为合并到网站中，可能在主页上，这样您就无法访问记录，除非您经过身份验证。这无疑是一个艰巨的挑战，因为它需要另一个数据库，该数据库使用单向散列正确存储身份验证密码，或者对用于保存记录模型数据的数据结构进行一些严重的修改。即使你现在没有办法去做，试着想想你将如何解决这个问题。
*   在您的计算机上设置 PostgreSQL 并切换到使用它，而不是使用默认的 SQLite 文件。
*   添加将文件附加到记录的功能。
*   使用该应用程序，尝试找出要添加或更改的功能，然后执行。

# 总结

在本章中，我们完成了一个涉及接口和 API 的最终项目。我们使用了两种不同的框架来实现我们的目标：Django 和 Falcon。它们是非常不同的，允许我们探索不同的概念和技术来制作我们的软件，并使这个有趣的应用程序变得生动。

我们已经看到了一个对称加密的示例，并探索了以更实用的风格编写的代码，而不是以更经典的面向控制流的方法编写的代码。我们重用并扩展了基于 Django 类的视图，将必须编写的代码量减少到了最低限度。

在编写 API 时，我们将处理请求与密码管理分离。这样就更容易看出代码的哪一部分依赖于 Falcon 框架，哪一部分独立于 Falcon 框架。

最后，我们看到了一些针对 API 的帮助程序和处理程序的测试。我们简要地介绍了一种技术，我使用它来扩展测试中的类，以便能够针对代码中通常不可用的部分进行测试。

本章中我的目的是为您提供一个有趣的示例，可以通过不同的方式进行扩展和改进。我还想给大家举几个不同的编码风格和技术的例子，这就是为什么我选择分散使用不同的框架。