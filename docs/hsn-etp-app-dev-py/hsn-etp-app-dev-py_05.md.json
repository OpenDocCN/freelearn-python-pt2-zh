["```py\ngit clone https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python\n```", "```py\n# simple_socket_thread.py\n#!/usr/bin/python3\nimport socket\nimport threading\n\n# Let's first create a TCP type Server for handling clients\nclass Server(object):\n    \"\"\"A simple TCP Server.\"\"\"\n\n    def __init__(self, hostname, port):\n        \"\"\"Server initializer\n\n        Keyword arguments:\n        hostname -- The hostname to use for the server\n        port -- The port on which the server should bind\n        \"\"\"\n\n        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.hostname = hostname\n        self.port = port\n        self.bind_connection()\n        self.listen()\n\n    def bind_connection(self):\n        \"\"\"Bind the server to the host.\"\"\"\n\n        self.server.bind((self.hostname, self.port))\n\n    def listen(self):\n        \"\"\"Start listening for the incoming connections.\"\"\"\n\n        self.server.listen(10) # Queue a maximum of 10 clients\n        # Enter the listening loop\n        while True:\n            client, client_addr = self.server.accept()\n            print(\"Received a connection from %s\" % str(client_addr))\n            client_thread = threading.Thread(target=self.handle_client, args=(client,))\n            client_thread.daemon = True\n            client_thread.start()\n\n    def handle_client(self, client):\n        \"\"\"Handle incoming client connection.\n\n        Keyword arguments:\n        client -- The client connection socket\n        \"\"\"\n\n        print(\"Accepted a client connection\")\n        while True:\n            buff = client.recv(1024).decode()\n            if not buff:\n                break\n            print(buff)\n        print(\"Client closed the connection\")\n        client.close() # We are done now, let's close the connection\n\nif __name__ == '__main__':\n    server = Server('localhost', 7000)\n```", "```py\n# simple_socket_threadpool.py\n#!/usr/bin/python3\nfrom concurrent.futures import ThreadPoolExecutor\nimport socket\n\n# Let's first create a TCP type Server for handling clients\nclass Server(object):\n    \"\"\"A simple TCP Server.\"\"\"\n\n    def __init__(self, hostname, port, pool_size):\n        \"\"\"Server initializer\n\n        Keyword arguments:\n        hostname -- The hostname to use for the server\n        port -- The port on which the server should bind\n        pool_size -- The pool size to use for the threading executor\n        \"\"\"\n\n        # Setup thread pool size\n        self.executor_pool = ThreadPoolExecutor(max_workers=pool_size)\n\n        # Setup the TCP socket server\n        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.hostname = hostname\n        self.port = port\n        self.bind_connection()\n        self.listen()\n\n    def bind_connection(self):\n        \"\"\"Bind the server to the host.\"\"\"\n\n        self.server.bind((self.hostname, self.port))\n\n    def listen(self):\n        \"\"\"Start listening for the incoming connections.\"\"\"\n\n        self.server.listen(10) # Queue a maximum of 10 clients\n        # Enter the listening loop\n        while True:\n            client, client_addr = self.server.accept()\n            print(\"Received a connection from %s\" % str(client_addr))\n            self.executor_pool.submit(self.handle_client, client)\n\n    def handle_client(self, client):\n        \"\"\"Handle incoming client connection.\n\n        Keyword arguments:\n        client -- The client connection socket\n        \"\"\"\n\n        print(\"Accepted a client connection\")\n        while True:\n            buff = client.recv(1024).decode()\n            if not buff:\n                break\n            print(buff)\n        print(\"Client closed the connection\")\n        client.close() # We are done now, let's close the connection\n\nif __name__ == '__main__':\n    server = Server('localhost', 7000, 20)\n```", "```py\nself.executor_pool = ThreadPoolExecutor(max_workers=pool_size)\n```", "```py\nself.executor_pool.submit(self.handle_client, client)\n```", "```py\nfrom concurrent.futures import ProcessPoolExecutor\n```", "```py\ndef __init__(self, hostname, port, pool_size):\n        \"\"\"Server initializer\n\n        Keyword arguments:\n        hostname -- The hostname to use for the server\n        port -- The port on which the server should bind\n        pool_size -- The size of the pool to use for the process based executor\n        \"\"\"\n\n        # Setup process pool size\n        self.executor_pool = ProcessPoolExecutor(max_workers=pool_size)\n\n        # Setup the TCP socket server\n        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.hostname = hostname\n        self.port = port\n        self.bind_connection()\n        self.listen()\n```", "```py\ndef get_number():\n  i = 0\n  while True:\n    yield i \n    i = i + 1\nnum = get_number()\nprint(next(num))\n>>> 0\nprint(next(num))\n>>> 1\n```", "```py\ndef say_hello():\n  msg = yield \"Hello\"\n  yield msg\ngreeting = say_hello()\nnext(greeting)\n>>> Hello\ngreeting.send(\"Joe\")\n>>> Joe\n```", "```py\n# async_url_fetch.py\n#!/usr/bin/python3\nimport asyncio\nimport requests\n\nasync def fetch_url(url):\n   response = requests.get(url)\n   return response.text\n\nasync def get_url(url):\n    return await fetch_url(url)\n\ndef process_results(future):\n    print(\"Got results\")\n    print(future.result())\n\nloop = asyncio.get_event_loop()\ntask1 = loop.create_task(get_url('http://www.google.com'))\ntask2 = loop.create_task(get_url('http://www.microsoft.com'))\ntask1.add_done_callback(process_results)\ntask2.add_done_callback(process_results)\nloop.run_forever()\n```", "```py\nasync def fetch_url(url)\n```", "```py\nreturn await fetch_url(url)\n```", "```py\nprint(future.results())\n```", "```py\ntask1.add_done_callback(process_results)\n```", "```py\n# async_socket_server.py#!/usr/bin/python3import asyncioclass MessageProtocol(asyncio.Protocol):    \"\"\"An asyncio protocol implementation to handle the incoming messages.\"\"\" def connection_made(self, transport): ...\n```"]