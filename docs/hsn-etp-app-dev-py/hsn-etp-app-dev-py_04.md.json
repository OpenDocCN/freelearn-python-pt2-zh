["```py\ngit clone https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python\n```", "```py\n# simple_multithreading.pyimport threadingclass SimpleThread(threading.Thread): ...\n```", "```py\nimport threading\nimport json\nimport yaml\n\nclass JSONConverter(threading.Thread):\n        def __init__(self, json_file, yaml_file, lock):\n                threading.Thread.__init__(self)\n                self.json_file = json_file\n                self.yaml_file = yaml_file\n      self.lock = lock\n\n        def run(self):\n                print(\"Starting read for {}\".format(self.json_file))\n                self.json_reader = open(self.json_file, 'r')\n                self.json = json.load(self.json_reader)\n                self.json_reader.close()\n                print(\"Read completed for {}\".format(self.json_file))\n                print(\"Writing {} to YAML\".format(self.json_file))\n      self.lock.acquire() # We acquire a lock before writing\n                self.yaml_writer = open(self.yaml_file, 'a+')\n                yaml.dump(self.json, self.yaml_writer)\n                self.yaml_writer.close()\n                self.lock.release() # Release the lock once our writes are done\n                print(\"Conversion completed for {}\".format(self.json_file))\n\nfiles = ['file1.json', 'file2.json', 'file3.json']\nwrite_lock = threading.Lock()\nconversion_threads = []\n\nfor file in files:\n        converter = JSONConverter(file, 'converted.yaml', write_lock)\n        conversion_threads.append(converter)\n        converter.start()\n\nfor cthread in conversion_threads:\n        cthread.join()\n\nprint(\"Exiting\")\n```", "```py\n# condition_variable.py\nimport threading\n\nclass EmailQueue(threading.Thread):\n\n    def __init__(self, email_queue, max_items, condition_var):\n        threading.Thread.__init__(self)\n        self.email_queue = email_queue\n        self.max_items = max_items\n        self.condition_var = condition_var\n        self.email_recipients = []\n\n    def add_recipient(self, email):\n        self.email_recipients.append(email)\n\n    def run(self):\n        while True:\n            self.condition_var.acquire()\n            if len(self.email_queue) == self.max_items:\n                print(\"E-mail queue is full. Entering wait state...\")\n                self.condition_var.wait()\n                print(\"Received consume signal. Populating queue...\")\n            while len(self.email_queue) < self.max_items:\n                if len(self.email_recipients) == 0:\n                    break\n                email = self.email_recipients.pop()\n                self.email_queue.append(email)\n                self.condition_var.notify()\n            self.condition_var.release()\n\nclass EmailSender(threading.Thread):\n\n    def __init__(self, email_queue, condition_var):\n        threading.Thread.__init__(self)\n        self.email_queue = email_queue\n        self.condition_var = condition_var\n\n    def run(self):\n        while True:\n            self.condition_var.acquire()\n            if len(self.email_queue) == 0:\n                print(\"E-mail queue is empty. Entering wait state...\")\n                self.condition_var.wait()\n                print(\"E-mail queue populated. Resuming operations...\")\n            while len(self.email_queue) is not 0:\n                email = self.email_queue.pop()\n                print(\"Sending email to {}\".format(email))\n            self.condition_var.notify()\n            self.condition_var.release()\n\nqueue = []\nMAX_QUEUE_SIZE = 100\ncondition_var = threading.Condition()\n\nemail_queue = EmailQueue(queue, MAX_QUEUE_SIZE, condition_var)\nemail_sender = EmailSender(queue, condition_var)\nemail_queue.start()\nemail_sender.start()\nemail_queue.add_recipient(\"joe@example.com\")\n```", "```py\npython condition_variable.py \nE-mail queue is empty. Entering wait state...\nE-mail queue populated. Resuming operations...\nSending email to joe@example.com\nE-mail queue is empty. Entering wait state...\n```", "```py\n# url_loader.py\nfrom multiprocessing import Process\nimport urllib.request\n\ndef load_url(url):\n    url_handle = urllib.request.urlopen(url)\n    url_data = url_handle.read()\n    # The data returned by read() call is in the bytearray format. We need to\n    # decode the data before we can print it.\n    html_data = url_data.decode('utf-8')\n    url_handle.close()\n    print(html_data)\n\nif __name__ == '__main__':\n    url = 'http://www.w3c.org'\n    loader_process = Process(target=load_url, args=(url,))\n    print(\"Spawning a new process to load the url\")\n    loader_process.start()\n    print(\"Waiting for the spawned process to exit\")\n    loader_process.join()\n    print(\"Exiting\u2026\")\n```", "```py\nfrom multiprocessing import Pool\nif __name__ == '__main__':\n    url = ['http://www.w3c.org', 'http://www.microsoft.com', '[http://www.wikipedia.org', '[http://www.packt.com']\n    with Pool(4) as loader_pool:\n      loader_pool.map(load_url, url)\n```", "```py\n# url_load_pipe.py\nfrom multiprocessing import Process, Pipe\nimport urllib.request\n\ndef load_url(url, pipe):\n    url_handle = urllib.request.urlopen(url)\n    url_data = url_handle.read()\n    # The data returned by read() call is in the bytearray format. We need to\n    # decode the data before we can print it.\n    html_data = url_data.decode('utf-8')\n    url_handle.close()\n    pipe.send(html_data)\n\nif __name__ == '__main__':\n    url = 'http://www.w3c.org'\n    parent_pipe, child_pipe = Pipe()\n    loader_process = Process(target=load_url, args=(url, child_pipe))\n    print(\"Spawning a new process to load the url\")\n    loader_process.start()\n    print(\"Waiting for the spawned process to exit\")\n    html_data = parent_pipe.recv()\n    print(html_data)\n    loader_process.join()\n    print(\"Exiting\u2026\")\n```", "```py\n# url_loader_locks.pyfrom multiprocessing import Process, Lockimport urllib.requestdef load_url(url, lock): url_handle = urllib.request.urlopen(url) ...\n```"]