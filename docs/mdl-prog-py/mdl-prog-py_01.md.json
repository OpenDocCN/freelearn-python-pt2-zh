["```py\nprint(\"Hello World!\")\n```", "```py\n**python hello.py**\n\n```", "```py\n**Hello World!**\n\n```", "```py\ndef init():\n    global _stats\n    _stats = {}\n\ndef event_occurred(event):\n    global _stats\n    try:\n        _stats[event] = _stats[event] + 1\n    except KeyError:\n        _stats[event] = 1\n\ndef get_stats():\n    global _stats\n    return sorted(_stats.items())\n```", "```py\nimport stats\n\nstats.init()\nstats.event_occurred(\"meal_eaten\")\nstats.event_occurred(\"snack_eaten\")\nstats.event_occurred(\"meal_eaten\")\nstats.event_occurred(\"snack_eaten\")\nstats.event_occurred(\"meal_eaten\")\nstats.event_occurred(\"diet_started\")\nstats.event_occurred(\"meal_eaten\")\nstats.event_occurred(\"meal_eaten\")\nstats.event_occurred(\"meal_eaten\")\nstats.event_occurred(\"diet_abandoned\")\nstats.event_occurred(\"snack_eaten\")\n\nfor event,num_times in stats.get_stats():\n    print(\"{} occurred {} times\".format(event, num_times))\n```", "```py\nstats.event_occurred(\"snack_eaten\")\n```", "```py\nimport animals.cow\nanimals.cow.speak()\n```", "```py\nimport configparser\n\ndef load_config():\n    config = configparser.ConfigParser()\n    config.read(\"config.ini\")\n    return config['config']\n\ndef get_data_from_user():\n    config = load_config()\n    data = []\n    for n in range(config.getint('num_data_points')):\n        value = input(\"Data point {}: \".format(n+1))\n        data.append(value)\n    return data\n\ndef print_results(results):\n    for value,num_times in results:\n        print(\"{} = {}\".format(value, num_times))\n\ndef analyze_data():\n    data = get_data_from_user()\n    results = {}\n    config = load_config()\n    for value in data:\n        if config.getboolean('allow_duplicates'):\n            try:\n                results[value] = results[value] + 1\n            except KeyError:\n                results[value] = 1\n        else:\n            results[value] = 1\n    return results\n\ndef sort_results(results):\n    sorted_results = []\n    for value in results.keys():\n        sorted_results.append((value, results[value]))\n    sorted_results.sort()\n    return sorted_results\n\nif __name__ == \"__main__\":\n    results = analyze_data()\n    sorted_results = sort_results(results)\n    print_results(sorted_results)\n```", "```py\ndef calc_local_price(us_dollar_amount):\n    exchange_rate = get_exchange_rate(\"USD\", \"EUR\")\n    local_amount = us_dollar_amount * exchange_rate\n    return local_amount\n```", "```py\ndef calc_local_price(foreign_amount, from_country):\n    if from_country == \"United States\":\n        exchange_rate = get_exchange_rate(\"USD\", \"EUR\")\n    elif from_country == \"China\":\n        exchange_rate = get_exchange_rate(\"CHN\", \"EUR\")\n    elif from_country == \"Germany\":\n        exchange_rate = get_exchange_rate(\"EUR\", \"EUR\")\n    elif from_country = \"Australia\":\n        exchange_rate = get_exchange_rate(\"AUS\", \"EUR\")\n    else:\n        raise RuntimeError(\"Unsupported country: \" + from_country)\n    local_amount = us_dollar_amount * exchange_rate\n    return local_amount\n```", "```py\ndef calc_shipping_cost(params):\n    if params in cache:\n        shipping_cost = cache[params]\n    else:\n        ...calculate the shipping cost.\n        cache[params] = shipping_cost\n    return shipping_cost\n```", "```py\nimport datetime\n\nMAX_CACHE_SIZE = 100\n```", "```py\ndef init():\n    global _cache\n    _cache = {} # Maps key to (datetime, value) tuple.\n```", "```py\ndef set(key, value):\n    global _cache\n    if key not in _cache and len(_cache) >= MAX_CACHE_SIZE:\n        _remove_oldest_entry()\n    _cache[key] = [datetime.datetime.now(), value]\n```", "```py\ndef get(key):\n    global _cache\n    if key in _cache:\n        _cache[key][0] = datetime.datetime.now()\n        return _cache[key][1]\n    else:\n        return None\n```", "```py\ndef contains(key):\n    global _cache\n    return key in _cache\n\ndef size():\n    global _cache\n    return len(_cache)\n```", "```py\ndef _remove_oldest_entry():\n    global _cache\n    oldest = None\n    for key in _cache.keys():\n        if oldest == None:\n            oldest = key\n        elif _cache[key][0] < _cache[oldest][0]:\n            oldest = key\n    if oldest != None:\n        del _cache[oldest]\n```", "```py\nimport random\nimport string\nimport cache\n\ndef random_string(length):\n    s = ''\n    for i in range(length):\n        s = s + random.choice(string.ascii_letters)\n    return s\n\ncache.init()\n\nfor n in range(1000):\n    while True:\n        key = random_string(20)\n        if cache.contains(key):\n            continue\n        else:\n            break\n    value = random_string(20)\n    cache.set(key, value)\n    print(\"After {} iterations, cache has {} entries\".format(n+1, cache.size()))\n```", "```py\n**$ python test_cache.py**\n**After 1 iterations, cache has 1 entries**\n**After 2 iterations, cache has 2 entries**\n**After 3 iterations, cache has 3 entries**\n**...**\n**After 98 iterations, cache has 98 entries**\n**After 99 iterations, cache has 99 entries**\n**After 100 iterations, cache has**\n **100 entries**\n**After 101 iterations, cache has 100 entries**\n**After 102 iterations, cache has 100 entries**\n**...**\n**After 998 iterations, cache has 100 entries**\n**After 999 iterations, cache has 100 entries**\n**After 1000 iterations, cache has 100 entries**\n\n```"]