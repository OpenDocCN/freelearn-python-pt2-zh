["```py\n**>>> counter.reset()**\n**>>> counter.add(\"sheep\")**\n**>>> counter.add(\"cow\")**\n**>>> counter.add(\"sheep\")**\n**>>> counter.add(\"rabbit\")**\n**>>> counter.add(\"cow\")**\n**>>> print(counter.totals())**\n**[(\"cow\", 2), (\"rabbit\", 1), (\"sheep\", 2)]**\n\n```", "```py\nAbout the ``counter`` package\n-----------------------------\n\n``counter`` is a package designed to make it easy to keep track of the number of times some event or object occurs.  Using this package, you **reset** the counter, **add** the various values to the counter, and then retrieve the calculated **totals** to see how often each value occurred.\n```", "```py\n    counter.reset()\n```", "```py\n    counter.add(color)\n```", "```py\n    for color,num_occurrences in counter.totals():\n        print(color, num_occurrences)\n```", "```py\nfrom .interface import *\n```", "```py\ndef reset():\n    pass\n\ndef add(value):\n    pass\n\ndef totals():\n    pass\n```", "```py\ndef reset():\n    \"\"\" Reset our counter.\n\n        This should be called before we start counting.\n    \"\"\"\n    pass\n```", "```py\ndef reset():\n    \"\"\" Reset our counter.\n\n        This should be called before we start counting.\n    \"\"\"\n    global _counts\n    _counts = {} # Maps value to number of occurrences.\n```", "```py\ndef add(value):\n    \"\"\" Add the given value to our counter.\n    \"\"\"\n    global _counts\n\n    try:\n        _counts[value] += 1\n    except KeyError:\n        _counts[value] = 1\n```", "```py\ndef totals():\n    \"\"\" Return the number of times each value has occurred.\n\n        We return a list of (value, num_occurrences) tuples, one\n        for each unique value included in the count.\n    \"\"\"\n    global _counts\n\n    results = []\n    for value in sorted(_counts.keys()):\n        results.append((value, _counts[value]))\n    return results\n```", "```py\n**import counter**\n**counter.reset()**\n**counter.add(1)**\n**counter.add(2)**\n**counter.add(1)**\n**print(counter.totals())**\n\n```", "```py\n**[(1, 2), (2, 1)]**\n\n```", "```py\nimport unittest\nimport counter\n\nclass CounterTestCase(unittest.TestCase):\n    \"\"\" Unit tests for the ``counter`` package.\n    \"\"\"\n    def test_counter_totals(self):\n        counter.reset()\n        counter.add(1)\n        counter.add(2)\n        counter.add(3)\n        counter.add(1)\n        self.assertEqual(counter.totals(),\n                         [(1, 2), (2, 1), (3, 1)])\n\n    def test_counter_reset(self):\n        counter.reset()\n        counter.add(1)\n        counter.reset()\n        counter.add(2)\n        self.assertEqual(counter.totals(), [(2, 1)])\n\nif __name__ == \"__main__\":\n    unittest.main()\n```", "```py\n**python tests.py**\n\n```", "```py\n**..**\n**---------------------------------------------------------------------**\n**Ran 2 tests in 0.000s**\n\n**OK**\n\n```", "```py\ncounter.reset([0, 5, 10, 15])\n```", "```py\ndef reset(ranges=None):\n    \"\"\" Reset our counter.\n\n        If 'ranges' is supplied, the given list of values will be\n        used as the start and end of each range of values.  In\n        this case, the totals will be calculated based on a range\n        of values rather than individual values.\n\n        This should be called before we start counting.\n    \"\"\"\n    global _ranges\n    global _counts\n\n    _ranges = ranges\n    _counts = {} # If _ranges is None, maps value to number of\n                 # occurrences.  Otherwise, maps (min_value,\n                 # max_value) to number of occurrences.\n```", "```py\ndef add(value):\n    \"\"\" Add the given value to our counter.\n    \"\"\"\n    global _ranges\n    global _counts\n\n    if _ranges == None:\n        key = value\n    else:\n        for i in range(len(_ranges)-1):\n            if value >= _ranges[i] and value < _ranges[i+1]:\n                key = (_ranges[i], _ranges[i+1])\n                break\n\n    try:\n        _counts[key] += 1\n    except KeyError:\n        _counts[key] = 1\n```", "```py\ndef totals():\n    \"\"\" Return the number of times each value has occurred.\n\n        If we are currently counting ranges of values, we return a\n        list of  (min_value, max_value, num_occurrences) tuples,\n        one for each range.  Otherwise, we return a list of\n        (value, num_occurrences) tuples, one for each unique value\n        included in the count.\n    \"\"\"\n    global _ranges\n    global _counts\n\n    if _ranges != None:\n        results = []\n        for i in range(len(_ranges)-1):\n            min_value = _ranges[i]\n            max_value = _ranges[i+1]\n            num_occurrences = _counts.get((min_value, max_value),\n                                          0)\n            results.append((min_value, max_value,\n                            num_occurrences))\n        return results\n    else:\n        results = []\n        for value in sorted(_counts.keys()):\n            results.append((value, _counts[value]))\n        return results\n```", "```py\nimport counter\ncounter.reset([0, 5, 10, 15])\ncounter.add(5.7)\ncounter.add(4.6)\ncounter.add(14.2)\ncounter.add(0.3)\ncounter.add(7.1)\ncounter.add(2.6)\nprint(counter.totals())\n```", "```py\n[(0, 5, 3), (5, 10, 2), (10, 15, 1)]\n```", "```py\nclass RangeCounterTestCase(unittest.TestCase):\n    \"\"\" Unit tests for the range-based features of the\n        ``counter`` package.\n    \"\"\"\n    def test_range_totals(self):\n        counter.reset([0, 5, 10, 15])\n        counter.add(3)\n        counter.add(9)\n        counter.add(4.5)\n        counter.add(12)\n        counter.add(19.1)\n        counter.add(14.2)\n        counter.add(8)\n        self.assertEqual(counter.totals(),\n                         [(0, 5, 2), (5, 10, 2), (10, 15, 2)])\n```", "```py\nERROR: test_range_totals (__main__.RangeCounterTestCase)\n-----------------------------------------------------------------\nTraceback (most recent call last):\n  File \"tests.py\", line 35, in test_range_totals\n    counter.add(19.1)\n  File \"/Users/erik/Project Support/Work/Packt/PythonModularProg/First Draft/Chapter 9/code/counter-ranges/counter/interface.py\", line 36, in add\n    _counts[key] += 1\nUnboundLocalError: local variable 'key' referenced before assignment\n```", "```py\ndef add(value):\n    \"\"\" Add the given value to our counter.\n    \"\"\"\n    global _ranges\n    global _counts\n\n    if _ranges == None:\n        key = value\n    else:\n **key = None**\n        for i in range(len(_ranges)-1):\n            if value >= _ranges[i] and value < _ranges[i+1]:\n                key = (_ranges[i], _ranges[i+1])\n                break\n **if key == None:**\n **raise RuntimeError(\"Value out of range: {}\".format(value))**\n\n    try:\n        _counts[key] += 1\n    except KeyError:\n        _counts[key] = 1\n```", "```py\n    def test_out_of_range(self):\n        counter.reset([0, 5, 10, 15])\n        with self.assertRaises(RuntimeError):\n            counter.add(19.1)\n```"]