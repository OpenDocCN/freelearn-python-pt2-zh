["```py\nclass GitFetcher:\n    _current_tag = None\n\n    def __init__(self, tag):\n        self.current_tag = tag\n\n    @property\n    def current_tag(self):\n        if self._current_tag is None:\n            raise AttributeError(\"tag was never set\")\n        return self._current_tag\n\n    @current_tag.setter\n    def current_tag(self, new_tag):\n        self.__class__._current_tag = new_tag\n\n    def pull(self):\n        logger.info(\"pulling from %s\", self.current_tag)\n        return self.current_tag\n```", "```py\n>>> f1 = GitFetcher(0.1)\n>>> f2 = GitFetcher(0.2)\n>>> f1.current_tag = 0.3\n>>> f2.pull()\n0.3\n>>> f1.pull()\n0.3\n```", "```py\nclass SharedAttribute:\n    def __init__(self, initial_value=None):\n        self.value = initial_value\n        self._name = None\n\n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        if self.value is None:\n            raise AttributeError(f\"{self._name} was never set\")\n        return self.value\n\n    def __set__(self, instance, new_value):\n        self.value = new_value\n\n    def __set_name__(self, owner, name):\n        self._name = name\n```", "```py\nclass GitFetcher:\n    current_tag = SharedAttribute()\n    current_branch = SharedAttribute()\n\n    def __init__(self, tag, branch=None):\n        self.current_tag = tag\n        self.current_branch = branch\n\n    def pull(self):\n        logger.info(\"pulling from %s\", self.current_tag)\n        return self.current_tag\n```", "```py\nclass BaseFetcher:\n    def __init__(self, source):\n        self.source = source\n\nclass TagFetcher(BaseFetcher):\n    _attributes = {}\n\n    def __init__(self, source):\n        self.__dict__ = self.__class__._attributes\n        super().__init__(source)\n\n    def pull(self):\n        logger.info(\"pulling from tag %s\", self.source)\n        return f\"Tag = {self.source}\"\n\nclass BranchFetcher(BaseFetcher):\n    _attributes = {}\n\n    def __init__(self, source):\n        self.__dict__ = self.__class__._attributes\n        super().__init__(source)\n\n    def pull(self):\n        logger.info(\"pulling from branch %s\", self.source)\n        return f\"Branch = {self.source}\"\n```", "```py\nclass SharedAllMixin:\n    def __init__(self, *args, **kwargs):\n        try:\n            self.__class__._attributes\n        except AttributeError:\n            self.__class__._attributes = {}\n\n        self.__dict__ = self.__class__._attributes\n        super().__init__(*args, **kwargs)\n\nclass BaseFetcher:\n    def __init__(self, source):\n        self.source = source\n\nclass TagFetcher(SharedAllMixin, BaseFetcher):\n    def pull(self):\n        logger.info(\"pulling from tag %s\", self.source)\n        return f\"Tag = {self.source}\"\n\nclass BranchFetcher(SharedAllMixin, BaseFetcher):\n    def pull(self):\n        logger.info(\"pulling from branch %s\", self.source)\n        return f\"Branch = {self.source}\"\n```", "```py\nfrom _adapter_base import UsernameLookup\n\nclass UserSource(UsernameLookup):\n    def fetch(self, user_id, username):\n        user_namespace = self._adapt_arguments(user_id, username)\n        return self.search(user_namespace)\n\n    @staticmethod\n    def _adapt_arguments(user_id, username):\n        return f\"{user_id}:{username}\"\n```", "```py\nclass UserSource:\n    ...\n    def fetch(self, user_id, username):\n        user_namespace = self._adapt_arguments(user_id, username)\n        return self.username_lookup.search(user_namespace)\n```", "```py\nclass Product:\n    def __init__(self, name, price):\n        self._name = name\n        self._price = price\n\n    @property\n    def price(self):\n        return self._price\n\nclass ProductBundle:\n    def __init__(\n        self,\n        name,\n        perc_discount,\n        *products: Iterable[Union[Product, \"ProductBundle\"]]\n    ) -> None:\n        self._name = name\n        self._perc_discount = perc_discount\n        self._products = products\n\n    @property\n    def price(self):\n        total = sum(p.price for p in self._products)\n        return total * (1 - self._perc_discount)\n```", "```py\nclass DictQuery:\n    def __init__(self, **kwargs):\n        self._raw_query = kwargs\n\n    def render(self) -> dict:\n        return self._raw_query\n```", "```py\nclass QueryEnhancer:\n    def __init__(self, query: DictQuery):\n        self.decorated = query\n\n    def render(self):\n        return self.decorated.render()\n\nclass RemoveEmpty(QueryEnhancer):\n    def render(self):\n        original = super().render()\n        return {k: v for k, v in original.items() if v}\n\nclass CaseInsensitive(QueryEnhancer):\n    def render(self):\n        original = super().render()\n        return {k: v.lower() for k, v in original.items()}\n```", "```py\n>>> original = DictQuery(key=\"value\", empty=\"\", none=None, upper=\"UPPERCASE\", title=\"Title\")\n>>> new_query = CaseInsensitive(RemoveEmpty(original))\n>>> original.render()\n{'key': 'value', 'empty': '', 'none': None, 'upper': 'UPPERCASE', 'title': 'Title'}\n>>> new_query.render()\n{'key': 'value', 'upper': 'uppercase', 'title': 'title'}\n```", "```py\nclass QueryEnhancer:\n    def __init__(\n        self,\n        query: DictQuery,\n        *decorators: Iterable[Callable[[Dict[str, str]], Dict[str, str]]]\n    ) -> None:\n        self._decorated = query\n        self._decorators = decorators\n\n    def render(self):\n        current_result = self._decorated.render()\n        for deco in self._decorators:\n            current_result = deco(current_result)\n        return current_result\n```", "```py\n>>> query = DictQuery(foo=\"bar\", empty=\"\", none=None, upper=\"UPPERCASE\", title=\"Title\")\n>>> QueryEnhancer(query, remove_empty, case_insensitive).render()\n{'foo': 'bar', 'upper': 'uppercase', 'title': 'title'}\n```", "```py\nimport re\n\nclass Event:\n    pattern = None\n\n    def __init__(self, next_event=None):\n        self.successor = next_event\n\n    def process(self, logline: str):\n        if self.can_process(logline):\n            return self._process(logline)\n\n        if self.successor is not None:\n            return self.successor.process(logline)\n\n    def _process(self, logline: str) -> dict:\n        parsed_data = self._parse_data(logline)\n        return {\n            \"type\": self.__class__.__name__,\n            \"id\": parsed_data[\"id\"],\n            \"value\": parsed_data[\"value\"],\n        }\n\n    @classmethod\n    def can_process(cls, logline: str) -> bool:\n        return cls.pattern.match(logline) is not None\n\n    @classmethod\n    def _parse_data(cls, logline: str) -> dict:\n        return cls.pattern.match(logline).groupdict()\n\nclass LoginEvent(Event):\n    pattern = re.compile(r\"(?P<id>\\d+):\\s+login\\s+(?P<value>\\S+)\")\n\nclass LogoutEvent(Event):\n    pattern = re.compile(r\"(?P<id>\\d+):\\s+logout\\s+(?P<value>\\S+)\")\n```", "```py\n>>> chain = LogoutEvent(LoginEvent())\n>>> chain.process(\"567: login User\")\n{'type': 'LoginEvent', 'id': '567', 'value': 'User'}\n```", "```py\nclass SessionEvent(Event):\n    pattern = re.compile(r\"(?P<id>\\d+):\\s+log(in|out)\\s+(?P<value>\\S+)\")\n```", "```py\nchain = SessionEvent(LoginEvent(LogoutEvent()))\n```", "```py\nclass InvalidTransitionError(Exception):\n    \"\"\"Raised when trying to move to a target state from an unreachable \n    source\n    state.\n    \"\"\"\n\nclass MergeRequestState(abc.ABC):\n    def __init__(self, merge_request):\n        self._merge_request = merge_request\n\n    @abc.abstractmethod\n    def open(self):\n        ...\n\n    @abc.abstractmethod\n    def close(self):\n        ...\n\n    @abc.abstractmethod\n    def merge(self):\n        ...\n\n    def __str__(self):\n        return self.__class__.__name__\n\nclass Open(MergeRequestState):\n    def open(self):\n        self._merge_request.approvals = 0\n\n    def close(self):\n        self._merge_request.approvals = 0\n        self._merge_request.state = Closed\n\n    def merge(self):\n        logger.info(\"merging %s\", self._merge_request)\n        logger.info(\"deleting branch %s\", \n        self._merge_request.source_branch)\n        self._merge_request.state = Merged\n\nclass Closed(MergeRequestState):\n    def open(self):\n        logger.info(\"reopening closed merge request %s\", \n         self._merge_request)\n        self._merge_request.state = Open\n\n    def close(self):\n        pass\n\n    def merge(self):\n        raise InvalidTransitionError(\"can't merge a closed request\")\n\nclass Merged(MergeRequestState):\n    def open(self):\n        raise InvalidTransitionError(\"already merged request\")\n\n    def close(self):\n        raise InvalidTransitionError(\"already merged request\")\n\n    def merge(self):\n        pass\n\nclass MergeRequest:\n    def __init__(self, source_branch: str, target_branch: str) -> None:\n        self.source_branch = source_branch\n        self.target_branch = target_branch\n        self._state = None\n        self.approvals = 0\n        self.state = Open\n\n    @property\n    def state(self):\n        return self._state\n\n    @state.setter\n    def state(self, new_state_cls):\n        self._state = new_state_cls(self)\n\n    def open(self):\n        return self.state.open()\n\n    def close(self):\n        return self.state.close()\n\n    def merge(self):\n        return self.state.merge()\n\n    def __str__(self):\n        return f\"{self.target_branch}:{self.source_branch}\"\n```", "```py\n>>> mr = MergeRequest(\"develop\", \"master\") \n>>> mr.open()\n>>> mr.approvals\n0\n>>> mr.approvals = 3\n>>> mr.close()\n>>> mr.approvals\n0\n>>> mr.open()\nINFO:log:reopening closed merge request master:develop\n>>> mr.merge()\nINFO:log:merging master:develop\nINFO:log:deleting branch develop\n>>> mr.close()\nTraceback (most recent call last):\n...\nInvalidTransitionError: already merged request\n```", "```py\nclass MergeRequest:\n    def __init__(self, source_branch: str, target_branch: str) -> None:\n        self.source_branch = source_branch\n        self.target_branch = target_branch\n        self._state: MergeRequestState\n        self.approvals = 0\n        self.state = Open\n\n    @property\n    def state(self):\n        return self._state\n\n    @state.setter\n    def state(self, new_state_cls):\n        self._state = new_state_cls(self)\n\n    @property\n    def status(self):\n        return str(self.state)\n\n    def __getattr__(self, method):\n        return getattr(self.state, method)\n\n    def __str__(self):\n        return f\"{self.target_branch}:{self.source_branch}\"\n```", "```py\nAttributeError: 'NoneType' object has no attribute 'keys'\n```"]