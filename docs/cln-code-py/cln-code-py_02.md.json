["```py\n>>> my_numbers = (4, 5, 3, 9)\n>>> my_numbers[-1]\n9\n>>> my_numbers[-3]\n5\n```", "```py\n>>> my_numbers = (1, 1, 2, 3, 5, 8, 13, 21)\n>>> my_numbers[2:5]\n(2, 3, 5)\n```", "```py\n>>> my_numbers[:3]\n(1, 1, 2)\n>>> my_numbers[3:]\n(3, 5, 8, 13, 21)\n>>> my_numbers[::]\n(1, 1, 2, 3, 5, 8, 13, 21)\n>>> my_numbers[1:7:2]\n(1, 3, 8)\n```", "```py\n>>> interval = slice(1, 7, 2)\n>>> my_numbers[interval]\n(1, 3, 8)\n\n>>> interval = slice(None, 3)\n>>> my_numbers[interval] == my_numbers[:3]\nTrue\n```", "```py\nclass Items:\n    def __init__(self, *values):\n        self._values = list(values)\n\n    def __len__(self):\n        return len(self._values)\n\n    def __getitem__(self, item):\n        return self._values.__getitem__(item)\n```", "```py\n>>> range(1, 100)[25:50]\nrange(26, 51)\n```", "```py\nfd = open(filename)\ntry:\n    process_file(fd)\nfinally:\n    fd.close()\n```", "```py\nwith open(filename) as fd:\n    process_file(fd)\n```", "```py\ndef stop_database():\n    run(\"systemctl stop postgresql.service\")\n\ndef start_database():\n    run(\"systemctl start postgresql.service\")\n\nclass DBHandler:\n    def __enter__(self):\n        stop_database()\n        return self\n\n    def __exit__(self, exc_type, ex_value, ex_traceback):\n        start_database()\n\ndef db_backup():\n    run(\"pg_dump database\")\n\ndef main():\n    with DBHandler():\n        db_backup()\n```", "```py\nimport contextlib\n\n@contextlib.contextmanager\ndef db_handler():\n    stop_database()\n    yield\n    start_database()\n\nwith db_handler():\n    db_backup()\n```", "```py\nclass dbhandler_decorator(contextlib.ContextDecorator):\n    def __enter__(self):\n        stop_database()\n\n    def __exit__(self, ext_type, ex_value, ex_traceback):\n        start_database()\n\n@dbhandler_decorator()\ndef offline_backup():\n    run(\"pg_dump database\")\n```", "```py\nimport contextlib\n\nwith contextlib.suppress(DataConversionException):\n      parse_data(input_json_or_dict)\n```", "```py\n>>> class Connector:\n...     def __init__(self, source):\n...         self.source = source\n...         self._timeout = 60\n... \n>>> conn = Connector(\"postgresql://localhost\")\n>>> conn.source\n'postgresql://localhost'\n>>> conn._timeout\n60\n>>> conn.__dict__\n{'source': 'postgresql://localhost', '_timeout': 60}\n```", "```py\n>>> class Connector:\n...     def __init__(self, source):\n...         self.source = source\n...         self.__timeout = 60\n...\n...      def connect(self):\n...         print(\"connecting with {0}s\".format(self.__timeout))\n...         # ...\n... \n>>> conn = Connector(\"postgresql://localhost\")\n>>> conn.connect()\nconnecting with 60s\n>>> conn.__timeout\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nAttributeError: 'Connector' object has no attribute '__timeout'\n```", "```py\n>>> vars(conn)\n{'source': 'postgresql://localhost', '_Connector__timeout': 60}\n>>> conn._Connector__timeout\n60\n>>> conn._Connector__timeout = 30\n>>> conn.connect()\nconnecting with 30s\n```", "```py\nimport re\n\nEMAIL_FORMAT = re.compile(r\"[^@]+@[^@]+\\.[^@]+\")\n\ndef is_valid_email(potentially_valid_email: str):\n    return re.match(EMAIL_FORMAT, potentially_valid_email) is not None\n\nclass User:\n    def __init__(self, username):\n        self.username = username\n        self._email = None\n\n    @property\n    def email(self):\n        return self._email\n\n    @email.setter\n    def email(self, new_email):\n        if not is_valid_email(new_email):\n            raise ValueError(f\"Can't set {new_email} as it's not a \n            valid email\")\n        self._email = new_email\n```", "```py\n>>> u1 = User(\"jsmith\")\n>>> u1.email = \"jsmith@\"\nTraceback (most recent call last):\n...\nValueError: Can't set jsmith@ as it's not a valid email\n>>> u1.email = \"jsmith@g.co\"\n>>> u1.email\n'jsmith@g.co'\n```", "```py\nfrom datetime import timedelta\n\nclass DateRangeIterable:\n    \"\"\"An iterable that contains its own iterator object.\"\"\"\n\n    def __init__(self, start_date, end_date):\n        self.start_date = start_date\n        self.end_date = end_date\n        self._present_day = start_date\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self._present_day >= self.end_date:\n            raise StopIteration\n        today = self._present_day\n        self._present_day += timedelta(days=1)\n        return today\n```", "```py\n>>> for day in DateRangeIterable(date(2018, 1, 1), date(2018, 1, 5)):\n...     print(day)\n... \n2018-01-01\n2018-01-02\n2018-01-03\n2018-01-04\n>>> \n```", "```py\n>>> r = DateRangeIterable(date(2018, 1, 1), date(2018, 1, 5))\n>>> next(r)\ndatetime.date(2018, 1, 1)\n>>> next(r)\ndatetime.date(2018, 1, 2)\n>>> next(r)\ndatetime.date(2018, 1, 3)\n>>> next(r)\ndatetime.date(2018, 1, 4)\n>>> next(r)\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\n File ... __next__\n raise StopIteration\nStopIteration\n>>> \n```", "```py\n>>> r1 = DateRangeIterable(date(2018, 1, 1), date(2018, 1, 5))\n>>> \", \".join(map(str, r1))\n'2018-01-01, 2018-01-02, 2018-01-03, 2018-01-04'\n>>> max(r1)\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nValueError: max() arg is an empty sequence\n>>> \n```", "```py\nclass DateRangeContainerIterable:\n    def __init__(self, start_date, end_date):\n        self.start_date = start_date\n        self.end_date = end_date\n\n    def __iter__(self):\n        current_day = self.start_date\n        while current_day < self.end_date:\n            yield current_day\n            current_day += timedelta(days=1)\n```", "```py\n>>> r1 = DateRangeContainerIterable(date(2018, 1, 1), date(2018, 1, 5))\n>>> \", \".join(map(str, r1))\n'2018-01-01, 2018-01-02, 2018-01-03, 2018-01-04'\n>>> max(r1)\ndatetime.date(2018, 1, 4)\n>>> \n```", "```py\nclass DateRangeSequence:\n    def __init__(self, start_date, end_date):\n        self.start_date = start_date\n        self.end_date = end_date\n        self._range = self._create_range()\n\n    def _create_range(self):\n        days = []\n        current_day = self.start_date\n        while current_day < self.end_date:\n            days.append(current_day)\n            current_day += timedelta(days=1)\n        return days\n\n    def __getitem__(self, day_no):\n        return self._range[day_no]\n\n    def __len__(self):\n        return len(self._range)\n```", "```py\n>>> s1 = DateRangeSequence(date(2018, 1, 1), date(2018, 1, 5))\n>>> for day in s1:\n...     print(day)\n... \n2018-01-01\n2018-01-02\n2018-01-03\n2018-01-04\n>>> s1[0]\ndatetime.date(2018, 1, 1)\n>>> s1[3]\ndatetime.date(2018, 1, 4)\n>>> s1[-1]\ndatetime.date(2018, 1, 4)\n```", "```py\nelement in container\n```", "```py\ncontainer.__contains__(element)\n```", "```py\ndef mark_coordinate(grid, coord):\n    if 0 <= coord.x < grid.width and 0 <= coord.y < grid.height:\n        grid[coord] = MARKED\n```", "```py\nclass Boundaries:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def __contains__(self, coord):\n        x, y = coord\n        return 0 <= x < self.width and 0 <= y < self.height\n\nclass Grid:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n        self.limits = Boundaries(width, height)\n\n    def __contains__(self, coord):\n        return coord in self.limits\n```", "```py\ndef mark_coordinate(grid, coord):\n    if coord in grid:\n        grid[coord] = MARKED\n```", "```py\nclass DynamicAttributes:\n\n    def __init__(self, attribute):\n        self.attribute = attribute\n\n    def __getattr__(self, attr):\n        if attr.startswith(\"fallback_\"):\n            name = attr.replace(\"fallback_\", \"\")\n            return f\"[fallback resolved] {name}\"\n        raise AttributeError(\n            f\"{self.__class__.__name__} has no attribute {attr}\"\n        )\n```", "```py\n>>> dyn = DynamicAttributes(\"value\")\n>>> dyn.attribute\n'value'\n\n>>> dyn.fallback_test\n'[fallback resolved] test'\n\n>>> dyn.__dict__[\"fallback_new\"] = \"new value\"\n>>> dyn.fallback_new\n'new value'\n\n>>> getattr(dyn, \"something\", \"default\")\n'default'\n```", "```py\nfrom collections import defaultdict\n\nclass CallCount:\n\n    def __init__(self):\n        self._counts = defaultdict(int)\n\n    def __call__(self, argument):\n        self._counts[argument] += 1\n        return self._counts[argument]\n```", "```py\n>>> cc = CallCount()\n>>> cc(1)\n1\n>>> cc(2)\n1\n>>> cc(1)\n2\n>>> cc(1)\n3\n>>> cc(\"something\")\n1\n```", "```py\ndef wrong_user_display(user_metadata: dict = {\"name\": \"John\", \"age\": 30}):\n    name = user_metadata.pop(\"name\")\n    age = user_metadata.pop(\"age\")\n\n    return f\"{name} ({age})\"\n```", "```py\n>>> wrong_user_display()\n'John (30)'\n>>> wrong_user_display({\"name\": \"Jane\", \"age\": 25})\n'Jane (25)'\n>>> wrong_user_display()\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\n File ... in wrong_user_display\n name = user_metadata.pop(\"name\")\nKeyError: 'name' \n```", "```py\ndef user_display(user_metadata: dict = None):\n    user_metadata = user_metadata or {\"name\": \"John\", \"age\": 30}\n\n    name = user_metadata.pop(\"name\")\n    age = user_metadata.pop(\"age\")\n\n    return f\"{name} ({age})\"\n```", "```py\nclass BadList(list):\n    def __getitem__(self, index):\n        value = super().__getitem__(index)\n        if index % 2 == 0:\n            prefix = \"even\"\n        else:\n            prefix = \"odd\"\n        return f\"[{prefix}] {value}\"\n```", "```py\n>>> bl = BadList((0, 1, 2, 3, 4, 5))\n>>> bl[0]\n'[even] 0'\n>>> bl[1]\n'[odd] 1'\n>>> \"\".join(bl)\nTraceback (most recent call last):\n...\nTypeError: sequence item 0: expected str instance, int found\n```", "```py\nfrom collections import UserList\n\nclass GoodList(UserList):\n    def __getitem__(self, index):\n        value = super().__getitem__(index)\n        if index % 2 == 0:\n            prefix = \"even\"\n        else:\n            prefix = \"odd\"\n        return f\"[{prefix}] {value}\"\n```", "```py\n>>> gl = GoodList((0, 1, 2))\n>>> gl[0]\n'[even] 0'\n>>> gl[1]\n'[odd] 1'\n>>> \"; \".join(gl)\n'[even] 0; [odd] 1; [even] 2'\n```"]