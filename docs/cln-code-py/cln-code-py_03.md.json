["```py\n>>> configuration = {\"dbport\": 5432}\n>>> configuration.get(\"dbhost\", \"localhost\")\n'localhost'\n>>> configuration.get(\"dbport\")\n5432\n```", "```py\n>>> import os\n>>> os.getenv(\"DBHOST\")\n'localhost'\n>>> os.getenv(\"DPORT\", 5432)\n5432\n```", "```py\n>>> def connect_database(host=\"localhost\", port=5432):\n...     logger.info(\"connecting to database server at %s:%i\", host, port)\n```", "```py\nclass DataTransport:\n    \"\"\"An example of an object handling exceptions of different levels.\"\"\"\n\n    retry_threshold: int = 5\n    retry_n_times: int = 3\n\n    def __init__(self, connector):\n        self._connector = connector\n        self.connection = None\n\n    def deliver_event(self, event):\n        try:\n            self.connect()\n            data = event.decode()\n            self.send(data)\n        except ConnectionError as e:\n            logger.info(\"connection error detected: %s\", e)\n            raise\n        except ValueError as e:\n            logger.error(\"%r contains incorrect data: %s\", event, e)\n            raise\n\n    def connect(self):\n        for _ in range(self.retry_n_times):\n            try:\n                self.connection = self._connector.connect()\n            except ConnectionError as e:\n                logger.info(\n                    \"%s: attempting new connection in %is\",\n                    e,\n                    self.retry_threshold,\n                )\n                time.sleep(self.retry_threshold)\n            else:\n                return self.connection\n        raise ConnectionError(\n            f\"Couldn't connect after {self.retry_n_times} times\"\n        )\n\n    def send(self, data):\n        return self.connection.send(data)\n```", "```py\ndef connect_with_retry(connector, retry_n_times, retry_threshold=5):\n    \"\"\"Tries to establish the connection of <connector> retrying\n    <retry_n_times>.\n\n    If it can connect, returns the connection object.\n    If it's not possible after the retries, raises ConnectionError\n\n    :param connector: An object with a `.connect()` method.\n    :param retry_n_times int: The number of times to try to call\n                                ``connector.connect()``.\n    :param retry_threshold int: The time lapse between retry calls.\n\n    \"\"\"\n    for _ in range(retry_n_times):\n        try:\n            return connector.connect()\n        except ConnectionError as e:\n            logger.info(\n                \"%s: attempting new connection in %is\", e, retry_threshold\n            )\n```", "```py\n            time.sleep(retry_threshold)\n    exc = ConnectionError(f\"Couldn't connect after {retry_n_times} times\")\n    logger.exception(exc)\n    raise exc\n```", "```py\nclass DataTransport:\n    \"\"\"An example of an object that separates the exception handling by\n    abstraction levels.\n    \"\"\"\n\n    retry_threshold: int = 5\n    retry_n_times: int = 3\n\n    def __init__(self, connector):    \n        self._connector = connector\n        self.connection = None\n\n    def deliver_event(self, event):\n        self.connection = connect_with_retry(\n            self._connector, self.retry_n_times, self.retry_threshold\n        )\n        self.send(event)\n\n    def send(self, event):\n        try:\n            return self.connection.send(event.decode())\n        except ValueError as e:\n            logger.error(\"%r contains incorrect data: %s\", event, e)\n            raise\n```", "```py\ntry:\n    process_data()\nexcept:\n    pass\n```", "```py\nclass InternalDataError(Exception):\n    \"\"\"An exception with the data of our domain problem.\"\"\"\n\ndef process(data_dictionary, record_id):\n    try:\n        return data_dictionary[record_id]\n    except KeyError as e:\n        raise InternalDataError(\"Record not present\") from e\n```", "```py\ntry:\n    assert condition.holds(), \"Condition is not satisfied\"\nexcept AssertionError:\n    alternative_procedure()\n```", "```py\nresult = condition.holds()\nassert result > 0, \"Error with {0}\".format(result)\n```", "```py\ndef process_students_list(students):\n    # do some processing...\n\n    students_ranking = sorted(\n        students, key=lambda s: s.passed * 11 - s.failed * 5 - s.years * 2\n    )\n    # more processing\n    for student in students_ranking:\n        print(\n            \"Name: {0}, Score: {1}\".format(\n                student.name,\n                (student.passed * 11 - student.failed * 5 - student.years * 2),\n            )\n        )\n```", "```py\ndef score_for_student(student):\n    return student.passed * 11 - student.failed * 5 - student.years * 2\n\ndef process_students_list(students):\n    # do some processing...\n\n    students_ranking = sorted(students, key=score_for_student)\n    # more processing\n    for student in students_ranking:\n        print(\n            \"Name: {0}, Score: {1}\".format(\n                student.name, score_for_student(student)\n            )\n        )\n```", "```py\nclass ComplicatedNamespace:\n    \"\"\"An convoluted example of initializing an object with some properties.\"\"\"\n\n    ACCEPTED_VALUES = (\"id_\", \"user\", \"location\")\n\n    @classmethod\n    def init_with_data(cls, **data):\n        instance = cls()\n        for key, value in data.items():\n            if key in cls.ACCEPTED_VALUES:\n                setattr(instance, key, value)\n        return instance\n```", "```py\n>>> cn = ComplicatedNamespace.init_with_data(\n...     id_=42, user=\"root\", location=\"127.0.0.1\", extra=\"excluded\"\n... )\n>>> cn.id_, cn.user, cn.location\n(42, 'root', '127.0.0.1')\n\n>>> hasattr(cn, \"extra\")\nFalse\n```", "```py\nclass Namespace:\n    \"\"\"Create an object from keyword arguments.\"\"\"\n\n    ACCEPTED_VALUES = (\"id_\", \"user\", \"location\")\n\n    def __init__(self, **data):\n        accepted_data = {\n            k: v for k, v in data.items() if k in self.ACCEPTED_VALUES\n        }\n        self.__dict__.update(accepted_data)\n```", "```py\nif os.path.exists(filename):\n    with open(filename) as f:\n        ...\n```", "```py\ntry:\n    with open(filename) as f:\n        ...\nexcept FileNotFoundError as e:\n    logger.error(e)\n```", "```py\nclass TransactionalPolicy(collections.UserDict):\n    \"\"\"Example of an incorrect use of inheritance.\"\"\"\n\n    def change_in_policy(self, customer_id, **new_policy_data):\n        self[customer_id].update(**new_policy_data)\n```", "```py\n>>> policy = TransactionalPolicy({\n...     \"client001\": { \n...         \"fee\": 1000.0, \n...         \"expiration_date\": datetime(2020, 1, 3), \n...     } \n... }) \n>>> policy[\"client001\"]\n{'fee': 1000.0, 'expiration_date': datetime.datetime(2020, 1, 3, 0, 0)}\n>>> policy.change_in_policy(\"client001\", expiration_date=datetime(2020, 1, 4))\n>>> policy[\"client001\"]\n{'fee': 1000.0, 'expiration_date': datetime.datetime(2020, 1, 4, 0, 0)}\n```", "```py\n>>> dir(policy)\n[ # all magic and special method have been omitted for brevity...\n 'change_in_policy', 'clear', 'copy', 'data', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']\n```", "```py\nclass TransactionalPolicy:\n    \"\"\"Example refactored to use composition.\"\"\"\n\n    def __init__(self, policy_data, **extra_data):\n        self._data = {**policy_data, **extra_data}\n\n    def change_in_policy(self, customer_id, **new_policy_data):\n        self._data[customer_id].update(**new_policy_data)\n\n    def __getitem__(self, customer_id):\n        return self._data[customer_id]\n\n    def __len__(self):\n        return len(self._data)\n```", "```py\nclass BaseModule:\n    module_name = \"top\"\n\n    def __init__(self, module_name):\n        self.name = module_name\n\n    def __str__(self):\n        return f\"{self.module_name}:{self.name}\"\n\nclass BaseModule1(BaseModule):\n    module_name = \"module-1\"\n\nclass BaseModule2(BaseModule):\n    module_name = \"module-2\"\n\nclass BaseModule3(BaseModule):\n    module_name = \"module-3\"\n\nclass ConcreteModuleA12(BaseModule1, BaseModule2):\n    \"\"\"Extend 1 & 2\"\"\"\n\n```", "```py\nclass ConcreteModuleB23(BaseModule2, BaseModule3):\n    \"\"\"Extend 2 & 3\"\"\"\n```", "```py\n>>> str(ConcreteModuleA12(\"test\"))\n'module-1:test'\n```", "```py\n>>> [cls.__name__ for cls in ConcreteModuleA12.mro()]\n['ConcreteModuleA12', 'BaseModule1', 'BaseModule2', 'BaseModule', 'object']\n```", "```py\nclass BaseTokenizer:\n\n    def __init__(self, str_token):\n        self.str_token = str_token\n\n    def __iter__(self):\n        yield from self.str_token.split(\"-\")\n```", "```py\n>>> tk = BaseTokenizer(\"28a2320b-fd3f-4627-9792-a2b38e3c46b0\")\n>>> list(tk)\n['28a2320b', 'fd3f', '4627', '9792', 'a2b38e3c46b0']\n```", "```py\nclass UpperIterableMixin:\n    def __iter__(self):\n        return map(str.upper, super().__iter__())\n\nclass Tokenizer(UpperIterableMixin, BaseTokenizer):\n    pass\n```", "```py\n>>> def function(argument):\n...     argument += \" in function\"\n...     print(argument)\n... \n>>> immutable = \"hello\"\n>>> function(immutable)\nhello in function\n>>> mutable = list(\"hello\")\n>>> immutable\n'hello'\n>>> function(mutable)\n['h', 'e', 'l', 'l', 'o', ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n']\n>>> mutable\n['h', 'e', 'l', 'l', 'o', ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n']\n>>> \n```", "```py\n>>> def f(first, second, third):\n...     print(first)\n...     print(second)\n...     print(third)\n... \n>>> l = [1, 2, 3]\n>>> f(*l)\n1\n2\n3\n```", "```py\n>>> a, b, c = [1, 2, 3]\n>>> a\n1\n>>> b\n2\n>>> c\n3\n```", "```py\n>>> def show(e, rest):\n...     print(\"Element: {0} - Rest: {1}\".format(e, rest))\n... \n>>> first, *rest = [1, 2, 3, 4, 5]\n>>> show(first, rest)\nElement: 1 - Rest: [2, 3, 4, 5]\n>>> *rest, last = range(6)\n>>> show(last, rest)\nElement: 5 - Rest: [0, 1, 2, 3, 4]\n>>> first, *middle, last = range(6)\n>>> first\n0\n>>> middle\n[1, 2, 3, 4]\n>>> last\n5\n>>> first, last, *empty = (1, 2)\n>>> first\n1\n>>> last\n2\n>>> empty\n[]\n```", "```py\nUSERS = [(i, f\"first_name_{i}\", \"last_name_{i}\") for i in range(1_000)]\n\nclass User:\n    def __init__(self, user_id, first_name, last_name):\n        self.user_id = user_id\n        self.first_name = first_name\n        self.last_name = last_name\n\ndef bad_users_from_rows(dbrows) -> list:\n    \"\"\"A bad case (non-pythonic) of creating ``User``s from DB rows.\"\"\"\n    return [User(row[0], row[1], row[2]) for row in dbrows]\n\ndef users_from_rows(dbrows) -> list:\n    \"\"\"Create ``User``s from DB rows.\"\"\"\n    return [\n        User(user_id, first_name, last_name)\n        for (user_id, first_name, last_name) in dbrows\n    ]\n```", "```py\nmax(...)\n    max(iterable, *[, default=obj, key=func]) -> value\n    max(arg1, arg2, *args, *[, key=func]) -> value\n\n    With a single iterable argument, return its biggest item. The\n    default keyword-only argument specifies an object to return if\n    the provided iterable is empty.\n    With two or more arguments, return the largest argument.\n```", "```py\nfunction(**{\"key\": \"value\"})\n```", "```py\nfunction(key=\"value\")\n```", "```py\n>>> def function(**kwargs):\n...     print(kwargs)\n... \n>>> function(key=\"value\")\n{'key': 'value'}\n```", "```py\ntrack_request(request.headers, request.ip_addr, request.request_id)\n```", "```py\ndef calculate_price(base_price: float, tax: float, discount: float) -> \n    return (base_price * (1 + tax)) * (1 - discount)\n\ndef show_price(price: float) -> str:\n    return \"$ {0:,.2f}\".format(price)\n\ndef str_final_price(\n    base_price: float, tax: float, discount: float, fmt_function=str\n) -> str:\n    return fmt_function(calculate_price(base_price, tax, discount))\n```", "```py\n>>> str_final_price(10, 0.2, 0.5)\n'6.0'\n\n>>> str_final_price(1000, 0.2, 0)\n'1200.0'\n\n>>> str_final_price(1000, 0.2, 0.1, fmt_function=show_price)\n'$ 1,080.00'\n```", "```py\nfrom mypoject.constants import CONNECTION_TIMEOUT\n```"]