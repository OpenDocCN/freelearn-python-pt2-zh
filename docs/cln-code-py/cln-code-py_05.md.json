["```py\ndef original(...):\n    ...\noriginal = modifier(original)\n```", "```py\n@modifier\ndef original(...):\n   ...\n```", "```py\n# decorator_function_1.py\nclass ControlledException(Exception):\n    \"\"\"A generic exception on the program's domain.\"\"\"\n\ndef retry(operation):\n    @wraps(operation)\n    def wrapped(*args, **kwargs):\n        last_raised = None\n        RETRIES_LIMIT = 3\n        for _ in range(RETRIES_LIMIT):\n            try:\n                return operation(*args, **kwargs)\n            except ControlledException as e:\n                logger.info(\"retrying %s\", operation.__qualname__)\n                last_raised = e\n        raise last_raised\n\n    return wrapped\n```", "```py\n@retry\ndef run_operation(task):\n    \"\"\"Run a particular task, simulating some failures on its execution.\"\"\"\n    return task.run()\n```", "```py\nclass LoginEventSerializer:\n    def __init__(self, event):\n        self.event = event\n\n    def serialize(self) -> dict:\n        return {\n            \"username\": self.event.username,\n            \"password\": \"**redacted**\",\n            \"ip\": self.event.ip,\n            \"timestamp\": self.event.timestamp.strftime(\"%Y-%m-%d \n             %H:%M\"),\n        }\n\nclass LoginEvent:\n    SERIALIZER = LoginEventSerializer\n\n    def __init__(self, username, password, ip, timestamp):\n        self.username = username\n        self.password = password\n        self.ip = ip\n        self.timestamp = timestamp\n\n    def serialize(self) -> dict:\n        return self.SERIALIZER(self).serialize()\n```", "```py\n\ndef hide_field(field) -> str:\n    return \"**redacted**\"\n\ndef format_time(field_timestamp: datetime) -> str:\n    return field_timestamp.strftime(\"%Y-%m-%d %H:%M\")\n\ndef show_original(event_field):\n    return event_field\n\nclass EventSerializer:\n    def __init__(self, serialization_fields: dict) -> None:\n        self.serialization_fields = serialization_fields\n\n    def serialize(self, event) -> dict:\n        return {\n            field: transformation(getattr(event, field))\n            for field, transformation in \n            self.serialization_fields.items()\n        }\n\nclass Serialization:\n\n    def __init__(self, **transformations):\n        self.serializer = EventSerializer(transformations)\n\n    def __call__(self, event_class):\n        def serialize_method(event_instance):\n            return self.serializer.serialize(event_instance)\n        event_class.serialize = serialize_method\n        return event_class\n\n@Serialization(\n    username=show_original,\n    password=hide_field,\n    ip=show_original,\n    timestamp=format_time,\n)\nclass LoginEvent:\n\n    def __init__(self, username, password, ip, timestamp):\n        self.username = username\n        self.password = password\n        self.ip = ip\n        self.timestamp = timestamp\n```", "```py\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@Serialization(\n    username=show_original,\n    password=hide_field,\n    ip=show_original,\n    timestamp=format_time,\n)\n@dataclass\nclass LoginEvent:\n    username: str\n    password: str\n    ip: str\n    timestamp: datetime\n```", "```py\n @retry(arg1, arg2,... )\n```", "```py\n  <original_function> = retry(arg1, arg2, ....)(<original_function>)\n```", "```py\nRETRIES_LIMIT = 3\n\ndef with_retry(retries_limit=RETRIES_LIMIT, allowed_exceptions=None):\n    allowed_exceptions = allowed_exceptions or (ControlledException,)\n\n    def retry(operation):\n\n        @wraps(operation)\n        def wrapped(*args, **kwargs):\n            last_raised = None\n            for _ in range(retries_limit):\n                try:\n                    return operation(*args, **kwargs)\n                except allowed_exceptions as e:\n                    logger.info(\"retrying %s due to %s\", operation, e)\n                    last_raised = e\n            raise last_raised\n\n        return wrapped\n\n    return retry\n```", "```py\n# decorator_parametrized_1.py\n@with_retry()\ndef run_operation(task):\n    return task.run()\n\n@with_retry(retries_limit=5)\ndef run_with_custom_retries_limit(task):\n    return task.run()\n\n@with_retry(allowed_exceptions=(AttributeError,))\ndef run_with_custom_exceptions(task):\n    return task.run()\n\n@with_retry(\n    retries_limit=4, allowed_exceptions=(ZeroDivisionError, AttributeError)\n)\ndef run_with_custom_parameters(task):\n    return task.run()\n```", "```py\nclass WithRetry:\n\n    def __init__(self, retries_limit=RETRIES_LIMIT, allowed_exceptions=None):\n        self.retries_limit = retries_limit\n        self.allowed_exceptions = allowed_exceptions or (ControlledException,)\n\n    def __call__(self, operation):\n\n        @wraps(operation)\n        def wrapped(*args, **kwargs):\n            last_raised = None\n\n            for _ in range(self.retries_limit):\n                try:\n                    return operation(*args, **kwargs)\n                except self.allowed_exceptions as e:\n                    logger.info(\"retrying %s due to %s\", operation, e)\n                    last_raised = e\n            raise last_raised\n\n        return wrapped\n```", "```py\n@WithRetry(retries_limit=5)\ndef run_with_custom_retries_limit(task):\n    return task.run()\n```", "```py\n# decorator_wraps_1.py\n\ndef trace_decorator(function):\n    def wrapped(*args, **kwargs):\n        logger.info(\"running %s\", function.__qualname__)\n        return function(*args, **kwargs)\n\n    return wrapped\n```", "```py\n@trace_decorator\ndef process_account(account_id):\n    \"\"\"Process an account by Id.\"\"\"\n    logger.info(\"processing account %s\", account_id)\n    ...\n```", "```py\n>>> help(process_account)\nHelp on function wrapped in module decorator_wraps_1:\n\nwrapped(*args, **kwargs) \n```", "```py\n>>> process_account.__qualname__\n'trace_decorator.<locals>.wrapped'\n```", "```py\n# decorator_wraps_2.py\ndef trace_decorator(function):\n    @wraps(function)\n    def wrapped(*args, **kwargs):\n        logger.info(\"running %s\", function.__qualname__)\n        return function(*args, **kwargs)\n\n    return wrapped\n```", "```py\n>>> Help on function process_account in module decorator_wraps_2:\n\nprocess_account(account_id)\n    Process an account by Id. \n```", "```py\n>>> process_account.__qualname__\n'process_account'\n```", "```py\ndef decorator(original_function):\n    @wraps(original_function)\n    def decorated_function(*args, **kwargs):\n        # modifications done by the decorator ...\n        return original_function(*args, **kwargs)\n\n    return decorated_function\n```", "```py\ndef traced_function_wrong(function):\n    logger.info(\"started execution of %s\", function)\n    start_time = time.time()\n\n    @functools.wraps(function)\n    def wrapped(*args, **kwargs):\n        result = function(*args, **kwargs)\n        logger.info(\n            \"function %s took %.2fs\",\n            function,\n            time.time() - start_time\n        )\n        return result\n    return wrapped\n```", "```py\n@traced_function_wrong\ndef process_with_delay(callback, delay=0):\n    time.sleep(delay)\n    return callback()\n```", "```py\n>>> from decorator_side_effects_1 import process_with_delay\nINFO:started execution of <function process_with_delay at 0x...>\n```", "```py\n>>> main()\n...\nINFO:function <function process_with_delay at 0x> took 8.67s\n\n>>> main()\n...\nINFO:function <function process_with_delay at 0x> took 13.39s\n\n>>> main()\n...\nINFO:function <function process_with_delay at 0x> took 17.01s\n```", "```py\nprocess_with_delay = traced_function_wrong(process_with_delay)\n```", "```py\ndef traced_function(function):\n    @functools.wraps(function)\n    def wrapped(*args, **kwargs):\n        logger.info(\"started execution of %s\", function.__qualname__)\n        start_time = time.time()\n        result = function(*args, **kwargs)\n        logger.info(\n            \"function %s took %.2fs\",\n            function.__qualname__,\n            time.time() - start_time\n        )\n        return result\n    return wrapped\n```", "```py\nEVENTS_REGISTRY = {}\n\ndef register_event(event_cls):\n    \"\"\"Place the class for the event into the registry to make it \n    accessible in\n    the module.\n    \"\"\"\n    EVENTS_REGISTRY[event_cls.__name__] = event_cls\n    return event_cls\n\nclass Event:\n    \"\"\"A base event object\"\"\"\n\nclass UserEvent:\n    TYPE = \"user\"\n\n@register_event\nclass UserLoginEvent(UserEvent):\n    \"\"\"Represents the event of a user when it has just accessed the system.\"\"\"\n\n@register_event\nclass UserLogoutEvent(UserEvent):\n    \"\"\"Event triggered right after a user abandoned the system.\"\"\"\n```", "```py\n>>> from decorator_side_effects_2 import EVENTS_REGISTRY\n>>> EVENTS_REGISTRY\n{'UserLoginEvent': decorator_side_effects_2.UserLoginEvent,\n 'UserLogoutEvent': decorator_side_effects_2.UserLogoutEvent}\n```", "```py\nimport logging\nfrom functools import wraps\n\nlogger = logging.getLogger(__name__)\n\nclass DBDriver:\n    def __init__(self, dbstring):\n        self.dbstring = dbstring\n\n    def execute(self, query):\n        return f\"query {query} at {self.dbstring}\"\n\ndef inject_db_driver(function):\n    \"\"\"This decorator converts the parameter by creating a ``DBDriver``\n    instance from the database dsn string.\n    \"\"\"\n    @wraps(function)\n    def wrapped(dbstring):\n        return function(DBDriver(dbstring))\n    return wrapped\n\n@inject_db_driver\ndef run_query(driver):\n    return driver.execute(\"test_function\")\n```", "```py\n>>> run_query(\"test_OK\")\n'query test_function at test_OK'\n```", "```py\nclass DataHandler:\n    @inject_db_driver\n    def run_query(self, driver):\n        return driver.execute(self.__class__.__name__)\n```", "```py\n>>> DataHandler().run_query(\"test_fails\")\nTraceback (most recent call last):\n ...\nTypeError: wrapped() takes 1 positional argument but 2 were given\n```", "```py\nfrom functools import wraps\nfrom types import MethodType\n\nclass inject_db_driver:\n    \"\"\"Convert a string to a DBDriver instance and pass this to the \n       wrapped function.\"\"\"\n\n    def __init__(self, function):\n        self.function = function\n        wraps(self.function)(self)\n\n    def __call__(self, dbstring):\n        return self.function(DBDriver(dbstring))\n\n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        return self.__class__(MethodType(self.function, instance))\n```", "```py\ndef traced_function(function):\n    @functools.wraps(function)\n    def wrapped(*args, **kwargs):\n        logger.info(\"started execution of %s\", function.__qualname__)\n        start_time = time.time()\n        result = function(*args, **kwargs)\n        logger.info(\n            \"function %s took %.2fs\",\n            function.__qualname__,\n            time.time() - start_time\n        )\n        return result\n    return wrapped\n```", "```py\ndef log_execution(function):\n    @wraps(function)\n    def wrapped(*args, **kwargs):\n        logger.info(\"started execution of %s\", function.__qualname__)\n        return function(*kwargs, **kwargs)\n    return wrapped\n\ndef measure_time(function):\n @wraps(function)\n def wrapped(*args, **kwargs):\n start_time = time.time()\n result = function(*args, **kwargs)\n\n logger.info(\"function %s took %.2f\", function.__qualname__,\n time.time() - start_time)\n return result\n return wrapped\n```", "```py\n@measure_time\n@log_execution\ndef operation():\n    ....\n```", "```py\n@app.task\ndef mytask():\n   ....\n```", "```py\n@route(\"/\", method=[\"GET\"])\ndef view_handler(request):\n ...\n```"]