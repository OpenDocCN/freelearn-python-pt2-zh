["```py\nclass MetricsClient:\n    \"\"\"3rd-party metrics client\"\"\"\n\n    def send(self, metric_name, metric_value):\n        if not isinstance(metric_name, str):\n            raise TypeError(\"expected type str for metric_name\")\n\n        if not isinstance(metric_value, str):\n            raise TypeError(\"expected type str for metric_value\")\n\n        logger.info(\"sending %s = %s\", metric_name, metric_value)\n\nclass Process:\n\n    def __init__(self):\n        self.client = MetricsClient() # A 3rd-party metrics client\n\n    def process_iterations(self, n_iterations):\n        for i in range(n_iterations):\n            result = self.run_process()\n            self.client.send(\"iteration.{}\".format(i), result)\n```", "```py\nTraceback (most recent call last):\n...\n    raise TypeError(\"expected type str for metric_value\")\nTypeError: expected type str for metric_value\n```", "```py\nclass WrappedClient:\n\n    def __init__(self):\n        self.client = MetricsClient()\n\n    def send(self, metric_name, metric_value):\n        return self.client.send(str(metric_name), str(metric_value))\n\nclass Process:\n    def __init__(self):\n        self.client = WrappedClient()\n\n    ... # rest of the code remains unchanged\n```", "```py\nimport unittest\nfrom unittest.mock import Mock\n\nclass TestWrappedClient(unittest.TestCase):\n    def test_send_converts_types(self):\n        wrapped_client = WrappedClient()\n        wrapped_client.client = Mock()\n        wrapped_client.send(\"value\", 1)\n\n        wrapped_client.client.send.assert_called_with(\"value\", \"1\")\n```", "```py\nfrom enum import Enum\n\nclass MergeRequestStatus(Enum):\n    APPROVED = \"approved\"\n    REJECTED = \"rejected\"\n    PENDING = \"pending\"\n\nclass MergeRequest:\n    def __init__(self):\n        self._context = {\n            \"upvotes\": set(),\n            \"downvotes\": set(),\n        }\n\n    @property\n    def status(self):\n        if self._context[\"downvotes\"]:\n            return MergeRequestStatus.REJECTED\n        elif len(self._context[\"upvotes\"]) >= 2:\n            return MergeRequestStatus.APPROVED\n        return MergeRequestStatus.PENDING\n\n    def upvote(self, by_user):\n        self._context[\"downvotes\"].discard(by_user)\n        self._context[\"upvotes\"].add(by_user)\n\n    def downvote(self, by_user):\n        self._context[\"upvotes\"].discard(by_user)\n        self._context[\"downvotes\"].add(by_user)\n```", "```py\nclass TestMergeRequestStatus(unittest.TestCase):\n\n    def test_simple_rejected(self):\n        merge_request = MergeRequest()\n        merge_request.downvote(\"maintainer\")\n        self.assertEqual(merge_request.status, MergeRequestStatus.REJECTED)\n\n    def test_just_created_is_pending(self):\n        self.assertEqual(MergeRequest().status, MergeRequestStatus.PENDING)\n\n    def test_pending_awaiting_review(self):\n        merge_request = MergeRequest()\n        merge_request.upvote(\"core-dev\")\n        self.assertEqual(merge_request.status, MergeRequestStatus.PENDING)\n\n    def test_approved(self):\n        merge_request = MergeRequest()\n        merge_request.upvote(\"dev1\")\n        merge_request.upvote(\"dev2\")\n\n        self.assertEqual(merge_request.status, MergeRequestStatus.APPROVED)\n```", "```py\nclass MergeRequest:\n    def __init__(self):\n        self._context = {\n            \"upvotes\": set(),\n            \"downvotes\": set(),\n        }\n        self._status = MergeRequestStatus.OPEN\n\n    def close(self):\n        self._status = MergeRequestStatus.CLOSED\n\n    ...\n    def _cannot_vote_if_closed(self):\n        if self._status == MergeRequestStatus.CLOSED:\n            raise MergeRequestException(\"can't vote on a closed merge \n            request\")\n\n    def upvote(self, by_user):\n        self._cannot_vote_if_closed()\n\n        self._context[\"downvotes\"].discard(by_user)\n        self._context[\"upvotes\"].add(by_user)\n\n    def downvote(self, by_user):\n        self._cannot_vote_if_closed()\n\n        self._context[\"upvotes\"].discard(by_user)\n        self._context[\"downvotes\"].add(by_user)\n```", "```py\n    def test_cannot_upvote_on_closed_merge_request(self):\n        self.merge_request.close()\n        self.assertRaises(\n            MergeRequestException, self.merge_request.upvote, \"dev1\"\n        )\n\n    def test_cannot_downvote_on_closed_merge_request(self):\n        self.merge_request.close()\n        self.assertRaisesRegex(\n            MergeRequestException,\n            \"can't vote on a closed merge request\",\n            self.merge_request.downvote,\n            \"dev1\",\n        )\n```", "```py\nclass AcceptanceThreshold:\n    def __init__(self, merge_request_context: dict) -> None:\n        self._context = merge_request_context\n\n    def status(self):\n        if self._context[\"downvotes\"]:\n            return MergeRequestStatus.REJECTED\n        elif len(self._context[\"upvotes\"]) >= 2:\n            return MergeRequestStatus.APPROVED\n        return MergeRequestStatus.PENDING\n\nclass MergeRequest:\n    ...\n    @property\n    def status(self):\n        if self._status == MergeRequestStatus.CLOSED:\n            return self._status\n\n        return AcceptanceThreshold(self._context).status()\n```", "```py\nclass TestAcceptanceThreshold(unittest.TestCase):\n    def setUp(self):\n        self.fixture_data = (\n            (\n                {\"downvotes\": set(), \"upvotes\": set()},\n                MergeRequestStatus.PENDING\n            ),\n            (\n                {\"downvotes\": set(), \"upvotes\": {\"dev1\"}},\n                MergeRequestStatus.PENDING,\n            ),\n            (\n                {\"downvotes\": \"dev1\", \"upvotes\": set()},\n                MergeRequestStatus.REJECTED\n            ),\n            (\n                {\"downvotes\": set(), \"upvotes\": {\"dev1\", \"dev2\"}},\n                MergeRequestStatus.APPROVED\n            ),\n        )\n\n    def test_status_resolution(self):\n        for context, expected in self.fixture_data:\n            with self.subTest(context=context):\n                status = AcceptanceThreshold(context).status()\n                self.assertEqual(status, expected)\n```", "```py\nFAIL: (context={'downvotes': set(), 'upvotes': {'dev1', 'dev2'}})\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"\" test_status_resolution\n    self.assertEqual(status, expected)\nAssertionError: <MergeRequestStatus.APPROVED: 'approved'> != <MergeRequestStatus.REJECTED: 'rejected'>\n```", "```py\ndef test_simple_rejected():\n    merge_request = MergeRequest()\n    merge_request.downvote(\"maintainer\")\n    assert merge_request.status == MergeRequestStatus.REJECTED\n\ndef test_just_created_is_pending():\n    assert MergeRequest().status == MergeRequestStatus.PENDING\n\ndef test_pending_awaiting_review():\n    merge_request = MergeRequest()\n    merge_request.upvote(\"core-dev\")\n    assert merge_request.status == MergeRequestStatus.PENDING\n```", "```py\ndef test_invalid_types():\n    merge_request = MergeRequest()\n    pytest.raises(TypeError, merge_request.upvote, {\"invalid-object\"})\n\ndef test_cannot_vote_on_closed_merge_request():\n    merge_request = MergeRequest()\n    merge_request.close()\n    pytest.raises(MergeRequestException, merge_request.upvote, \"dev1\")\n    with pytest.raises(\n        MergeRequestException,\n        match=\"can't vote on a closed merge request\",\n    ):\n        merge_request.downvote(\"dev1\")\n```", "```py\n@pytest.mark.parametrize(\"context,expected_status\", (\n    (\n        {\"downvotes\": set(), \"upvotes\": set()},\n        MergeRequestStatus.PENDING\n    ),\n    (\n        {\"downvotes\": set(), \"upvotes\": {\"dev1\"}},\n        MergeRequestStatus.PENDING,\n    ),\n    (\n        {\"downvotes\": \"dev1\", \"upvotes\": set()},\n        MergeRequestStatus.REJECTED\n    ),\n    (\n        {\"downvotes\": set(), \"upvotes\": {\"dev1\", \"dev2\"}},\n        MergeRequestStatus.APPROVED\n    ),\n))\ndef test_acceptance_threshold_status_resolution(context, expected_status):\n    assert AcceptanceThreshold(context).status() == expected_status\n```", "```py\n@pytest.fixture\ndef rejected_mr():\n    merge_request = MergeRequest()\n\n    merge_request.downvote(\"dev1\")\n    merge_request.upvote(\"dev2\")\n    merge_request.upvote(\"dev3\")\n    merge_request.downvote(\"dev4\")\n\n    return merge_request\n\ndef test_simple_rejected(rejected_mr):\n    assert rejected_mr.status == MergeRequestStatus.REJECTED\n\ndef test_rejected_with_approvals(rejected_mr):\n    rejected_mr.upvote(\"dev2\")\n    rejected_mr.upvote(\"dev3\")\n    assert rejected_mr.status == MergeRequestStatus.REJECTED\n\ndef test_rejected_to_pending(rejected_mr):\n    rejected_mr.upvote(\"dev1\")\n    assert rejected_mr.status == MergeRequestStatus.PENDING\n\ndef test_rejected_to_approved(rejected_mr):\n    rejected_mr.upvote(\"dev1\")\n    rejected_mr.upvote(\"dev2\")\n    assert rejected_mr.status == MergeRequestStatus.APPROVED\n```", "```py\npytest \\\n    --cov-report term-missing \\\n    --cov=coverage_1 \\\n    test_coverage_1.py\n```", "```py\ntest_coverage_1.py ................ [100%]\n\n----------- coverage: platform linux, python 3.6.5-final-0 -----------\nName         Stmts Miss Cover Missing\n---------------------------------------------\ncoverage_1.py 38      1  97%    53\n```", "```py\nclass GitBranch:\n    def __init__(self, commits: List[Dict]):\n        self._commits = {c[\"id\"]: c for c in commits}\n\n    def __getitem__(self, commit_id):\n        return self._commits[commit_id]\n\n    def __len__(self):\n        return len(self._commits)\n\ndef author_by_id(commit_id, branch):\n    return branch[commit_id][\"author\"]\n```", "```py\ndef test_find_commit():\n    branch = GitBranch([{\"id\": \"123\", \"author\": \"dev1\"}])\n    assert author_by_id(\"123\", branch) == \"dev1\"\n\ndef test_find_any():\n    author = author_by_id(\"123\", Mock()) is not None\n    # ... rest of the tests..\n```", "```py\ndef author_by_id(commit_id, branch):\n    > return branch[commit_id][\"author\"]\n    E TypeError: 'Mock' object is not subscriptable\n```", "```py\ndef test_find_any():\n    mbranch = MagicMock()\n    mbranch.__getitem__.return_value = {\"author\": \"test\"}\n    assert author_by_id(\"123\", mbranch) == \"test\"\n```", "```py\n# mock_2.py\n\nfrom datetime import datetime\n\nimport requests\nfrom constants import STATUS_ENDPOINT\n\nclass BuildStatus:\n    \"\"\"The CI status of a pull request.\"\"\"\n\n    @staticmethod\n    def build_date() -> str:\n        return datetime.utcnow().isoformat()\n\n    @classmethod\n    def notify(cls, merge_request_id, status):\n        build_status = {\n            \"id\": merge_request_id,\n            \"status\": status,\n            \"built_at\": cls.build_date(),\n        }\n        response = requests.post(STATUS_ENDPOINT, json=build_status)\n        response.raise_for_status()\n        return response\n\n```", "```py\n# test_mock_2.py\n\nfrom unittest import mock\n\nfrom constants import STATUS_ENDPOINT\nfrom mock_2 import BuildStatus\n\n@mock.patch(\"mock_2.requests\")\ndef test_build_notification_sent(mock_requests):\n    build_date = \"2018-01-01T00:00:01\"\n    with mock.patch(\"mock_2.BuildStatus.build_date\", \n    return_value=build_date):\n        BuildStatus.notify(123, \"OK\")\n\n    expected_payload = {\"id\": 123, \"status\": \"OK\", \"built_at\": \n    build_date}\n    mock_requests.post.assert_called_with(\n        STATUS_ENDPOINT, json=expected_payload\n    )\n```", "```py\nfrom datetime import datetime\n\nfrom constants import STATUS_ENDPOINT\n\nclass BuildStatus:\n\n    endpoint = STATUS_ENDPOINT\n\n    def __init__(self, transport):\n        self.transport = transport\n\n    @staticmethod\n    def build_date() -> str:\n        return datetime.utcnow().isoformat()\n\n    def compose_payload(self, merge_request_id, status) -> dict:\n        return {\n            \"id\": merge_request_id,\n            \"status\": status,\n            \"built_at\": self.build_date(),\n        }\n\n    def deliver(self, payload):\n        response = self.transport.post(self.endpoint, json=payload)\n        response.raise_for_status()\n        return response\n\n    def notify(self, merge_request_id, status):\n        return self.deliver(self.compose_payload(merge_request_id, status))\n```", "```py\n@pytest.fixture\ndef build_status():\n    bstatus = BuildStatus(Mock())\n    bstatus.build_date = Mock(return_value=\"2018-01-01T00:00:01\")\n    return bstatus\n\ndef test_build_notification_sent(build_status):\n\n    build_status.notify(1234, \"OK\")\n\n    expected_payload = {\n        \"id\": 1234,\n        \"status\": \"OK\",\n        \"built_at\": build_status.build_date(),\n    }\n\n```", "```py\n    build_status.transport.post.assert_called_with(\n        build_status.endpoint, json=expected_payload\n    )\n```", "```py\nclass TestMergeRequestStatus(unittest.TestCase):\n    def setUp(self):\n        self.merge_request = MergeRequest()\n\n    def assert_rejected(self):\n        self.assertEqual(\n            self.merge_request.status, MergeRequestStatus.REJECTED\n        )\n\n    def assert_pending(self):\n        self.assertEqual(\n            self.merge_request.status, MergeRequestStatus.PENDING\n        )\n\n    def assert_approved(self):\n        self.assertEqual(\n            self.merge_request.status, MergeRequestStatus.APPROVED\n        )\n\n    def test_simple_rejected(self):\n        self.merge_request.downvote(\"maintainer\")\n        self.assert_rejected()\n\n    def test_just_created_is_pending(self):\n        self.assert_pending()\n```", "```py\n# File mutation_testing_1.py\nfrom mrstatus import MergeRequestStatus as Status\n\ndef evaluate_merge_request(upvote_count, downvotes_count):\n    if downvotes_count > 0:\n        return Status.REJECTED\n    if upvote_count >= 2:\n        return Status.APPROVED\n    return Status.PENDING\n```", "```py\n# file: test_mutation_testing_1.py\nclass TestMergeRequestEvaluation(unittest.TestCase):\n    def test_approved(self):\n        result = evaluate_merge_request(3, 0)\n        self.assertEqual(result, Status.APPROVED)\n```", "```py\n$ mut.py \\\n    --target mutation_testing_$N \\\n    --unit-test test_mutation_testing_$N \\\n    --operator AOD `# delete arithmetic operator` \\\n    --operator AOR `# replace arithmetic operator` \\\n    --operator COD `# delete conditional operator` \\\n    --operator COI `# insert conditional operator` \\\n    --operator CRP `# replace constant` \\\n    --operator ROR `# replace relational operator` \\\n    --show-mutants\n```", "```py\n[*] Mutation score [0.04649 s]: 100.0%\n - all: 4\n - killed: 4 (100.0%)\n - survived: 0 (0.0%)\n - incompetent: 0 (0.0%)\n - timeout: 0 (0.0%)\n```", "```py\n - [# 1] ROR mutation_testing_1:11 : \n------------------------------------------------------\n 7: from mrstatus import MergeRequestStatus as Status\n 8: \n 9: \n 10: def evaluate_merge_request(upvote_count, downvotes_count):\n~11:     if downvotes_count < 0:\n 12:         return Status.REJECTED\n 13:     if upvote_count >= 2:\n 14:         return Status.APPROVED\n 15:     return Status.PENDING\n------------------------------------------------------\n[0.00401 s] killed by test_approved (test_mutation_testing_1.TestMergeRequestEvaluation)\n```"]