["```py\n$ cd chapter08               # Change into this chapter's folder\n$ python3 -m venv venv       # Create Python Virtual Environment\n$ source venv/bin/activate   # Activate Python Virtual Environment\n(venv) $ pip install pip --upgrade        # Upgrade pip\n(venv) $ pip install -r requirements.txt  # Install dependent packages\n```", "```py\nfrom time import sleep\nimport pigpio\nfrom PIL.ImageColor import getrgb    # (1)\n\nGPIO_RED = 16\nGPIO_GREEN = 20\nGPIO_BLUE = 21\n\npi.set_PWM_range(GPIO_RED, 255)      # (2)\npi.set_PWM_frequency(GPIO_RED, 8000)\n# ... truncated ... \n```", "```py\ndef set_color(color):                                 # (3)   rgb = getrgb(color)                               \n  print(\"LED is {} ({})\".format(color, rgb))\n    pi.set_PWM_dutycycle(GPIO_RED,   rgb[0])          # (4)\n  pi.set_PWM_dutycycle(GPIO_GREEN, rgb[1])\n    pi.set_PWM_dutycycle(GPIO_BLUE,  rgb[2])\n```", "```py\ndef color_cycle(colors=(\"red\", \"green\", \"blue\"), delay_secs=1):   # (6)\n    # ...truncated...\n\ndef rainbow_example(loops=1, delay_secs=0.01):                    # (7)\n    # ...truncated...\n```", "```py\nNUM_LEDS = 60     # (2)\n```", "```py\n# ...truncated...\nfrom collections import deque                                   # (1) from PIL.ImageColor import getrgb\nfrom luma.core.render import canvas\nfrom luma.led_matrix.device import apa102\nfrom luma.core.interface.serial import spi, bitbang\n```", "```py\n# ...truncated...\ncolor_buffer = deque(['black']*NUM_LEDS, maxlen=NUM_LEDS)      # (3) \n```", "```py\n# ...truncated... serial = spi(port=0, device=0, bus_speed_hz=2000000)           # (4)  \n```", "```py\n# ...truncated... # serial = bitbang(SCLK=13, SDA=6)                             # (5)  # ...truncated... device = apa102(serial_interface=serial, cascaded=NUM_LEDS)    # (6)\n```", "```py\ndevice.clear()                                                   # (7) contrast_level = 128 # 0 (off) to 255 (maximum brightness) device.contrast(contrast_level)\n```", "```py\ndef set_color(color='black', index=-1):                          # (8)\n  if index == -1:\n        global color_buffer\n        color_buffer = deque([color]*NUM_LEDS, maxlen=NUM_LEDS)\n    else:\n        color_buffer[index] = color\n```", "```py\ndef update():                                                   # (12)\n  with canvas(device) as draw:\n        for led_pos in range(0, len(color_buffer)):\n            color = color_buffer[led_pos]\n\n            ## If your LED strip's colors are are not in the expected\n ## order, uncomment the following lines and adjust the indexes ## in the line color = (rgb[0], rgb[1], rgb[2]) # rgb = getrgb(color) # color = (rgb[0], rgb[1], rgb[2]) # if len(rgb) == 4: #     color += (rgb[3],)  # Add in Alpha    draw.point((led_pos, 0), fill=color)\n```", "```py\ndef push_color(color):                                       # (9)   color_buffer.appendleft(color)\n\ndef set_pattern(colors=('green', 'blue', 'red')):           # (10)     range(0, int(ceil(float(NUM_LEDS)/float(len(colors))))):\n        for color in colors:\n            push_color(color)\n\ndef rotate_colors(count=1):                                 # (11)\n    color_buffer.rotate(count)\n```", "```py\n$ i2cdetect -y 1\n```", "```py\n# ...truncated...\n30: -- -- -- -- -- -- -- -- -- -- -- -- 3c -- -- -- \n# ...truncated...\n```", "```py\nserial = i2c(port=1, address=0x3C)\n```", "```py\nfrom PIL import Image, ImageDraw, ImageFont         # (1)\nfrom luma.core.interface.serial import i2c, spi\nfrom luma.core.render import canvas\nfrom luma.oled.device import ssd1306  #...truncated...\n\n# OLED display is using I2C at address 0x3C serial = i2c(port=1, address=0x3C)                  # (2)\n#serial = spi(port=0, device=0)\n  device = ssd1306(serial)                            # (3)\ndevice.clear()\nprint(\"Screen Dimensions (WxH):\", device.size)\n\n```", "```py\ndef get_cpu_temp():     # (4)   temp = os.popen(\"vcgencmd measure_temp\").readline() # Eg 62.5'C\n  data = temp.strip().upper().replace(\"TEMP=\", \"\").split(\"'\")\n    data[0] = float(data[0])\n\n    if data[1] == 'F':  # To Celsius just in case it ever returns Fahrenheit\n  data[0] = (data[0] - 32) * 5/9\n  data[1] = 'C'    return (data[0], data[1])  # Eg (62.5, 'C') \n```", "```py\n# Temperature thresholds used to switch thermometer icons  temp_low_threshold = 60 # degrees Celsius                     # (5) temp_high_threshold = 85 # degrees Celsius   # Thermometer icons image_high = Image.open(\"temp_high.png\")                        # (6)\nimage_med  = Image.open(\"temp_med.png\")\nimage_low  = Image.open(\"temp_low.png\")\n\n# Scale thermometer icons (WxH) aspect_ratio = image_low.size[0] / image_low.size[1]            # (7)\nheight = 50 width = int(height * aspect_ratio)\nimage_high = image_high.resize((width, height))\nimage_med  = image_med.resize((width, height))\nimage_low  = image_low.resize((width, height))\n```", "```py\nrefresh_secs = 0.5  # Display refresh rate                           #(8) high_alert = False # Used for screen blinking when high temperature   try:\n    while True:\n        current_temp = get_cpu_temp()\n        temp_image = None    canvas = Image.new(\"RGB\", device.size, \"black\")              # (9)\n        draw = ImageDraw.Draw(canvas)                                # (10)\n        draw.rectangle(((0,0), \n                   (device.size[0]-1, device.size[1]-1)), \n                   outline=\"white\")\n```", "```py\n  if high_alert:                                     # (11)\n            device.display(canvas.convert(device.mode))\n            high_alert = False   sleep(refresh_secs)\n            continue \n```", "```py\n if current_temp[0] < temp_low_threshold:           # (12)\n            temp_image = image_low\n            high_alert = False     elif current_temp[0] > temp_high_threshold:\n            temp_image = image_high\n            high_alert = True     else:\n            temp_image = image_med\n            high_alert = False  \n```", "```py\n# Temperature Icon image_x_offset = -40                    # (13) image_y_offset = +7 image_xy = (((device.width - temp_image.size[0]) // 2) + \n        image_x_offset, ((device.height - temp_image.size[1]) // 2) \n        + image_y_offset)\ncanvas.paste(temp_image, image_xy)      # (14)\n```", "```py\n# Temperature Text (\\u00b0 is a 'degree' symbol)                 # (15) text = \"{}\\u00b0{}\".format(current_temp[0], current_temp[1]) # Eg 43'C   font = None # Use a default font.                                # (16)\n# font = ImageFont.truetype(font=\"Lato-Semibold.ttf\", size=20) \n\ntext_size = draw.textsize(text, font=font)                       # (17)\ntext_x_offset = +15 text_y_offset = 0 text_xy = (((device.width - text_size[0]) // 2) + text_x_offset, \n((device.height -  text_size[1]) // 2) + text_y_offset)\ndraw.text(text_xy, text, fill=\"white\", font=font)                # (18)\n```", "```py\n# Render display with canvas device.display(canvas.convert(device.mode))        # (19)\nsleep(refresh_secs)\n```", "```py\nfrom rtttl import parse_rtttl\nrtttl_score = parse_rtttl(\"Scale:d=4,o=4,b=125:8a,8b,        # (1)\n    8c#,8d,8e,8f#,8g#,8f#,8e,8d,8c#,8b,8a\")\n```", "```py\n    for note in rtttl_score['notes']:                        # (2)\n        frequency = int(note['frequency'])   duration = note['duration'] # Milliseconds\n        pi.hardware_PWM(BUZZER_GPIO, frequency, duty_cycle)  # (3)\n        sleep(duration/1000)                                 # (4)\n```"]