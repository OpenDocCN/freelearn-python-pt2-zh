["```py\n$ cd chapter11              # Change into this chapter's folder\n$ python3 -m venv venv      # Create Python Virtual Environment\n$ source venv/bin/activate  # Activate Python Virtual Environment\n(venv) $ pip install pip --upgrade        # Upgrade pip\n(venv) $ pip install -r requirements.txt  # Install dependent packages\n```", "```py\n(venv) $ python hc-sr501.py \n\nPLEASE NOTE - The HC-SR501 Needs 1 minute after power on to initialize itself.\n\nMonitoring environment...\nPress Control + C to Exit\nTriggered.\nNot Triggered.\n... truncated ...\n```", "```py\n# ... truncated ...\nGPIO = 21\n\n# Initialize GPIO\npi.set_mode(GPIO, pigpio.INPUT)                               # (1)\npi.set_pull_up_down(GPIO, pigpio.PUD_DOWN)\npi.set_glitch_filter(GPIO, 10000) # microseconds debounce     # (2)\n```", "```py\ndef callback_handler(gpio, level, tick):                       # (3)\n    \"\"\" Called whenever a level change occurs on GPIO Pin.\n      Parameters defined by PiGPIO pi.callback() \"\"\"\n    global triggered\n\n    if level == pigpio.HIGH:\n        triggered = True\n        print(\"Triggered\")\n    elif level == pigpio.LOW:\n        triggered = False\n        print(\"Not Triggered\")\n```", "```py\n# Register Callback\ncallback = pi.callback(GPIO, pigpio.EITHER_EDGE, callback_handler) # (4)\n```", "```py\n(venv) python hc-sr04.py\nPress Control + C to Exit\n9.6898cm, 3.8149\"\n9.7755cm, 3.8486\"\n10.3342cm, 4.0686\"\n11.5532cm, 4.5485\"\n12.3422cm, 4.8591\"\n...\n```", "```py\nTRIG_GPIO = 20                                       # (1)\nECHO_GPIO = 21\n\n# Speed of Sound in meters per second\n# at 20 degrees C (68 degrees F)\nVELOCITY = 343                                       # (2)\n\n# Sensor timeout and return value\nTIMEOUT_SECS = 0.1 # based on max distance of 4m     # (3)\nSENSOR_TIMEOUT  = -1\n```", "```py\n# For timing our ultrasonic pulse\necho_callback = None                             # (4)\ntick_start = -1\ntick_end = -1\nreading_success = False\n```", "```py\ndef trigger():                                   # (5)\n    global reading_success\n    reading_success = False\n\n    # Start ultrasonic pulses\n    pi.write(TRIG_GPIO, pigpio.HIGH)             # (6)\n    sleep(1 / 1000000) # Pause 10 microseconds\n    pi.write(TRIG_GPIO, pigpio.LOW)\n```", "```py\ndef get_distance_cms()                           # (7)\n    trigger()\n\n    timeout = time() + TIMEOUT_SECS              # (8)\n    while not reading_success:\n      if time() > timeout:\n          return SENSOR_TIMEOUT\n      sleep(0.01)\n```", "```py\n# ... get_distance_cms() continued\n\n    # Elapsed time in microseconds.\n    #Divide by 2 to get time from sensor to object.\n    elapsed_microseconds = \n                pigpio.tickDiff(tick_start, tick_end) / 2   # (9)\n\n    # Convert to seconds\n    elapsed_seconds = elapsed_microseconds / 1000000\n\n    # Calculate distance in meters (d = v * t)\n    distance_in_meters = elapsed_seconds * VELOCITY         # (10)\n\n    distance_in_centimeters = distance_in_meters * 100\n    return distance_in_centimeters\n```", "```py\ndef echo_handler(gpio, level, tick):            # (11)\n    global tick_start, tick_end, reading_success\n\n    if level == pigpio.HIGH:\n        tick_start = tick                       # (12)\n    elif level == pigpio.LOW:\n        tick_end = tick                         # (13)\n        reading_success = True\n```", "```py\necho_callback = \n    pi.callback(ECHO_GPIO, pigpio.EITHER_EDGE, echo_handler) # (14)\n```"]