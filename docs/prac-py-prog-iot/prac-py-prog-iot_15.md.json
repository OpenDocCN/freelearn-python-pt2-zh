["```py\n$ cd chapter12              # Change into this chapter's folder\n$ python3 -m venv venv      # Create Python Virtual Environment\n$ source venv/bin/activate  # Activate Python Virtual Environment\n(venv) $ pip install pip --upgrade        # Upgrade pip\n(venv) $ pip install -r requirements.txt  # Install dependent packages\n```", "```py\n(venv) $ cd version1_eventloop\n(venv) $ python main.py\nINFO:Main:Version 1 - Event Loop Example. Press Control + C To Exit.\nINFO:Main:Setting rate for all LEDs to 2.5\nINFO:Main:Turning the Potentiometer dial will change the rate for LED #0\nINFO:Main:Changing LED #0 rate to 2.6\nINFO:Main:Changing LED #0 rate to 2.7 \nINFO:Main:Turning the Potentiometer dial will change the rate for LED #1\nINFO:Main:Changing LED #1 rate to 2.6\nINFO:Main:Changing LED #1 rate to 2.5\n# Truncated\nINFO:Main:Changing LED #1 rate to 0.5\nINFO:Main:Changing rate for all LEDs to 0.5\n```", "```py\n# chapter12/version1_eventloop\n#\n# Setup and initialization code goes before while loop.\n#\n\nif __name__ == \"__main__\":\n    # Start of \"Event Loop\"\n    while True:                                # (1)\n      #\n      # ... Main body of logic and code is within the while loop...\n      #\n      sleep(SLEEP_DELAY)\n```", "```py\n    #\n    # Blink the LEDs.\n    #\n    now = time()                                               # (3)\n    for i in range(len(LED_GPIOS)):\n        if led_rates[i] <= 0:\n            pi.write(LED_GPIOS[i], pigpio.LOW) # LED Off.\n        elif now >= led_toggle_at_time[i]:\n            pi.write(LED_GPIOS[i], not pi.read(LED_GPIOS[i])) # Toggle LED\n            led_toggle_at_time[i] = now + led_rates[i]\n```", "```py\n   while True:\n      pi.write(led_gpio, not pi.read(led_gpio)) # Toggle LED GPIO High/Low\n      sleep(delay)\n```", "```py\nwhile True:\n    button_pressed = pi.read(BUTTON_GPIO) == pigpio.LOW        # (2)\n\n    if button_pressed and not button_held:\n        # Button has been pressed.\n        # ... Truncated ...\n    elif not button_pressed:\n        if was_pressed and not button_held:\n            # Button has been released\n            # ... Truncated ...\n    if button_hold_timer >= BUTTON_HOLD_SECS and not button_held:\n        # Button has been held down\n        # ... Truncated ...\n\n    # ... Truncated ...\n```", "```py\n# chapter12/version2_threads/main.py\nif __name__ == \"__main__\":                                       # (3)\n        # Initialize all LEDs\n        # ... Truncated ...\n\n        # No While loop!\n        # It's our BUTTON, LED and POT classes and the \n        # registered callbacks doing all the work.\n        pause()\n```", "```py\n# chapter12/version2_threads/main.py\n# Callback Handler when button is pressed, released or held down.\ndef button_handler(the_button, state):\n    global led_index\n    if state == BUTTON.PRESSED:                                 # (1)\n        #... Truncated ...\n    elif state == BUTTON.HOLD:                                  # (2)\n        #... Truncated \n\n# Creating button Instance\nbutton = BUTTON(gpio=BUTTON_GPIO,\n               pi=pi,\n               callback=button_handler)\n```", "```py\n# chapter12/version2_threads/BUTTON.py\ndef _callback_handler(self, gpio, level, tick): # PiGPIO Callback  # (1)\n\n     if level == pigpio.LOW: # level is LOW -> Button is pressed\n         if self.callback: self.callback(self, BUTTON.PRESSED)\n\n         # While button is pressed start a timer to detect\n         # if it remains pressed for self.hold_secs\n         timer = 0                                                 # (2)\n         while (timer < self.hold_secs) and not self.pi.read(self.gpio):\n             sleep(0.01)\n             timer += 0.01\n\n         # Button is still pressed after self.hold_secs\n         if not self.pi.read(self.gpio):                \n             if self.callback: self.callback(self, BUTTON.HOLD)\n\n     else: # level is HIGH -> Button released            \n         if self.callback: self.callback(self, BUTTON.RELEASED)\n```", "```py\n    # chapter12/version2_threads/POT.py\n    def run(self):   \n        while self.is_polling:                              # (1)\n            current_value = self.get_value()  \n            if self.last_value != current_value:            # (2)\n                if self.callback:\n                    self.callback(self, current_value)      # (3)\n                self.last_value = current_value\n\n            timer = 0  \n            while timer < self.poll_secs:  # Sleep for a while\n                sleep(0.01)\n                timer += 0.01\n\n        # self.is_polling has become False and the Thread ends.\n        self.__thread = None\n```", "```py\n# chapter12/version2_threads/LED.py\n def run(self):                                                    # (3)\n     \"\"\" Do the blinking (this is the run() method for our Thread) \"\"\"\n     while self.is_blinking:\n         # Toggle LED On/Off\n         self.pi.write(self.gpio, not self.pi.read(self.gpio))\n\n         # Works, but LED responsiveness to rate chances can be sluggish.\n         # sleep(self.blink_rate_secs)\n\n         # Better approach - LED responds to changes in near real-time.\n         timer = 0\n         while timer < self.blink_rate_secs:\n             sleep(0.01)\n             timer += 0.01\n\n     # self.is_blinking has become False and the Thread ends.\n     self._thread = None\n```", "```py\n    # chapter12/version2_threads/LED.py\n    @classmethod                                           # (1)\n    def set_rate_all(cls, rate):\n        for led in cls.instances: # Turn off all LEDs.\n            led.set_rate(0)\n\n        for led in cls.instances:                        \n            if led._thread:\n                led._thread.join()                         # (2)\n\n        # We do not get to this point in code until all \n        # LED Threads are complete (and LEDS are all off)\n\n        for led in cls.instances:  # Start LED's blinking\n            led.set_rate(rate)\n```", "```py\nif __name__ == \"__main__\":\n       # .... truncated ....\n\n        # Get (create) an event loop.\n        loop = asyncio.get_event_loop()      # (1)\n\n        # Register the LEDs.\n        for led in LEDS:\n            loop.create_task(led.run())      # (2)\n\n        # Register Button and Pot\n        loop.create_task(pot.run())          # (3)\n        loop.create_task(button.run())       # (4)\n\n        # Start the event loop.\n        loop.run_forever()                   # (5)\n```", "```py\n# version4_asyncio/LED.py\nasync def run(self):\n    \"\"\" Do the blinking \"\"\"\n    while True:                                           # (1)\n        if self.toggle_at > 0 and \n              (time() >= self.toggle_at):                 # (2)\n            self.pi.write(self.gpio, not self.pi.read(self.gpio))\n            self.toggle_at += self.blink_rate_secs\n\n        await asyncio.sleep(0)                            # (3)\n```", "```py\nasync def run(self):\n    \"\"\" Poll ADC for Voltage Changes \"\"\"\n    while True:\n        # Check if the Potentiometer has been adjusted.\n        current_value = self.get_value()\n        if self.last_value != current_value:\n\n            if self.callback:\n                self.callback(self, current_value)\n\n            self.last_value = current_value\n\n        await asyncio.sleep(0)\n```", "```py\nasync def run(self):\n    while True:\n        level = self.pi.read(self.gpio) # LOW(0) or HIGH(1)\n\n        # Waiting for a GPIO level change.\n        while level == self.__last_level:\n            await asyncio.sleep(0)\n\n            # ... truncated ...\n\n            while (time() < hold_timeout_at) and \\\n                   not self.pi.read(self.gpio):\n                await asyncio.sleep(0)\n\n        # ... truncated ...\n        await asyncio.sleep(0)\n```"]