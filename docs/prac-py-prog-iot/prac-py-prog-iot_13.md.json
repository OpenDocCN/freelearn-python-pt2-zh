["```py\n$ cd chapter10              # Change into this chapter's folder\n$ python3 -m venv venv      # Create Python Virtual Environment\n$ source venv/bin/activate  # Activate Python Virtual Environment\n(venv) $ pip install pip --upgrade        # Upgrade pip\n(venv) $ pip install -r requirements.txt  # Install dependent packages\n```", "```py\nLEFT_PULSE  = 1000   # Nano seconds          # (1)\nRIGHT_PULSE = 2000\nCENTER_PULSE = ((LEFT_PULSE - RIGHT_PULSE) // 2) + RIGHT_PULSE  # Eg 1500\n```", "```py\n  # Delay to give servo time to move\n  MOVEMENT_DELAY_SECS = 0.5            # (2)\n```", "```py\n def left():                                               # (3)\n       pi.set_servo_pulsewidth(SERVO_GPIO, LEFT_PULSE)\n\n def center():\n       pi.set_servo_pulsewidth(SERVO_GPIO, CENTER_PULSE)\n\n def right():\n       pi.set_servo_pulsewidth(SERVO_GPIO, RIGHT_PULSE)\n```", "```py\n   def idle():                                      # (4)\n      pi.set_servo_pulsewidth(SERVO_GPIO, 0)\n```", "```py\n  def angle(to_angle):                                   # (5)\n      # Restrict to -90..+90 degrees\n      to_angle = int(min(max(to_angle, -90), 90))\n\n      ratio = (to_angle + 90) / 180.0                    # (6)\n      pulse_range = LEFT_PULSE - RIGHT_PULSE\n      pulse = LEFT_PULSE - round(ratio * pulse_range)    # (7)\n\n      pi.set_servo_pulsewidth(SERVO_GPIO, pulse)\n```", "```py\n def sweep(count=4):                        # (10)\n      for i in range(count):\n          right()\n          sleep(MOVEMENT_DELAY_SECS)\n          left()\n          sleep(MOVEMENT_DELAY_SECS)\n```", "```py\nimport pigpio                    # (1)\nfrom time import sleep\nfrom motor_class import Motor\n\n# Motor A\nCHANNEL_1_ENABLE_GPIO = 18       # (2)\nINPUT_1Y_GPIO = 23 \nINPUT_2Y_GPIO = 24\n\n# Motor B\nCHANNEL_2_ENABLE_GPIO = 16       # (3)\nINPUT_3Y_GPIO = 20\nINPUT_4Y_GPIO = 21\n```", "```py\npi = pigpio.pi()                 # (4)\nmotor_A = Motor(pi, CHANNEL_1_ENABLE_GPIO, INPUT_1Y_GPIO, INPUT_2Y_GPIO)\nmotor_B = Motor(pi, CHANNEL_2_ENABLE_GPIO, INPUT_3Y_GPIO, INPUT_4Y_GPIO)\n```", "```py\n print(\"Motor A and B Speed 50, Right\") \n motor_A.set_speed(50)                                # (5)\n motor_A.right()\n motor_B.set_speed(50)\n motor_B.right() \n sleep(2)\n\n #... truncated ... \n\n print(\"Motor A Classic Brake, Motor B PWM Brake\")\n motor_A.brake()                                      # (6) \n motor_B.brake_pwm(brake_speed=100, delay_millisecs=50)\n sleep(2)\n```", "```py\nclass Motor:\n\n  def __init__(self, pi, enable_gpio, logic_1_gpio, logic_2_gpio):\n\n    self.pi = pi\n    self.enable_gpio = enable_gpio\n    self.logic_1_gpio = logic_1_gpio\n    self.logic_2_gpio = logic_2_gpio\n\n    pi.set_PWM_range(self.enable_gpio, 100) # speed is 0..100       # (1)\n\n    # Set default state - motor not spinning and \n    # set for right direction.\n    self.set_speed(0) # Motor off                                   # (2)\n    self.right()\n```", "```py\n def right(self, speed=None):           # (3)\n     if speed is not None:\n         self.set_speed(speed)\n\n     self.pi.write(self.logic_1_gpio, pigpio.LOW)\n     self.pi.write(self.logic_2_gpio, pigpio.HIGH)\n\n def left(self, speed=None):           # (4)\n     if speed is not None:\n         self.set_speed(speed)\n\n     self.pi.write(self.logic_1_gpio, pigpio.HIGH)\n     self.pi.write(self.logic_2_gpio, pigpio.LOW)\n```", "```py\n   def is_right(self):                              # (5)\n       return not self.pi.read(self.logic_1_gpio)   # LOW \n              and self.pi.read(self.logic_2_gpio)   # HIGH\n```", "```py\n    def set_speed(self, speed):                      # (6)\n        assert 0<=speed<=100\n        self.pi.set_PWM_dutycycle(self.enable_gpio, speed)\n```", "```py\n    def brake(self):                # (7)\n        was_right = self.is_right() # To restore direction after braking\n\n        self.set_speed(100)\n        self.pi.write(self.logic_1_gpio, pigpio.LOW)\n        self.pi.write(self.logic_2_gpio, pigpio.LOW)\n        self.set_speed(0)\n\n        if was_right:\n            self.right()\n        else:\n            self.left()\n```", "```py\n    def brake_pwm(self, brake_speed=100, delay_millisecs=50):    # (8)\n        was_right = None # To restore direction after braking\n        if self.is_right(): \n            self.left(brake_speed)\n            was_right = True\n        else:\n            self.right(brake_speed)\n            was_right = False\n        sleep(delay_millisecs / 1000)\n        self.set_speed(0)\n        if was_right:\n            self.right()\n        else:\n            self.left()\n```", "```py\nCHANNEL_1_ENABLE_GPIO = 18                                # (1)\nCHANNEL_2_ENABLE_GPIO = 16\n\nINPUT_1A_GPIO = 23 # Blue Coil 1 Connected to 1Y          # (2)\nINPUT_2A_GPIO = 24 # Pink Coil 2 Connected to 2Y\nINPUT_3A_GPIO = 20 # Yellow Coil 3 Connected to 3Y\nINPUT_4A_GPIO = 21 # Orange Coil 4 Connected to 4Y\n\nSTEP_DELAY_SECS = 0.002                                   # (3)\n```", "```py\ncoil_gpios = [                             # (4)\n    INPUT_1A_GPIO,\n    INPUT_2A_GPIO,\n    INPUT_3A_GPIO,\n    INPUT_4A_GPIO\n]\n\n# Initialise each coil GPIO as OUTPUT.\nfor gpio in coil_gpios:                    # (5)\n    pi.set_mode(gpio, pigpio.OUTPUT)\n\ndef off():\n    for gpio in coil_gpios:                # (6)\n       pi.write(gpio, pigpio.LOW) # Coil off\n\noff() # Start with stepper motor off.\n```", "```py\n# Enable Channels (always high)\npi.set_mode(CHANNEL_1_ENABLE_GPIO, pigpio.OUTPUT)      # (7)\npi.write(CHANNEL_1_ENABLE_GPIO, pigpio.HIGH)\npi.set_mode(CHANNEL_2_ENABLE_GPIO, pigpio.OUTPUT)\npi.write(CHANNEL_2_ENABLE_GPIO, pigpio.HIGH)\n```", "```py\nCOIL_HALF_SEQUENCE = [             # (8)\n    [0, 1, 1, 1],\n    [0, 0, 1, 1],   # (a)\n    [1, 0, 1, 1],\n    [1, 0, 0, 1],   # (b)\n    [1, 1, 0, 1],\n    [1, 1, 0, 0],   # (c)\n    [1, 1, 1, 0],\n    [0, 1, 1, 0] ]  # (d)\n\nCOIL_FULL_SEQUENCE = [\n    [0, 0, 1, 1],   # (a)\n    [1, 0, 0, 1],   # (b)\n    [1, 1, 0, 0],   # (c)\n    [0, 1, 1, 0] ]  # (d)\n```", "```py\nsequence = COIL_HALF_SEQUENCE       # (9)\n#sequence = COIL_FULL_SEQUENCE\n```", "```py\n# For rotate() to keep track of the sequence row it is on.\nsequence_row = 0 \n\ndef rotate(steps):                              # (10)\n    global sequence_row\n    direction = +1\n    if steps < 0:\n        direction = -1\n```", "```py\n# rotate(steps) continued...\n\n    for step in range(abs(steps)):                # (11)\n      coil_states = sequence[sequence_row]        # (12)\n      for i in range(len(sequence[sequence_row])):\n          gpio = coil_gpios[i]                    # (13)\n          state = sequence[sequence_row][i]       # (14)\n          pi.write(gpio, state)                   # (15)\n          sleep(STEP_DELAY_SECS)\n```", "```py\n# rotate(steps) continued...\n\n      sequence_row += direction            # (16)\n      if sequence_row < 0:\n          sequence_row = len(sequence) - 1\n      elif sequence_row >= len(sequence):\n          sequence_row = 0\n```", "```py\nif __name__ == '__main__':\n    try:                                                   #(17)\n        steps = 4096 # Steps for HALF stepping sequence.\n        print(\"{} steps for full 360 degree rotation.\".format(steps))\n        rotate(steps) # Rotate one direction\n        rotate(-steps) # Rotate reverse direction\n\n    finally:\n        off() # Turn stepper coils off\n        pi.stop() # PiGPIO Cleanup\n```"]