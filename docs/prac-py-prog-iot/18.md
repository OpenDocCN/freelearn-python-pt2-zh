# 十八、答案

# 第一章

1.  使特定于项目的 Python 包和依赖项与其他项目和系统级 Python 包隔离。
2.  不可以。您始终可以重新生成虚拟环境并重新安装软件包。
3.  保存 Python 项目所依赖的所有 Python 包（和版本）的列表。通过维护`requirements.txt`文件，您可以使用`pip install -r requirements.txt`命令轻松地重新安装所有软件包。
4.  确保您使用的是虚拟环境的`bin`文件夹中 Python 解释器的绝对路径。
5.  它激活一个虚拟环境，以便将 Python 和 pip 的所有用户都沙盒到虚拟环境中。
6.  `deactivate`。如果您键入`exit`（我们有时都会这样做！），它将退出终端窗口或关闭远程 SSH 会话！Grrrrr。
7.  是的，只要切换到`projects`文件夹并激活虚拟环境即可。
8.  Python 是空闲的，但请记住，您需要在虚拟环境中使用`python -m idlelib.idle [filename] &`。
9.  检查 I2C 接口是否已在 Raspbian 中启用。

# 第二章

1.  按答案编号排序，以免损坏其他部件或电阻器。。。除非您了解不同的值将如何影响电子电路，并且这样做是安全的。
2.  错误的 GPIO Zero 是其他 GPIO 库之上的包装器。它的设计是为了便于初学者通过隐藏较低级别的 GPIO 接口细节来使用。
3.  错误的在许多情况下，您最好使用成熟的高级包，因为它们将有助于加快开发。pythonapi 文档也推荐这种方法。
4.  不可以。LED 有正极（阳极）和负极（阴极）端子（支脚），必须正确连接。
5.  设备的时区处理可能不匹配。
6.  `signal.pause()`

# 第三章

1.  我们可以创建并配置一个`RequestParser`实例。我们在控制器的处理程序方法（如`.get()`或`.post()`）中使用此实例来验证客户机的请求。
2.  WebSockets–使用 WebSockets 构建的客户端和服务器可以在任意方向上彼此发起请求。这与 RESTful API 服务不同，在 RESTful API 服务中，只有客户端可以向服务器发起请求。
3.  Flask SocketIO 不包括类似 Flask RESTful 的内置验证类。您必须手动执行输入验证。或者，您也可以从 PyPi.org 找到合适的第三方 Python 模块来使用。
4.  `templates`文件夹是 Flask 框架查找模板文件的默认位置。它位于我们存储 HTML 页面和模板的位置。
5.  我们应该在 documentready 函数中初始化事件侦听器和网页内容，该函数在网页完全加载后调用。
6.  命令为`curl`。默认情况下，它安装在大多数基于 Unix 的操作系统上。
7.  更改 value 属性会更改 LED 的 PWM 占空比。我们将此视为改变 LED 的亮度。

# 第四章

1.  **MQTT**或**消息队列遥测协议**是分布式物联网中常用的轻量级消息传递协议。
2.  检查 QoS 级别，确保它们是级别 1 或 2。
3.  如果某个客户端突然与代理断开连接而没有首先完全关闭连接，则会代表该客户端发布一条`Will`消息。
4.  发布的消息和订阅客户端必须至少使用 QoS 级别 1，以确保消息被传递一次或多次。

5.  理想情况下，除了代理主机和端口之外，Python 代码中不需要任何更改，因为 MQTT 是一个开放标准。附带条件是，新代理的配置与被替换的代理类似–例如，两个代理的配置类似，以向客户端提供消息保留或持久连接功能。
6.  您应该订阅成功连接类型处理程序中的主题。这样，如果客户端失去其代理连接，它可以在重新连接时自动重新建立主题订阅。

# 第五章

1.  **SPI**（**串行外围接口电路**。LED 条和矩阵是常见的例子。
2.  您可以参考设备的官方数据表，或使用命令行工具 i2cdetect，该工具列出所有连接的 I2C 设备的地址。
3.  确保您使用的是库所期望的正确 pin 编号方案，和/或确保您已将库配置为使用您喜欢的方案（如果库提供此选项）。
4.  驱动程序库不是基于 PiGPIO 构建的，因此不支持远程 GPIO。
5.  错误的所有 GPIO 引脚的额定电压为 3.3 伏。连接任何高于此值的电压都会损坏覆盆子 Pi。
6.  用于驱动伺服的库极有可能使用软件 PWM 为伺服生成 PWM 信号。当 Raspberry Pi 的 CPU 繁忙时，软件 PWM 信号可能会失真。
7.  如果你是从你的 Raspberry Pi 的 5 伏引脚为伺服供电，这将表明你消耗了太多的电力，实际上剥夺了 Raspberry Pi 的电力。理想情况下，伺服应由外部电源供电。

# 第六章

1.  一般来说，是的。尝试是安全的，因为电阻越高，电路中的电流越低（欧姆定律），330Ω与所需的 200Ω电阻器相对接近。
2.  电阻越高，电流就越小，以至于没有足够的电流使电路可靠工作。

3.  电阻器消耗的功率超过电阻器的额定功率。除了使用欧姆定律确定电阻值外，还需要计算电阻的预期功耗，并确保电阻的额定功率（以瓦特为单位）超过计算值。
4.  1（一）。连接到+3.3 伏的输入 GPIO 引脚为逻辑高电平。
5.  GPIO 21 是浮动的。它不会被物理电阻或通过使用函数调用（如`pi.set_pull_up_down(21, pigpio.PUD_UP)`）的代码拉高到+3.3 伏。
6.  必须使用逻辑电平转换器。这可以是一个简单的基于电阻器的分压器，一个专用的逻辑电平转换器 IC 或模块，或任何其他形式的，可以适当地向下移动 5 伏到 3.3 伏。
7.  错误的电阻分压器只能降压。但是，请记住，只要 5 伏设备将 3.3 伏注册为逻辑高电平，就可以使用 3.3 伏驱动 5 伏逻辑设备。

# 第七章

1.  MOSFET 是电压控制元件，而 BJT 是电流控制元件。
2.  在 MOSFET 的栅脚上没有下拉电阻器，所以它是浮动的。MOSFET 放电缓慢，这在电机向下旋转时反映出来。使用下拉电阻器可确保 MOSFET 迅速放电并关闭。
3.  （a） 确保 G、S 和 D 支腿连接正确，因为不同的封装样式（例如 T092 和 TP220）的支腿订购方式不同。
    （b）您还需要确保 MOSFET 与逻辑电平兼容，以便可以使用 3.3 伏电压源对其进行控制。
    （c）确保下拉电阻器和限流电阻器之间产生的分压器允许>~3 伏电压进入 MOSFET 的栅脚。
4.  光电耦合器和继电器对电路的输入侧和输出侧进行电气隔离。晶体管在电路中，虽然它们允许低电流设备控制大电流设备，但两个设备仍然都是电气连接的（例如，您将看到公共接地连接）。
5.  Active low（低电平）是指通过使 GPIO 低电平来打开或激活连接的电路。有源高电平则相反，因为我们将 GPIO 引脚设为高电平以激活连接的电路。

6.  代码激活下拉仅在代码运行时变为下拉，因此 MOSFET 栅极基本上保持浮动，直到代码运行。
7.  失速电流是指电机工作人员失速时使用的电流，例如，强制停止转动。这是电机将消耗的最大电流。
8.  没有区别——它们是两个可互换使用的术语，用于描述电机在无负载连接到电机轴的情况下自由旋转时使用的电流。

# 第八章

1.  检查您的电源是否能够向 LED 条提供足够的电流（和电压）。当前需求随着您想要点亮的 LED 数量以及设置的颜色和亮度的增加而成比例增加。电流不足可能意味着内部红色/绿色/蓝色 LED 未正确点亮，因此颜色与预期不符。
2.  缺少从属选择或客户端启用 pin 意味着 APA102 完全控制 SPI 接口。这意味着您不能将多个 SPI 从设备连接到一个 SPI 引脚（除非您使用其他电子设备）。
3.  首先，检查逻辑电平转换器是否正确连接。其次，逻辑电平转换器可能无法足够快地转换逻辑电平以跟上 SPI 接口。尝试降低 SPI 总线速度。
4.  我们使用**PIL**（**Python 图像库**）创建一个内存中的图像，表示我们想要显示的内容。然后，我们将该图像发送到 OLED 显示器进行渲染。
5.  **RTTTL**表示**铃声文本传输语言**，这是诺基亚创建的铃声音乐格式。

# 第九章

1.  DHT22 是一种更精确的传感器，能够感应更大范围的温度和温度。
2.  外部上拉电阻器是可选的，因为我们的 Raspberry Pi 可以使用其内部嵌入式上拉电阻器。

3.  LDR 是一种光敏电阻器。当用作分压器电路的一部分时，我们将变化的电阻转化为变化的电压。然后，该电压可由连接到 Raspberry Pi 的模拟数字转换器（如 ADS1115）检测。
4.  尝试改变分压器电路中固定电阻器的电阻。尝试更高的电阻值，使 LDR 在较暗的条件下更敏感。尝试降低电阻值，使 LDR 对更亮的条件更敏感。
5.  当涉及到它们测量的电阻时，没有两个 LDR 是相同的。如果更换电路中的 LDR，请重新校准代码以确保安全。
6.  水导电。它充当两条探测线之间的电阻器。该电阻由分压器转换为电压，可由 ADS1115 ADC 检测。

# 第十章

1.  我们通常会发现伺服系统使用的默认参考脉冲宽度为左 1 毫秒，右 2 毫秒。实际上，伺服可能需要稍微调整脉冲宽度以达到其极限旋转位置。
2.  您正在应用一个脉冲宽度，试图将伺服旋转超过其物理极限。
3.  H 桥还允许我们改变电机的旋转，并应用制动器快速停止电机旋转。
4.  影响制动可靠性的因素很多，包括 IC 和电机。您可以采用 PWM 式制动作为替代制动技术。
5.  振动但不转动通常是线圈通电顺序和线圈步进顺序不匹配的症状。您需要识别并确保步进电机的线圈正确连接，并与步进顺序相匹配。查阅步进电机的数据表是最好的开始。
6.  L293D 的电压降约为 2 伏，因此您的电机只有 3 伏左右。为了补偿电压降，您需要一个 7 伏的电源。
7.  否。GPIO 引脚仅提供 3.3 伏电压。虽然这可能刚好足以旋转 5 伏步进电机，但步进电机的电流要求将超过 Raspberry Pi GPIO 引脚的安全限制。

# 第十一章

1.  不，一个**被动红外**（**PIR**传感器只能检测抽象运动。你需要一个主动式红外传感器或一个像热照相机这样的设备（还有很多复杂的代码）来提取更丰富的运动信息。
2.  超声波传感器测量超声波脉冲的往返时间，然后用于计算距离。因此，影响超声波脉冲定时或声速常数的因素会影响计算距离。一些示例包括温度，因为温度会影响声速、被检测对象的材料（例如，它是否吸收声音？）、对象的大小及其相对于传感器的角度。
3.  闭锁式和非闭锁式霍尔效应传感器均输出数字信号–其输出引脚为高或低。相比之下，比例霍尔效应传感器输出的模拟信号（电压变化）与它们与磁场的距离有关。
4.  当 GPIO 转换到高或低状态时，`callback_handler`函数将被调用。
5.  因此，位于 5 伏电源和分压器输出（两个电阻器之间）之间的电阻器的相对压降为 3.3 伏，即 5 伏*2kΩ/（1kΩ+2kΩ）=~3.3 伏。如果颠倒电路中的电阻值，分压器输出将为~1.7 伏，即 5 伏*1kΩ/（1kΩ+2kΩ）=~1.7 伏。
6.  在查阅 HC-SR501 PIR 传感器的数据表后，我们了解到其输出引脚始终在 3.3 伏下工作，即使其电源为 5 伏，因此我们不需要分压器。（请注意，在实践中，我们最好也通过测量来确认这一点。）

# 第十二章

1.  发布-订阅方法促进了一种高度解耦的编程方法。当您有许多组件（例如，传感器）发布数据，而这些数据只需要在程序中的其他地方使用时，这可能是有益的。
2.  **GIL**代表**全局解释器锁**。这是 Python 编程语言的一个设计方面，意味着一次只有一个线程可以访问 Python 解释器。

3.  纯事件循环（例如，一个长时间循环）会随着程序的增长而变得复杂。对许多状态变量和非平凡的介入性条件测试（例如，if 语句）的需要会使程序逻辑难以遵循和调试。
4.  不，每种方法都有其目的。当事件循环很小且集中时，它们很好。只有当它们变大并执行多个操作时，它们才会变得复杂。
5.  当您使用线程编程时，对另一个线程调用`join()`会将该线程连接到当前线程。然后，当前线程阻塞，直到所有连接的线程运行完方法。这是一种同步多线程完成的简单方法。
6.  也许您正在使用一个`sleep`语句（来自时间库），例如`sleep(duration)`，它会在整个时间段内阻塞。尝试使用以下示例中的方法，这将允许您的程序对`duration`值的更改保持响应：

```py
duration = 1   # 1 second
timer = 0
while timer < duration:
    timer += 0.01
    sleep(0.01)
```

7.  没有比这更好的方法。用 Python 实现编程目标的方法总是不止一种。最佳方法或方法组合取决于您的项目和您试图实现的目标。根据您的个人喜好和首选的编程风格，最好的方法也可以是最适合您的方法。

# 第十三章

1.  我们使用不同的温度来创建一个缓冲区，这样，如果温度徘徊在一个温度值附近，我们就不会生成多个触发器（和多封电子邮件）。
2.  使用中间层意味着我们不需要担心防火墙、端口转发和将 Raspberry Pi 公开到公共 internet 所需的其他配置。
3.  IFTTT 更注重消费者，而 Zapper 在其提供的集成方面更注重业务。Zapper 还允许您创建更复杂的工作流、触发器和操作场景。

4.  不可以。ThingSpeak 只使用显示在仪表板上的数据。某些平台（如 ThingBoard）允许您将数据发送回设备以控制该设备。
5.  最多有三个 JSON 属性可用`– Value1`、`Value2`和`Value3`。
6.  从开发的易用性和速度来看，IFTTT 或 Zapper 将是一个不错的选择，但您肯定可以使用 AWS 或其他主要物联网平台，甚至家庭助理。

# 第十四章

1.  PyPubSub 的使用是一项设计决策，旨在将 MQTT 相关代码和逻辑与硬件控制代码和逻辑解耦，目的是使代码更干净、更易于维护。
2.  您在使用 Google Assistant 应用程序时所说的命令在您的设备上显示为文本，因此很容易看到 Google Assistant 是如何听到您所说的命令的，以及哪些命令作为文本命令发送到您的 IFTTT 小程序。
3.  您需要构建一个集成服务，在 MQTT 和 RESTful API 之间封送数据（或者，标识一个执行此操作的第三十方服务，例如，签出[https://io.adafruit.com](https://io.adafruit.com) 及其 IFTTT 服务）。IFTTT 提供 RESTful Webhook 作为构建自定义集成的选项，但是，它不提供 MQTT 选项。
4.  一种选择是使用 MQTT，就像我们在本章中介绍的示例一样。如果使用 MQTT 将多个 IoTree 连接到中央 MQTT 代理，则它们都会一起接收指令。第二种选择是构建基于 WebSocket 的服务和应用程序（我们在[第 3 章](04.html)、*使用 Flask*与 RESTful API 和 Web 套接字联网中介绍了这种方法）。
5.  我们使用免费的[dweet.io](http://dweet.io)服务是为了方便实用，因此我们不必担心您所在地的防火墙、端口转发和路由器配置（以防万一，这是您从未体验过的）。免费的[dweet.io](http://dweet.io)服务不提供安全性或隐私，因此对于许多项目来说是不可取的。如果你喜欢[dweet.io](http://dweet.io)的想法，还有[dweetpro.io](https://dweetpro.io)，这是一款付费的替代产品，提供安全性和许多其他免费版本无法提供的功能。
6.  `CURL`是一个流行的命令行工具，可用于测试 RESTful API。Postman（[getpostman.com](https://getpostman.com)是一个流行的 GUI 工具，也可以用于相同的目的。

7.  如果使用 MQTT 代理的保留消息功能，则每个 IoTree 在连接时将接收最后一条消息（例如，显示什么颜色的模式），因此可以初始化自身。我们在[第 4 章](05.html)、*与 MQTT、Python 和 Mosquitto MQTT 代理*的联网中介绍了保留的消息。
8.  如果您的 MQTT 代理在与 IoTree 相同的 Raspberry Pi 上运行，并且您重新启动此 Raspberry Pi，则所有保留的消息都将丢失，除非 MOSQUITO MQTT 代理在其配置中启用了持久性。（我们的配置来自[第 4 章](05.html)，*与 MQTT、Python 和 Mosquitto MQTT 代理*联网，确保启用了持久性）。