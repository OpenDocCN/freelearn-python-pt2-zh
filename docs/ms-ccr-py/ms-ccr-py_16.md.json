["```py\n# Chapter16/example1.py\n\nimport time\n\nclass LocklessCounter:\n    def __init__(self):\n        self.value = 0\n\n    def increment(self, x):\n        new_value = self.value + x\n        time.sleep(0.001) # creating a delay\n        self.value = new_value\n\n    def get_value(self):\n        return self.value\n```", "```py\n# Chapter16/example1.py\n\nfrom concurrent.futures import ThreadPoolExecutor\n\ncounter = LocklessCounter()\nwith ThreadPoolExecutor(max_workers=3) as executor:\n    executor.map(counter.increment, [1 for i in range(300)])\n\nprint(f'Final counter: {counter.get_value()}.')\nprint('Finished.')\n```", "```py\n> python3 example1.py\nFinal counter: 101.\nFinished.\n```", "```py\n# Chapter16/example2.py\n\nimport threading\nimport time\n\nclass LockedCounter:\n    def __init__(self):\n        self.value = 0\n        self.lock = threading.Lock()\n\n    def increment(self, x):\n        with self.lock:\n            new_value = self.value + x\n            time.sleep(0.001) # creating a delay\n            self.value = new_value\n\n    def get_value(self):\n        with self.lock:\n            value = self.value\n\n        return value\n```", "```py\n# Chapter16/example2.py\n\nfrom concurrent.futures import ThreadPoolExecutor\n\ncounter = LockedCounter()\nwith ThreadPoolExecutor(max_workers=3) as executor:\n    executor.map(counter.increment, [1 for i in range(300)])\n\nprint(f'Final counter: {counter.get_value()}.')\nprint('Finished.')\n```", "```py\n> python3 example2.py\nFinal counter: 300.\nFinished.\n```", "```py\n# Chapter16/example3.py\n\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport matplotlib.pyplot as plt\n\nclass LockedCounter:\n    def __init__(self):\n        self.value = 0\n        self.lock = threading.Lock()\n\n    def increment(self, x):\n        with self.lock:\n            new_value = self.value + x\n            time.sleep(0.001) # creating a delay\n            self.value = new_value\n\n    def get_value(self):\n        with self.lock:\n            value = self.value\n\n        return value\n\nn_threads = []\ntimes = []\nfor n_workers in range(1, 11):\n    n_threads.append(n_workers)\n\n    counter = LockedCounter()\n\n    start = time.time()\n\n    with ThreadPoolExecutor(max_workers=n_workers) as executor:\n        executor.map(counter.increment, \n                     [1 for i in range(100 * n_workers)])\n\n    times.append(time.time() - start)\n\n    print(f'Number of threads: {n_workers}')\n    print(f'Final counter: {counter.get_value()}.')\n    print(f'Time taken: {times[-1] : .2f} seconds.')\n    print('-' * 40)\n\nplt.plot(n_threads, times)\nplt.xlabel('Number of threads'); plt.ylabel('Time in seconds')\nplt.show()\n```", "```py\n> python3 example3.py\nNumber of threads: 1\nFinal counter: 100.\nTime taken: 0.15 seconds.\n----------------------------------------\nNumber of threads: 2\nFinal counter: 200.\nTime taken: 0.28 seconds.\n----------------------------------------\nNumber of threads: 3\nFinal counter: 300.\nTime taken: 0.45 seconds.\n----------------------------------------\nNumber of threads: 4\nFinal counter: 400.\nTime taken: 0.59 seconds.\n----------------------------------------\nNumber of threads: 5\nFinal counter: 500.\nTime taken: 0.75 seconds.\n----------------------------------------\nNumber of threads: 6\nFinal counter: 600.\nTime taken: 0.87 seconds.\n----------------------------------------\nNumber of threads: 7\nFinal counter: 700.\nTime taken: 1.01 seconds.\n----------------------------------------\nNumber of threads: 8\nFinal counter: 800.\nTime taken: 1.18 seconds.\n----------------------------------------\nNumber of threads: 9\nFinal counter: 900.\nTime taken: 1.29 seconds.\n----------------------------------------\nNumber of threads: 10\nFinal counter: 1000.\nTime taken: 1.49 seconds.\n----------------------------------------\n```", "```py\n# Chapter16/example4.py\n\nimport threading\nimport time\n\nclass LockedCounter:\n    def __init__(self):\n        self.value = 0\n        self.lock = threading.Lock()\n\n    def increment(self, x):\n        with self.lock:\n            new_value = self.value + x\n            time.sleep(0.001) # creating a delay\n            self.value = new_value\n\n    def get_value(self):\n        with self.lock:\n            value = self.value\n\n        return value\n\nclass ApproximateCounter:\n    def __init__(self, global_counter):\n        self.value = 0\n        self.lock = threading.Lock()\n        self.global_counter = global_counter\n        self.threshold = 10\n\n    def increment(self, x):\n        with self.lock:\n            new_value = self.value + x\n            time.sleep(0.001) # creating a delay\n            self.value = new_value\n\n            if self.value >= self.threshold:\n                self.global_counter.increment(self.value)\n                self.value = 0\n\n    def get_value(self):\n        with self.lock:\n            value = self.value\n\n        return value\n```", "```py\n# Chapter16/example4.py\n\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Previous single-lock counter\n\nsingle_counter_n_threads = []\nsingle_counter_times = []\nfor n_workers in range(1, 11):\n    single_counter_n_threads.append(n_workers)\n\n    counter = LockedCounter()\n\n    start = time.time()\n\n    with ThreadPoolExecutor(max_workers=n_workers) as executor:\n        executor.map(counter.increment, \n                     [1 for i in range(100 * n_workers)])\n\n    single_counter_times.append(time.time() - start)\n```", "```py\n# New approximate counters\n\ndef thread_increment(counter):\n    counter.increment(1)\n\napprox_counter_n_threads = []\napprox_counter_times = []\nfor n_workers in range(1, 11):\n    approx_counter_n_threads.append(n_workers)\n\n    global_counter = LockedCounter()\n\n    start = time.time()\n\n    local_counters = [ApproximateCounter(global_counter) for i in range(n_workers)]\n    with ThreadPoolExecutor(max_workers=n_workers) as executor:\n        for i in range(100):\n            executor.map(thread_increment, local_counters)\n\n    approx_counter_times.append(time.time() - start)\n\n    print(f'Number of threads: {n_workers}')\n    print(f'Final counter: {global_counter.get_value()}.')\n    print('-' * 40)\n```", "```py\n# Chapter16/example4.py\nimport matplotlib.pyplot as plt\n\n# Plotting\n\nsingle_counter_line, = plt.plot(\n    single_counter_n_threads,\n    single_counter_times,\n    c = 'blue',\n    label = 'Single counter'\n)\napprox_counter_line, = plt.plot(\n    approx_counter_n_threads,\n    approx_counter_times,\n    c = 'red',\n    label = 'Approximate counter'\n)\nplt.legend(handles=[single_counter_line, approx_counter_line], loc=2)\nplt.xlabel('Number of threads'); plt.ylabel('Time in seconds')\nplt.show()\n```", "```py\n> python3 example4.py\nNumber of threads: 1\nFinal counter: 100.\n----------------------------------------\nNumber of threads: 2\nFinal counter: 200.\n----------------------------------------\nNumber of threads: 3\nFinal counter: 300.\n----------------------------------------\nNumber of threads: 4\nFinal counter: 400.\n----------------------------------------\nNumber of threads: 5\nFinal counter: 500.\n----------------------------------------\nNumber of threads: 6\nFinal counter: 600.\n----------------------------------------\nNumber of threads: 7\nFinal counter: 700.\n----------------------------------------\nNumber of threads: 8\nFinal counter: 800.\n----------------------------------------\nNumber of threads: 9\nFinal counter: 900.\n----------------------------------------\nNumber of threads: 10\nFinal counter: 1000.\n----------------------------------------\n```", "```py\n# Chapter16/network.py\n\nimport time\nfrom random import choice\n\nclass Network:\n    def __init__(self, primary_key, primary_value):\n        self.primary_key = primary_key\n        self.data = {primary_key: primary_value}\n\n    def __str__(self):\n        result = '{\\n'\n        for key in self.data:\n            result += f'\\t{key}: {self.data[key]};\\n'\n\n        return result + '}'\n\n    def add_node(self, key, value):\n        if key not in self.data:\n            self.data[key] = value\n            return True\n\n        return False\n\n    # precondition: the object has more than one node left\n    def refresh_primary(self):\n        del self.data[self.primary_key]\n        self.primary_key = choice(list(self.data))\n\n    def get_primary_value(self):\n        primary_key = self.primary_key\n        time.sleep(1) # creating a delay\n        return self.data[primary_key]\n```", "```py\n# Chapter16/example5.py\n\nfrom network import Network\nimport threading\n\ndef print_network_primary_value():\n    global my_network\n\n    print(f'Current primary value: {my_network.get_primary_value()}.')\n\nmy_network = Network('A', 1)\nprint(f'Initial network: {my_network}')\nprint()\n\nmy_network.add_node('B', 1)\nmy_network.add_node('C', 1)\nprint(f'Full network: {my_network}')\nprint()\n\nthread1 = threading.Thread(target=print_network_primary_value)\nthread2 = threading.Thread(target=my_network.refresh_primary)\n\nthread1.start()\nthread2.start()\n\nthread1.join()\nthread2.join()\n\nprint(f'Final network: {my_network}')\nprint()\n\nprint('Finished.')\n```", "```py\n> python3 example5.py\nInitial network: {\n A: 1;\n}\n\nFull network: {\n A: 1;\n B: 1;\n C: 1;\n}\n\nException in thread Thread-1:\nTraceback (most recent call last):\n File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/threading.py\", line 917, in _bootstrap_inner\n self.run()\n File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/threading.py\", line 865, in run\n self._target(*self._args, **self._kwargs)\n File \"example5.py\", line 7, in print_network_primary_value\n print(f'Current primary value: {my_network.get_primary_value()}.')\n File \"/Users/quannguyen/Documents/python/mastering_concurrency/ch16/network.py\", line 30, in get_primary_value\n return self.data[primary_key]\nKeyError: 'A'\n\nFinal network: {\n B: 1;\n C: 1;\n}\n\nFinished.\n```", "```py\n# Chapter16/concurrent_network.py\n\nfrom copy import deepcopy\nimport time\n\nclass Network:\n    [...]\n\n    def get_primary_value(self):\n        copy_network = deepcopy(self)\n\n        primary_key = copy_network.primary_key\n        time.sleep(1) # creating a delay\n        return copy_network.data[primary_key]\n```", "```py\n> python3 example6.py\nInitial network: {\n A: 1;\n}\n\nFull network: {\n A: 1;\n B: 1;\n C: 1;\n}\n\nCurrent primary value: 1.\nFinal network: {\n B: 1;\n C: 1;\n}\n\nFinished.\n```"]