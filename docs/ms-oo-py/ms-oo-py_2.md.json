["```py\nclass X:\n    pass\n```", "```py\n>>> X.__class__\n<class 'type'>\n>>> X.__class__.__base__\n<class 'object'>\n```", "```py\nclass Rectangle:\n    def area( self ):\n        return self.length * self.width\n```", "```py\n>>> r= Rectangle()\n>>> r.length, r.width = 13, 8\n>>> r.area()\n104\n```", "```py\nif 'x' in self.__dict__:\n```", "```py\ntry:\n    self.x\nexcept AttributeError:\n```", "```py\nclass Card:\n    def  __init__( self, rank, suit ):\n        self.suit= suit\n        self.rank= rank\n        self.hard, self.soft = self._points()\nclass NumberCard( Card ):\n    def _points( self ):\n        return int(self.rank), int(self.rank)\nclass AceCard( Card ):\n    def _points( self ):\n        return 1, 11\nclass FaceCard( Card ):\n    def _points( self ):\n        return 10, 10\n```", "```py\ncards = [ AceCard('A', '\u2660'), NumberCard('2','\u2660'), NumberCard('3','\u2660'), ]\n```", "```py\nclass Suit:\n    def __init__( self, name, symbol ):\n        self.name= name\n        self.symbol= symbol\n```", "```py\nClub, Diamond, Heart, Spade = Suit('Club','\u2663'), Suit('Diamond','\u2666'), Suit('Heart','\u2665'), Suit('Spade','\u2660')\n```", "```py\ncards = [ AceCard('A', Spade), NumberCard('2', Spade), NumberCard('3', Spade), ]\n```", "```py\ndef card( rank, suit ):\n    if rank == 1: return AceCard( 'A', suit )\n    elif 2 <= rank < 11: return NumberCard( str(rank), suit )\n    elif 11 <= rank < 14:\n        name = { 11: 'J', 12: 'Q', 13: 'K' }[rank]\n        return FaceCard( name, suit )\n    else:\n        raise Exception( \"Rank out of range\" )\n```", "```py\ndeck = [card(rank, suit)\n    for rank in range(1,14)\n        for suit in (Club, Diamond, Heart, Spade)]\n```", "```py\ndef card2( rank, suit ):\n    if rank == 1: return AceCard( 'A', suit )\n    elif 2 <= rank < 11: return NumberCard( str(rank), suit )\n    else:\n        name = { 11: 'J', 12: 'Q', 13: 'K' }[rank]\n        return FaceCard( name, suit )\n```", "```py\ndeck2 = [card2(rank, suit) for rank in range(13) for suit in (Club, Diamond, Heart, Spade)]\n```", "```py\ndef card3( rank, suit ):\n    if rank == 1: return AceCard( 'A', suit )\n    elif 2 <= rank < 11: return NumberCard( str(rank), suit )\n    elif rank == 11:\n        return FaceCard( 'J', suit )\n    elif rank == 12:\n        return FaceCard( 'Q', suit )\n    elif rank == 13:\n        return FaceCard( 'K', suit )\n    else:\n        raise Exception( \"Rank out of range\" )\n```", "```py\ndef card4( rank, suit ):\n    class_= {1: AceCard, 11: FaceCard, 12: FaceCard,\n        13: FaceCard}.get(rank, NumberCard)\n    return class_( rank, suit )\n```", "```py\ndefaultdict( lambda: NumberCard, {1: AceCard, 11: FaceCard, 12: FaceCard, 12: FaceCard} )\n```", "```py\nclass_= {1: AceCard, 11: FaceCard, 12: FaceCard, 13: FaceCard }.get(rank, NumberCard)\nrank_str= {1:'A', 11:'J', 12:'Q', 13:'K'}.get(rank,str(rank))\nreturn class_( rank_str, suit )\n```", "```py\nclass_, rank_str= {\n    1:  (AceCard,'A'),\n    11: (FaceCard,'J'),\n    12: (FaceCard,'Q'),\n    13: (FaceCard,'K'),\n    }.get(rank, (NumberCard, str(rank)))\nreturn class_( rank_str, suit )\n```", "```py\nfrom functools import partial\npart_class= {\n    1:  partial(AceCard,'A'),\n    11: partial(FaceCard,'J'),\n    12: partial(FaceCard,'Q'),\n    13: partial(FaceCard,'K'),\n    }.get(rank, partial(NumberCard, str(rank)))\nreturn part_class( suit )\n```", "```py\nclass CardFactory:\n    def rank( self, rank ):\n        self.class_, self.rank_str= {\n            1:(AceCard,'A'),\n            11:(FaceCard,'J'),\n            12:(FaceCard,'Q'),\n            13:(FaceCard,'K'),\n            }.get(rank, (NumberCard, str(rank)))\n        return self\n    def suit( self, suit ):\n        return self.class_( self.rank_str, suit )\n```", "```py\ncard8 = CardFactory()\ndeck8 = [card8.rank(r+1).suit(s) for r in range(13) for s in (Club, Diamond, Heart, Spade)]\n```", "```py\nclass Card:\n    pass\nclass NumberCard( Card ):\n    def  __init__( self, rank, suit ):\n        self.suit= suit\n        self.rank= str(rank)\n        self.hard = self.soft = rank\nclass AceCard( Card ):\n    def  __init__( self, rank, suit ):\n        self.suit= suit\n        self.rank= \"A\"\n        self.hard, self.soft =  1, 11\nclass FaceCard( Card ):\n    def  __init__( self, rank, suit ):\n        self.suit= suit\n        self.rank= {11: 'J', 12: 'Q', 13: 'K' }[rank]\n        self.hard = self.soft = 10\n```", "```py\nclass Card:\n    def __init__( self, rank, suit, hard, soft ):\n        self.rank= rank\n        self.suit= suit\n        self.hard= hard\n        self.soft= soft\nclass NumberCard( Card ):\n    def  __init__( self, rank, suit ):\n        super().__init__( str(rank), suit, rank, rank )\nclass AceCard( Card ):\n    def  __init__( self, rank, suit ):\n        super().__init__( \"A\", suit, 1, 11 )\nclass FaceCard( Card ):\n    def  __init__( self, rank, suit ):\n        super().__init__( {11: 'J', 12: 'Q', 13: 'K' }[rank], suit, 10, 10 )\n```", "```py\ndef card10( rank, suit ):\n    if rank == 1: return AceCard( rank, suit )\n    elif 2 <= rank < 11: return NumberCard( rank, suit )\n    elif 11 <= rank < 14: return FaceCard( rank, suit )\n    else:\n        raise Exception( \"Rank out of range\" )\n```", "```py\nd= [card6(r+1,s) for r in range(13) for s in (Club, Diamond, Heart, Spade)]\nrandom.shuffle(d)\nhand= [ d.pop(), d.pop() ]\n```", "```py\nclass Deck:\n    def __init__( self ):\n        self._cards = [card6(r+1,s) for r in range(13) for s in (Club, Diamond, Heart, Spade)]\n        random.shuffle( self._cards )\n    def pop( self ):\n        return self._cards.pop()\n```", "```py\nd= Deck()\nhand= [ d.pop(), d.pop() ]\n```", "```py\nclass Deck2( list ):\n    def __init__( self ):\n        super().__init__( card6(r+1,s) for r in range(13) for s in (Club, Diamond, Heart, Spade) )\n        random.shuffle( self )\n```", "```py\nclass Deck3(list):\n    def __init__(self, decks=1):\n        super().__init__()\n        for i in range(decks):\n            self.extend( card6(r+1,s) for r in range(13) for s in (Club, Diamond, Heart, Spade) )\n        random.shuffle( self )\n        burn= random.randint(1,52)\n        for i in range(burn): self.pop()\n```", "```py\n( card6(r+1,s) for r in range(13) for s in (Club, Diamond, Heart, Spade) for d in range(decks) )\n```", "```py\nclass Hand:\n    def __init__( self, dealer_card ):\n        self.dealer_card= dealer_card\n        self.cards= []\n    def hard_total(self ):\n        return sum(c.hard for c in self.cards)\n    def soft_total(self ):\n        return sum(c.soft for c in self.cards)\n```", "```py\nd = Deck()\nh = Hand( d.pop() )\nh.cards.append( d.pop() )\nh.cards.append( d.pop() )\n```", "```py\nclass Hand2:\n    def __init__( self, dealer_card, *cards ):\n        self.dealer_card= dealer_card\n        self.cards = list(cards)\n    def hard_total(self ):\n        return sum(c.hard for c in self.cards)\n    def soft_total(self ):\n        return sum(c.soft for c in self.cards)\n```", "```py\nd = Deck()\nP = Hand2( d.pop() )\np.cards.append( d.pop() )\np.cards.append( d.pop() )\n```", "```py\nd = Deck()\nh = Hand2( d.pop(), d.pop(), d.pop() )\n```", "```py\nclass GameStrategy:\n    def insurance( self, hand ):\n        return False\n    def split( self, hand ):\n        return False\n    def double( self, hand ):\n        return False\n    def hit( self, hand ):\n        return sum(c.hard for c in hand.cards) <= 17\n```", "```py\ndumb = GameStrategy()\n```", "```py\nclass Table:\n    def __init__( self ):\n        self.deck = Deck()\n    def place_bet( self, amount ):\n        print( \"Bet\", amount )\n    def get_hand( self ):\n        try:\n            self.hand= Hand2( d.pop(), d.pop(), d.pop() )\n            self.hole_card= d.pop()\n        except IndexError:\n            # Out of cards: need to shuffle.\n            self.deck= Deck()\n            return self.get_hand()\n        print( \"Deal\", self.hand )\n        return self.hand\n    def can_insure( self, hand ):\n        return hand.dealer_card.insure\n```", "```py\nclass BettingStrategy:\n    def bet( self ):\n        raise NotImplementedError( \"No bet method\" )\n    def record_win( self ):\n        pass\n    def record_loss( self ):\n        pass\n\nclass Flat(BettingStrategy):\n    def bet( self ):\n        return 1\n```", "```py\nimport abc\nclass BettingStrategy2(metaclass=abc.ABCMeta):\n    @abstractmethod\n    def bet( self ):\n        return 1\n    def record_win( self ):\n        pass\n    def record_loss( self ):\n        pass\n```", "```py\nclass Hand3:\n    def __init__( self, *args, **kw ):\n        if len(args) == 1 and isinstance(args[0],Hand3):\n            # Clone an existing hand; often a bad idea\n            other= args[0]\n            self.dealer_card= other.dealer_card\n            self.cards= other.cards\n        else:\n            # Build a fresh, new hand.\n            dealer_card, *cards = args\n            self.dealer_card=  dealer_card\n            self.cards= list(cards)\n```", "```py\nh = Hand( deck.pop(), deck.pop(), deck.pop() )\nmemento= Hand( h )\n```", "```py\nclass Hand4:\n    def __init__( self, *args, **kw ):\n        if len(args) == 1 and isinstance(args[0],Hand4):\n            # Clone an existing handl often a bad idea\n            other= args[0]\n            self.dealer_card= other.dealer_card\n            self.cards= other.cards\n        elif len(args) == 2 and isinstance(args[0],Hand4) and 'split' in kw:\n            # Split an existing hand\n            other, card= args\n            self.dealer_card= other.dealer_card\n            self.cards= [other.cards[kw['split']], card]\n        elif len(args) == 3:\n            # Build a fresh, new hand.\n            dealer_card, *cards = args\n            self.dealer_card=  dealer_card\n            self.cards= list(cards)\n        else:\n            raise TypeError( \"Invalid constructor args={0!r} kw={1!r}\".format(args, kw) )\n    def __str__( self ):\n        return \", \".join( map(str, self.cards) )\n```", "```py\nd = Deck()\nh = Hand4( d.pop(), d.pop(), d.pop() )\ns1 = Hand4( h, d.pop(), split=0 )\ns2 = Hand4( h, d.pop(), split=1 )\n```", "```py\nclass Hand5:\n    def __init__( self, dealer_card, *cards ):\n        self.dealer_card= dealer_card\n        self.cards = list(cards)\n    @staticmethod\n    def freeze( other ):\n        hand= Hand5( other.dealer_card, *other.cards )\n        return hand\n    @staticmethod\n    def split( other, card0, card1 ):\n        hand0= Hand5( other.dealer_card, other.cards[0], card0 )\n        hand1= Hand5( other.dealer_card, other.cards[1], card1 )\n        return hand0, hand1\n    def __str__( self ):\n        return \", \".join( map(str, self.cards) )\n```", "```py\nd = Deck()\nh = Hand5( d.pop(), d.pop(), d.pop() )\ns1, s2 = Hand5.split( h, d.pop(), d.pop() )\n```", "```py\nclass Player:\n    def __init__( self, table, bet_strategy, game_strategy ):\n **self.bet_strategy = bet_strategy**\n **self.game_strategy = game_strategy**\n **self.table= table**\n    def game( self ):\n        self.table.place_bet( self.bet_strategy.bet() )\n        self.hand= self.table.get_hand()\n        if self.table.can_insure( self.hand ):\n            if self.game_strategy.insurance( self.hand ):\n                self.table.insure( self.bet_strategy.bet() )\n        # Yet more... Elided for now\n```", "```py\ntable = Table()\nflat_bet = Flat()\ndumb = GameStrategy()\np = Player( table, flat_bet, dumb )\np.game()\n```", "```py\nclass Player2:\n    def __init__( self, **kw ):\n        \"\"\"Must provide table, bet_strategy, game_strategy.\"\"\"\n        self.__dict__.update( kw )\n    def game( self ):\n        self.table.place_bet( self.bet_strategy.bet() )\n        self.hand= self.table.get_hand()\n        if self.table.can_insure( self.hand ):\n            if self.game_strategy.insurance( self.hand ):\n                self.table.insure( self.bet_strategy.bet() )\n        # etc.\n```", "```py\np2 = Player2( table=table, bet_strategy=flat_bet, game_strategy=dumb )\n```", "```py\n>>> p1= Player2( table=table, bet_strategy=flat_bet, game_strategy=dumb)\n>>> p1.game()\n```", "```py\n>>> p2= Player2( table=table, bet_strategy=flat_bet, game_strategy=dumb, log_name=\"Flat/Dumb\" )\n>>> p2.game()\n```", "```py\nclass Player3( Player ):\n    def __init__( self, table, bet_strategy, game_strategy, **extras ):\n        self.bet_strategy = bet_strategy\n        self.game_strategy = game_strategy\n        self.table= table\n        self.__dict__.update( extras )\n```", "```py\nclass ValidPlayer:\n    def __init__( self, table, bet_strategy, game_strategy ):\n        assert isinstance( table, Table )\n        assert isinstance( bet_strategy, BettingStrategy )\n        assert isinstance( game_strategy, GameStrategy )\n\n        self.bet_strategy = bet_strategy\n        self.game_strategy = game_strategy\n        self.table= table\n```", "```py\nclass Player:\n    def __init__( self, table, bet_strategy, game_strategy ):\n        \"\"\"Creates a new player associated with a table, and configured with proper betting and play strategies\n\n        :param table: an instance of :class:`Table`\n        :param bet_strategy: an instance of :class:`BettingStrategy`\n        :param  game_strategy: an instance of :class:`GameStrategy`\n        \"\"\"\n        self.bet_strategy = bet_strategy\n        self.game_strategy = game_strategy\n        self.table= table\n```", "```py\nclass Card:\n    insure= False\n    def  __init__( self, rank, suit ):\n        self.suit= suit\n        self.rank= rank\n        self.hard, self.soft = self._points()\nclass NumberCard( Card ):\n    def _points( self ):\n        return int(self.rank), int(self.rank)\n```", "```py\n>>> x=NumberCard( '2', '\u2663')\n>>> str(x)\n'<__main__.NumberCard object at 0x1013ea610>'\n>>> repr(x)\n'<__main__.NumberCard object at 0x1013ea610>'\n>>> print(x)\n<__main__.NumberCard object at 0x1013ea610>\n```", "```py\n    def __repr__( self ):\n        return \"{__class__.__name__}(suit={suit!r}, rank={rank!r})\".format(\n            __class__=self.__class__, **self.__dict__)\n    def __str__( self ):\n        return \"{rank}{suit}\".format(**self.__dict__)\n```", "```py\nclass Hand:\n    def __init__( self, dealer_card, *cards ):\n        self.dealer_card= dealer_card\n        self.cards= list(cards)\n    def __str__( self ):\n        return \", \".join( map(str, self.cards) )\n    def __repr__( self ):\n        return \"{__class__.__name__}({dealer_card!r}, {_cards_str})\".format(\n        __class__=self.__class__,\n        _cards_str=\", \".join( map(repr, self.cards) ),\n        **self.__dict__ )\n```", "```py\n[[fill]align][sign][#][0][width][,][.precision][type]\n```", "```py\nre.compile(\nr\"(?P<fill_align>.?[\\<\\>=\\^])?\"\n\"(?P<sign>[-+ ])?\"\n\"(?P<alt>#)?\"\n\"(?P<padding>0)?\"\n\"(?P<width>\\d*)\"\n\"(?P<comma>,)?\"\n\"(?P<precision>\\.\\d*)?\"\n\"(?P<type>[bcdeEfFgGnosxX%])?\" )\n```", "```py\n    def __format__( self, format_spec ):\n        if format_spec == \"\":\n            return str(self)\n        rs= format_spec.replace(\"%r\",self.rank).replace(\"%s\",self.suit)\n        rs= rs.replace(\"%%\",\"%\")\n        return rs\n```", "```py\nprint( \"Dealer Has {0:%r of %s}\".format( hand.dealer_card) )\n```", "```py\n    default_format= \"some specification\"\n    def __str__( self ):\n        return self.__format__( self.default_format )\n    def __format__( self, format_spec ):\n        if format_spec == \"\":  format_spec = self.default_format\n       # process the format specification.\n```", "```py\nwidth=6\nfor hand,count in statistics.items():\n    print( \"{hand} {count:{width}d}\".format(hand=hand,count=count,width=width) )\n```", "```py\n    def __format__( self, format_specification ):\n        if format_specification == \"\":\n            return str(self)\n        return \", \".join( \"{0:{fs}}\".format(c, fs=format_specification)\n            for c in self.cards )\n```", "```py\n\"Player: {hand:%r%s}\".format(hand=player_hand)\n```", "```py\n>>> x = object()\n>>> hash(x)\n269741571\n>>> id(x)\n4315865136\n>>> id(x) / 16\n269741571.0\n```", "```py\nclass Card:\n    insure= False\n    def __init__( self, rank, suit, hard, soft ):\n        self.rank= rank\n        self.suit= suit\n        self.hard= hard\n        self.soft= soft\n    def __repr__( self ):\n        return \"{__class__.__name__}(suit={suit!r}, rank={rank!r})\".format(__class__=self.__class__, **self.__dict__)\n    def __str__( self ):\n        return \"{rank}{suit}\".format(**self.__dict__)\n\nclass NumberCard( Card ):\n    def  __init__( self, rank, suit ):\n        super().__init__( str(rank), suit, rank, rank )\n\nclass AceCard( Card ):\n    def  __init__( self, rank, suit ):\n        super().__init__( \"A\", suit, 1, 11 )\n\nclass FaceCard( Card ):\n    def  __init__( self, rank, suit ):\n        super().__init__( {11: 'J', 12: 'Q', 13: 'K' }[rank], suit, 10, 10 )\n```", "```py\n>>> c1 = AceCard( 1, '\u2663' )\n>>> c2 = AceCard( 1, '\u2663' )\n```", "```py\n>>> print( id(c1), id(c2) )\n4302577232 4302576976\n```", "```py\n>>> c1 is c2\nFalse\n```", "```py\n>>> print( hash(c1), hash(c2) )\n268911077 268911061\n```", "```py\n>>> id(c1) / 16\n268911077.0\n>>> id(c2) / 16\n268911061.0\n```", "```py\n>>> print( c1 == c2 )\nFalse\n```", "```py\n>>> print( set( [c1, c2] ) )\n{AceCard(suit='\u2663', rank=1), AceCard(suit='\u2663', rank=1)}\n```", "```py\nclass Card2:\n    insure= False\n    def __init__( self, rank, suit, hard, soft ):\n        self.rank= rank\n        self.suit= suit\n        self.hard= hard\n        self.soft= soft\n    def __repr__( self ):\n        return \"{__class__.__name__}(suit={suit!r}, rank={rank!r})\".format(__class__=self.__class__, **self.__dict__)\n    def __str__( self ):\n        return \"{rank}{suit}\".format(**self.__dict__)\n    def __eq__( self, other ):\n        return self.suit == other.suit and self.rank == other.rank\n    def __hash__( self ):\n        return hash(self.suit) ^ hash(self.rank)\nclass AceCard2( Card2 ):\n    insure= True\n    def  __init__( self, rank, suit ):\n        super().__init__( \"A\", suit, 1, 11 )\n```", "```py\n>>> c1 = AceCard2( 1, '\u2663' )\n>>> c2 = AceCard2( 1, '\u2663' )\n```", "```py\n>>> print( id(c1), id(c2) )\n4302577040 4302577296\n>>> print( c1 is c2 )\nFalse\n```", "```py\n>>> print( hash(c1), hash(c2) )\n1259258073890 1259258073890\n```", "```py\n>>> print( c1 == c2 )\nTrue\n```", "```py\n>>> print( set( [c1, c2] ) )\n{AceCard2(suit='\u2663', rank='A')}\n```", "```py\nclass Card3:\n    insure= False\n    def __init__( self, rank, suit, hard, soft ):\n        self.rank= rank\n        self.suit= suit\n        self.hard= hard\n        self.soft= soft\n    def __repr__( self ):\n        return \"{__class__.__name__}(suit={suit!r}, rank={rank!r})\".format(__class__=self.__class__, **self.__dict__)\n    def __str__( self ):\n        return \"{rank}{suit}\".format(**self.__dict__)\n    def __eq__( self, other ):\n        return self.suit == other.suit and self.rank == other.rank\n        # and self.hard == other.hard and self.soft == other.soft\n    __hash__ = None\nclass AceCard3( Card3 ):\n    insure= True\n    def  __init__( self, rank, suit ):\n        super().__init__( \"A\", suit, 1, 11 )\n```", "```py\n>>> c1 = AceCard3( 1, '\u2663' )\n>>> c2 = AceCard3( 1, '\u2663' )\n```", "```py\n>>> print( id(c1), id(c2) )\n4302577040 4302577296\n```", "```py\n>>> print( hash(c1), hash(c2) )\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unhashable type: 'AceCard3'\n```", "```py\n>>> print( c1 == c2 )\nTrue\n```", "```py\n>>> print( set( [c1, c2] ) )\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unhashable type: 'AceCard3'\n```", "```py\nclass Hand:\n     def __init__( self, dealer_card, *cards ):\n        self.dealer_card= dealer_card\n        self.cards= list(cards)\n    def __str__( self ):\n        return \", \".join( map(str, self.cards) )\n    def __repr__( self ):\n        return \"{__class__.__name__}({dealer_card!r}, {_cards_str})\".format(\n        __class__=self.__class__,\n        _cards_str=\", \".join( map(repr, self.cards) ),\n        **self.__dict__ )\n    def __eq__( self, other ):\n        return self.cards == other.cards and self.dealer_card == other.dealer_card\n    __hash__ = None\n```", "```py\nimport sys\nclass FrozenHand( Hand ):\n    def __init__( self, *args, **kw ):\n        if len(args) == 1 and isinstance(args[0], Hand):\n            # Clone a hand\n            other= args[0]\n            self.dealer_card= other.dealer_card\n            self.cards= other.cards\n        else:\n            # Build a fresh hand\n            super().__init__( *args, **kw )\n    def __hash__( self ):\n        h= 0\n        for c in self.cards:\n            h = (h + hash(c)) % sys.hash_info.modulus\n        return h\n```", "```py\nstats = defaultdict(int)\n\nd= Deck()\nh = Hand( d.pop(), d.pop(), d.pop() )\nh_f = FrozenHand( h )\nstats[h_f] += 1\n```", "```py\nif some_object:\n    process( some_object )\n```", "```py\n>>> x = object()\n>>> bool(x)\nTrue\n```", "```py\ndef __bool__( self ):\n    return bool( self._cards )\n```", "```py\ndef __bool__( self ):\n    return super().__bool__( self )\n```", "```py\nd = Deck()\nwhile d:\n    card= d.pop()\n    # process the card\n```", "```py\n    def __bytes__( self ):\n        class_code= self.__class__.__name__[0]\n        rank_number_str = {'A': '1', 'J': '11', 'Q': '12', 'K': '13'}.get( self.rank, self.rank )\n        string= \"(\"+\" \".join([class_code, rank_number_str, self.suit,] ) + \")\"\n        return bytes(string,encoding=\"utf8\")\n```", "```py\ndef card_from_bytes( buffer ):\n    string = buffer.decode(\"utf8\")\n    assert string[0 ]==\"(\" and string[-1] == \")\"\n    code, rank_number, suit = string[1:-1].split()\n    class_ = { 'A': AceCard, 'N': NumberCard, 'F': FaceCard }[code]\n    return class_( int(rank_number), suit )\n```", "```py\nb= bytes(someCard)\n```", "```py\nsomeCard = card_from_bytes(b)\n```", "```py\nclass BlackJackCard_p:\n    def __init__( self, rank, suit ):\n        self.rank= rank\n        self.suit= suit\n    def __lt__( self, other ):\n        print( \"Compare {0} < {1}\".format( self, other ) )\n        return self.rank < other.rank\n    def __str__( self ):\n        return \"{rank}{suit}\".format( **self.__dict__ )\n```", "```py\n>>> two = BlackJackCard_p( 2, '\u2660' )\n>>> three = BlackJackCard_p( 3, '\u2660' )\n>>> two < three\nCompare 2\u2660 < 3\u2660\nTrue\n>>> two > three\nCompare 3\u2660 < 2\u2660\nFalse\n>>> two == three\nFalse\n>>> two <= three\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unorderable types: BlackJackCard_p() <= BlackJackCard_p()\n```", "```py\n>>> two_c = BlackJackCard_p( 2, '\u2663' )\n>>> two == two_c\nFalse\n```", "```py\nif hand.cards[0] == hand.cards[1]\n```", "```py\nif hand.cards[0].rank == hand.cards[1].rank\n```", "```py\n class BlackJackCard:\n    def __init__( self, rank, suit, hard, soft ):\n        self.rank= rank\n        self.suit= suit\n        self.hard= hard\n        self.soft= soft\n    def __lt__( self, other ):\n        if not isinstance( other, BlackJackCard ): return NotImplemented\n        return self.rank < other.rank\n\n    def __le__( self, other ):\n        try:\n            return self.rank <= other.rank\n        except AttributeError:\n            return NotImplemented\n    def __gt__( self, other ):\n        if not isinstance( other, BlackJackCard ): return NotImplemented\n        return self.rank > other.rank\n    def __ge__( self, other ):\n        if not isinstance( other, BlackJackCard ): return NotImplemented\n        return self.rank >= other.rank\n    def __eq__( self, other ):\n        if not isinstance( other, BlackJackCard ): return NotImplemented\n        return self.rank == other.rank and self.suit == other.suit\n    def __ne__( self, other ):\n        if not isinstance( other, BlackJackCard ): return NotImplemented\n        return self.rank != other.rank and self.suit != other.suit\n    def __str__( self ):\n        return \"{rank}{suit}\".format( **self.__dict__ )\n```", "```py\n>>> two = card21( 2, '\u2660' )\n>>> three = card21( 3, '\u2660' )\n>>> two_c = card21( 2, '\u2663' )\n```", "```py\n>>> two == two_c\nFalse\n>>> two.rank == two_c.rank\nTrue\n>>> two < three\nTrue\n>>> two_c < three\nTrue\n```", "```py\n>>> two = card21( 2, '\u2663' )\n>>> two < 2\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unorderable types: Number21Card() < int()\n>>> two > 2\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unorderable types: Number21Card() > int()\n```", "```py\n>>> two == 2\nFalse\n>>> two == 3\nFalse\n```", "```py\ndef total( self ):\n    delta_soft = max( c.soft-c.hard for c in self.cards )\n    hard = sum( c.hard for c in self.cards )\n    if hard+delta_soft <= 21: return hard+delta_soft\n    return hard\n```", "```py\nclass Hand:\n    def __init__( self, dealer_card, *cards ):\n        self.dealer_card= dealer_card\n        self.cards= list(cards)\n    def __str__( self ):\n        return \", \".join( map(str, self.cards) )\n    def __repr__( self ):\n        return \"{__class__.__name__}({dealer_card!r}, {_cards_str})\".format(\n        __class__=self.__class__,\n        _cards_str=\", \".join( map(repr, self.cards) ),\n        **self.__dict__ )\n\n    def __eq__( self, other ):\n        if isinstance(other,int):\n            return self.total() == other\n        try:\n            return (self.cards == other.cards \n                and self.dealer_card == other.dealer_card)\n        except AttributeError:\n            return NotImplemented\n    def __lt__( self, other ):\n        if isinstance(other,int):\n            return self.total() < other\n        try:\n            return self.total() < other.total()\n        except AttributeError:\n            return NotImplemented\n    def __le__( self, other ):\n        if isinstance(other,int):\n            return self.total() <= other\n        try:\n            return self.total() <= other.total()\n        except AttributeError:\n            return NotImplemented\n    __hash__ = None\n    def total( self ):\n        delta_soft = max( c.soft-c.hard for c in self.cards )\n        hard = sum( c.hard for c in self.cards )\n        if hard+delta_soft <= 21: return hard+delta_soft\n        return hard\n```", "```py\n>>> two = card21( 2, '\u2660' )\n>>> three = card21( 3, '\u2660' )\n>>> two_c = card21( 2, '\u2663' )\n>>> ace = card21( 1, '\u2663' )\n>>> cards = [ ace, two, two_c, three ]\n```", "```py\n>>> h= Hand( card21(10,'\u2660'), *cards )\n>>> print(h)\nA\u2663, 2\u2660, 2\u2663, 3\u2660\n>>> h.total()\n18\n```", "```py\n>>> h2= Hand( card21(10,'\u2660'), card21(5,'\u2660'), *cards )\n>>> print(h2)\n5\u2660, A\u2663, 2\u2660, 2\u2663, 3\u2660\n>>> h2.total()\n13\n```", "```py\n>>> h < h2\nFalse\n>>> h > h2\nTrue\n```", "```py\n>>> h == 18\nTrue\n>>> h < 19\nTrue\n>>> h > 17\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unorderable types: Hand() > int()\n```", "```py\nclass Noisy:\n    def __del__( self ):\n        print( \"Removing {0}\".format(id(self)) )\n```", "```py\n>>> x= Noisy()\n>>> del x\nRemoving 4313946640\n```", "```py\n>>> ln = [ Noisy(), Noisy() ]\n>>> ln2= ln[:]\n>>> del ln\n```", "```py\n>>> del ln2\nRemoving 4313920336\nRemoving 4313920208\n```", "```py\na = b = Noisy()\nc = [ Noisy() ] * 2\n```", "```py\nclass Parent:\n    def __init__( self, *children ):\n        self.children= list(children)\n        for child in self.children:\n            child.parent= self\n    def __del__( self ):\n        print( \"Removing {__class__.__name__} {id:d}\".format( __class__=self.__class__, id=id(self)) )\n\nclass Child:\n    def __del__( self ):\n        print( \"Removing {__class__.__name__} {id:d}\".format( __class__=self.__class__, id=id(self)) )\n```", "```py\n>>>> p = Parent( Child(), Child() )\n>>> id(p)\n4313921808\n>>> del p\n```", "```py\n>>> p= Parent()\n>>> id(p)\n4313921744\n>>> del p\nRemoving Parent 4313921744\n```", "```py\n>>> import gc\n>>> gc.collect()\n174\n>>> gc.garbage\n[<__main__.Parent object at 0x101213910>, <__main__.Child object at 0x101213890>, <__main__.Child object at 0x101213650>, <__main__.Parent object at 0x101213850>, <__main__.Child object at 0x1012130d0>, <__main__.Child object at 0x101219a10>, <__main__.Parent object at 0x101213250>, <__main__.Child object at 0x101213090>, <__main__.Child object at 0x101219810>, <__main__.Parent object at 0x101213050>, <__main__.Child object at 0x101213210>, <__main__.Child object at 0x101219f90>, <__main__.Parent object at 0x101213810>, <__main__.Child object at 0x1012137d0>, <__main__.Child object at 0x101213790>]\n```", "```py\na= B()\n```", "```py\nimport weakref\nclass Parent2:\n    def __init__( self, *children ):\n        self.children= list(children)\n        for child in self.children:\n            child.parent= weakref.ref(self)\n    def __del__( self ):\n        print( \"Removing {__class__.__name__} {id:d}\".format( __class__=self.__class__, id=id(self)) )\n```", "```py\np = self.parent()\nif p is not None:\n    # process p, the Parent instance\nelse:\n    # the parent instance was garbage collected.\n```", "```py\n>>> p = Parent2( Child(), Child() )\n>>> del p\nRemoving Parent2 4303253584\nRemoving Child 4303256464\nRemoving Child 4303043344\n```", "```py\n__del__ = close\n```", "```py\nclass Float_Fail( float ):\n    def __init__( self, value, unit ):\n        super().__init__( value )\n        self.unit = unit\n```", "```py\n>>> s2 = Float_Fail( 6.5, \"knots\" )\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: float() takes at most 1 argument (2 given)\n```", "```py\nclass Float_Units( float ):\n    def __new__( cls, value, unit ):\n       obj= super().__new__( cls, value )\n       obj.unit= unit\n       return obj\n```", "```py\n>>> speed= Float_Units( 6.5, \"knots\" )\n>>> speed\n6.5\n>>> speed * 10\n65.0\n>>> speed.unit\n'knots'\n```", "```py\nUseless= type(\"Useless\",(),{})\n```", "```py\n>>> Useless()\n<__main__.Useless object at 0x101001910>\n>>> u=_\n>>> u.attr= 1    \n>>> dir(u)\n['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'attr']\n```", "```py\nclass Useless:\n    pass\n```", "```py\nimport collections\nclass Ordered_Attributes(type):\n    @classmethod\n    def __prepare__(metacls, name, bases, **kwds):\n        return collections.OrderedDict()\n    def __new__(cls, name, bases, namespace, **kwds):\n        result = super().__new__(cls, name, bases, namespace)\n        result._order = tuple(n for n in namespace if not n.startswith('__'))\n        return result\n```", "```py\nclass Order_Preserved( metaclass=Ordered_Attributes ):\n    pass\n```", "```py\nclass Something( Order_Preserved ):\n    this= 'text'\n    def z( self ):\n        return False\n    b= 'order is preserved'\n    a= 'more text'\n```", "```py\n>>> Something._order\n>>> ('this', 'z', 'b', 'a')\n```", "```py\nclass Unit:\n    \"\"\"Full name for the unit.\"\"\"\n    factor= 1.0\n    standard= None # Reference to the appropriate StandardUnit\n    name= \"\" # Abbreviation of the unit's name.\n    @classmethod\n    def value( class_, value ):\n        if value is None: return None\n        return value/class_.factor\n    @classmethod\n    def convert( class_, value ):\n        if value is None: return None\n        return value*class_.factor\n```", "```py\n>>> m_f= FOOT.value(4)\n>>> METER.convert(m_f)\n1.2191999999999998\n```", "```py\nclass INCH:\n    standard= INCH\n```", "```py\nclass INCH:\n    pass\nINCH.standard= INCH\n```", "```py\n@standard\nclass INCH:\n    pass\n```", "```py\nclass UnitMeta(type):\n    def __new__(cls, name, bases, dict):\n        new_class= super().__new__(cls, name, bases, dict)\n        new_class.standard = new_class\n        return new_class\n```", "```py\nclass Standard_Unit( Unit, metaclass=UnitMeta ):\n    pass\n```", "```py\nclass INCH( Standard_Unit ):\n    \"\"\"Inches\"\"\"\n    name= \"in\"\n\nclass FOOT( Unit ):\n    \"\"\"Feet\"\"\"\n    name= \"ft\"\n    standard= INCH\n    factor= 1/12\n\nclass CENTIMETER( Unit ):\n    \"\"\"Centimeters\"\"\"\n    name= \"cm\"\n    standard= INCH\n    factor= 2.54\n\nclass METER( Unit ):\n    \"\"\"Meters\"\"\"\n    name= \"m\"\n    standard= INCH\n    factor= .0254\n```", "```py\n>>> x_std= INCH.value( 159.625 )\n>>> FOOT.convert( x_std )\n13.302083333333332\n>>> METER.convert( x_std )\n4.054475\n>>> METER.factor\n0.0254\n```", "```py\n>>> INCH.standard.__name__\n'INCH'\n>>> FOOT.standard.__name__\n'INCH'\n```", "```py\n>>> class Generic:\n...     pass\n...     \n>>> g= Generic()\n```", "```py\n>>> g.attribute= \"value\"\n>>> g.attribute\n'value'\n>>> g.unset\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'Generic' object has no attribute 'unset'\n>>> del g.attribute\n>>> g.attribute\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'Generic' object has no attribute 'attribute'\n```", "```py\n>>> import types\n>>> n = types.SimpleNamespace()\n```", "```py\n>>> n.attribute= \"value\"\n>>> n.attribute\n'value'\n>>> del n.attribute\n>>> n.attribute\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'namespace' object has no attribute 'attribute'\n```", "```py\ndef  split( self, deck ):\n    assert self.cards[0].rank == self.cards[1].rank\n    try:\n        self.split_count\n        raise CannotResplit\n    except AttributeError:\n        h0 = Hand( self.dealer_card, self.cards[0], deck.pop() )\n        h1 = Hand( self.dealer_card, self.cards[1], deck.pop() )\n        h0.split_count= h1.split_count= 1\n        return h0, h1\n```", "```py\nclass Hand:\n    def __str__( self ):\n        return \", \".join( map(str, self.card) )\n    def __repr__( self ):\n        return \"{__class__.__name__}({dealer_card!r}, {_cards_str})\".format(\n        __class__=self.__class__,\n        _cards_str=\", \".join( map(repr, self.card) ),\n        **self.__dict__ )\n```", "```py\nclass Hand_Lazy(Hand):\n    def __init__( self, dealer_card, *cards ):\n        self.dealer_card= dealer_card\n        self._cards= list(cards)\n    @property\n    def total( self ):\n        delta_soft = max(c.soft-c.hard for c in self._cards)\n        hard_total = sum(c.hard for c in self._cards)\n        if hard_total+delta_soft <= 21: return hard_total+delta_soft\n        return hard_total\n    @property\n    def card( self ):\n        return self._cards\n    @card.setter\n    def card( self, aCard ):\n        self._cards.append( aCard )\n    @card.deleter\n    def card( self ):\n        self._cards.pop(-1)\n```", "```py\n>>> d= Deck()\n>>> h= Hand_Lazy( d.pop(), d.pop(), d.pop() )\n>>> h.total\n19\n>>> h.card= d.pop()\n>>> h.total\n29\n```", "```py\nclass Hand_Eager(Hand):\n    def __init__( self, dealer_card, *cards ):\n        self.dealer_card= dealer_card\n        self.total= 0\n        self._delta_soft= 0\n        self._hard_total= 0\n        self._cards= list()\n        for c in cards:\n            self.card = c\n    @property\n    def card( self ):\n        return self._cards\n    @card.setter\n    def card( self, aCard ):\n        self._cards.append(aCard)\n        self._delta_soft = max(aCard.soft-aCard.hard, self._delta_soft)\n        self._hard_total += aCard.hard\n        self._set_total()\n    @card.deleter\n    def card( self ):\n        removed= self._cards.pop(-1)\n        self._hard_total -= removed.hard\n        # Issue: was this the only ace?\n        self._delta_soft = max( c.soft-c.hard for c in self._cards )\n        self._set_total()\n    def _set_total( self ):\n        if self._hard_total+self._delta_soft <= 21:\n            self.total= self._hard_total+self._delta_soft\n        else:\n            self.total= self._hard_total\n```", "```py\nd= Deck()\nh1= Hand_Lazy( d.pop(), d.pop(), d.pop() )\nprint( h1.total )\nh2= Hand_Eager( d.pop(), d.pop(), d.pop() )\nprint( h2.total )\n```", "```py\nobj.set_something(value)\nobj.something = value\n```", "```py\n    @property\n    def card( self ):\n        return self._cards\n    @card.setter\n    def card( self, aCard ):\n        self._cards.append( aCard )\n    @card.deleter\n    def card( self ):\n        self._cards.pop(-1)\n```", "```py\nh.card= d.pop()\n```", "```py\n    def split( self, deck ):\n        \"\"\"Updates this hand and also returns the new hand.\"\"\"\n        assert self._cards[0].rank == self._cards[1].rank\n        c1= self._cards[-1]\n        del self.card\n        self.card= deck.pop()\n        h_new= self.__class__( self.dealer_card, c1, deck.pop() )\n        return h_new\n```", "```py\n>>> d= Deck()\n>>> c= d.pop()\n>>> h= Hand_Lazy( d.pop(), c, c ) # Force splittable hand\n>>> h2= h.split(d)\n>>> print(h)\n2\u2660, 10\u2660\n>>> print(h2)\n2\u2660, A\u2660\n```", "```py\n>>> c= card21(1,'\u2660')\n>>> c.rank= 12\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 30, in __setattr__\nTypeError: Cannot set rank\n>>> c.hack= 13\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 31, in __setattr__\nAttributeError: 'Ace21Card' has no attribute 'hack'\n```", "```py\nclass BlackJackCard:\n    \"\"\"Abstract Superclass\"\"\"\n    __slots__ = ( 'rank', 'suit', 'hard', 'soft' )\n    def __init__( self, rank, suit, hard, soft ):\n        super().__setattr__( 'rank', rank )\n        super().__setattr__( 'suit', suit )\n        super().__setattr__( 'hard', hard )\n        super().__setattr__( 'soft', soft )\n    def __str__( self ):\n        return \"{0.rank}{0.suit}\".format( self )\n    def __setattr__( self, name, value ):\n        raise AttributeError( \"'{__class__.__name__}' has no attribute '{name}'\".format( __class__= self.__class__, name= name ) )\n```", "```py\nobject.__setattr__(c, 'bad', 5)\n```", "```py\nclass BlackJackCard2( tuple ):\n    def __new__( cls, rank, suit, hard, soft ):\n        return super().__new__( cls, (rank, suit, hard, soft) )\n    def __getattr__( self, name ):\n        return self[{'rank':0, 'suit':1, 'hard':2 , 'soft':3}[name]]\n    def __setattr__( self, name, value ):\n        raise AttributeError\n```", "```py\n>>> d = BlackJackCard2( 'A', '\u2660', 1, 11 )\n>>> d.rank\n'A'\n>>> d.suit\n'\u2660'\n>>> d.bad= 2\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 7, in __setattr__AttributeError\n```", "```py\n>>> RateTimeDistance( rate=5.2, time=9.5 )\n{'distance': 49.4, 'time': 9.5, 'rate': 5.2}\n>>> RateTimeDistance( distance=48.5, rate=6.1 )\n{'distance': 48.5, 'time': 7.950819672131148, 'rate': 6.1}\n```", "```py\n>>> rtd= RateTimeDistance()\n>>> rtd.time= 9.5\n>>> rtd   \n{'time': 9.5}\n>>> rtd.rate= 6.24\n>>> rtd\n{'distance': 59.28, 'time': 9.5, 'rate': 6.24}\n```", "```py\nclass RateTimeDistance( dict ):\n    def __init__( self, *args, **kw ):\n        super().__init__( *args, **kw )\n        self._solve()\n    def __getattr__( self, name ):\n        return self.get(name,None)\n    def __setattr__( self, name, value ):\n        self[name]= value\n        self._solve()\n    def __dir__( self ):\n        return list(self.keys())\n    def _solve(self):\n        if self.rate is not None and self.time is not None:\n            self['distance'] = self.rate*self.time\n        elif self.rate is not None and self.distance is not None:\n            self['time'] = self.distance / self.rate\n        elif self.time is not None and self.distance is not None:\n            self['rate'] = self.distance / self.time\n```", "```py\n>>> rtd= RateTimeDistance( rate=6.3, time=8.25, distance=None )\n>>> print( \"Rate={rate}, Time={time}, Distance={distance}\".format( **rtd ) )\nRate=6.3, Time=8.25, Distance=51.975\n```", "```py\nself.distance = self.rate*self.time\n```", "```py\n>>> rtd.time= None\n>>> rtd.rate= 6.1\n>>> print( \"Rate={rate}, Time={time}, Distance={distance}\".format( **rtd ) )\nRate=6.1, Time=8.25, Distance=50.324999999999996\n```", "```py\nobject.__getattribute__(self, name)\n```", "```py\nclass BlackJackCard3:\n    \"\"\"Abstract Superclass\"\"\"\n    def __init__( self, rank, suit, hard, soft ):\n        super().__setattr__( 'rank', rank )\n        super().__setattr__( 'suit', suit )\n        super().__setattr__( 'hard', hard )\n        super().__setattr__( 'soft', soft )\n    def __setattr__( self, name, value ):\n        if name in self.__dict__:\n            raise AttributeError( \"Cannot set {name}\".format(name=name) )\n        raise AttributeError( \"'{__class__.__name__}' has no attribute '{name}'\".format( __class__= self.__class__, name= name ) )\n    def __getattribute__( self, name ):\n        if name.startswith('_'): raise AttributeError\n        return object.__getattribute__( self, name )\n```", "```py\n>>> c = BlackJackCard3( 'A', '\u2660', 1, 11 )\n>>> c.rank= 12\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 9, in __setattr__\n  File \"<stdin>\", line 13, in __getattribute__\nAttributeError\n>>> c.__dict__['rank']= 12\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 13, in __getattribute__\nAttributeError\n```", "```py\nclass UnitValue_1:\n    \"\"\"Measure and Unit combined.\"\"\"\n    def __init__( self, unit ):\n        self.value= None\n        self.unit= unit\n        self.default_format= \"5.2f\"\n    def __set__( self, instance, value ):\n        self.value= value\n    def __str__( self ):\n        return \"{value:{spec}} {unit}\".format( spec=self.default_format, **self.__dict__)\n    def __format__( self, spec=\"5.2f\" ):\n        #print( \"formatting\", spec )\n        if spec == \"\": spec= self.default_format\n        return \"{value:{spec}} {unit}\".format( spec=spec, **self.__dict__)\n```", "```py\nclass RTD_1:\n    rate= UnitValue_1( \"kt\" )\n    time= UnitValue_1( \"hr\" )\n    distance= UnitValue_1( \"nm\" )\n    def __init__( self, rate=None, time=None, distance=None ):\n        if rate is None:\n            self.time = time\n            self.distance = distance\n            self.rate = distance / time\n        if time is None:\n            self.rate = rate\n            self.distance = distance\n            self.time = distance / rate\n        if distance is None:\n            self.rate = rate\n            self.time = time\n            self.distance = rate * time\n    def __str__( self ):\n        return \"rate: {0.rate} time: {0.time} distance: {0.distance}\".format(self)\n```", "```py\n>>> m1 = RTD_1( rate=5.8, distance=12 )\n>>> str(m1)\n'rate:  5.80 kt time:  2.07 hr distance: 12.00 nm'\n>>> print( \"Time:\", m1.time.value, m1.time.unit )\nTime: 2.0689655172413794 hr\n```", "```py\nclass Unit:\n    conversion= 1.0\n    def __get__( self, instance, owner ):\n        return instance.kph * self.conversion\n    def __set__( self, instance, value ):\n        instance.kph= value / self.conversion\n```", "```py\nclass Knots( Unit ):\n    conversion= 0.5399568\n```", "```py\nclass MPH( Unit ):\n    conversion= 0.62137119\n```", "```py\nclass KPH( Unit ):\n    def __get__( self, instance, owner ):\n        return instance._kph\n    def __set__( self, instance, value ):\n        instance._kph= value\n```", "```py\nclass Measurement:\n    kph= KPH()\n    knots= Knots()\n    mph= MPH()\n    def __init__( self, kph=None, mph=None, knots=None ):\n        if kph: self.kph= kph\n        elif mph: self.mph= mph\n        elif knots: self.knots= knots\n        else:\n            raise TypeError\n    def __str__( self ):\n        return \"rate: {0.kph} kph = {0.mph} mph = {0.knots} knots\".format(self)\n```", "```py\n>>> m2 = Measurement( knots=5.9 )\n>>> str(m2)\n'rate: 10.92680006993152 kph = 6.789598762345432 mph = 5.9 knots'\n>>> m2.kph\n10.92680006993152\n>>> m2.mph\n6.789598762345432\n```", "```py\nimport collections.abc\nclass SomeApplicationClass( collections.abc.Callable ):\n    pass\n```", "```py\ndef some_method( self, other ):\n    assert isinstance(other, collections.abc.Iterator)\n```", "```py\ntry:\n    some_obj.some_method( another )\nexcept AttributeError:\n    warnings.warn( \"{0!r} not an Iterator, found {0.__class__.__bases__!r}\".format(another) )\n    raise\n```", "```py\nassert isinstance( some_argument, collections.abc.Container ), \"{0!r} not a Container\".format(some_argument)\n```", "```py\nif not isinstance(some_argument, collections.abc.Container):\n    raise TypeError( \"{0!r} not a Container\".format(some_argument) )\n```", "```py\ntry:\n    found = value in some_argument\nexcept TypeError:\n    if not isinstance(some_argument, collections.abc.Container):\n        warnings.warn( \"{0!r} not a Container\".format(some_argument) )\n    raise\n```", "```py\n>>> abs(3)\n3\n>>> isinstance(abs, collections.abc.Callable)\nTrue\n```", "```py\n>>> def test(n):\n...     return n*n\n...\n>>> isinstance(test, collections.abc.Callable)\nTrue\n```", "```py\n>>> isinstance( {}, collections.abc.Mapping )\nTrue\n>>> isinstance( collections.defaultdict(int), collections.abc.Mapping )\nTrue\n```", "```py\n>>> import numbers\n>>> isinstance( 42, numbers.Number )\nTrue\n>>> 355/113            \n3.1415929203539825\n>>> isinstance( 355/113, numbers.Number )\nTrue\n```", "```py\n>>> issubclass( decimal.Decimal, numbers.Number )\nTrue\n>>> issubclass( decimal.Decimal, numbers.Integral )\nFalse\n>>> issubclass( decimal.Decimal, numbers.Real )\nFalse\n>>> issubclass( decimal.Decimal, numbers.Complex )\nFalse\n>>> issubclass( decimal.Decimal, numbers.Rational )\nFalse\n```", "```py\n>>> x = [ 1, 2, 3 ]\n>>> iter(x)\n<list_iterator object at 0x1006e3c50>\n>>> x_iter = iter(x)\n>>> next(x_iter)\n1\n>>> next(x_iter)\n2\n>>> next(x_iter)\n3\n>>> next(x_iter)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nStopIteration\n>>> isinstance( x_iter, collections.abc.Iterator )\nTrue\n```", "```py\nwith function(arg) as context:\n    process( context )\n```", "```py\nwith open(\"some file\") as the_file:\n    process( the_file )\n```", "```py\nfrom abc import ABCMeta, abstractmethod\nclass AbstractBettingStrategy(metaclass=ABCMeta):\n    __slots__ = ()\n    @abstractmethod\n    def bet(self, hand):\n        return 1\n    @abstractmethod\n    def record_win(self, hand):\n        pass\n    @abstractmethod\n    def record_loss(self, hand):\n        pass\n    @classmethod\n    def __subclasshook__(cls, subclass):\n        if cls is Hand:\n            if (any(\"bet\" in B.__dict__ for B in subclass.__mro__)\n            and any(\"record_win\" in B.__dict__ for B in subclass.__mro__)\n            and any(\"record_loss\" in B.__dict__ for B in subclass.__mro__)\n            ):\n                return True\n        return NotImplemented\n```", "```py\nclass Simple_Broken(AbstractBettingStrategy):\n    def bet( self, hand ):\n        return 1\n```", "```py\n>>> simple= Simple_Broken()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: Can't instantiate abstract class Simple_Broken with abstract methods record_loss, record_win\n```", "```py\nclass Simple(AbstractBettingStrategy):\n    def bet( self, hand ):\n        return 1\n    def record_win(self, hand):\n        pass\n    def record_loss(self, hand):\n        pass\n```", "```py\nimport collections.abc\nclass Power1( collections.abc.Callable ):\n    def __call__( self, x, n ):\n        p= 1\n        for i in range(n):\n            p *= x\n        return p\npow1= Power1()\n```", "```py\n>>> pow1( 2, 0 )\n1\n>>> pow1( 2, 1 )\n2\n>>> pow1( 2, 2 )\n4\n>>> pow1( 2, 10 )\n1024\n```", "```py\nclass Power2( collections.abc.Callable ):\n    def __call_( self, x, n ):\n        p= 1\n        for i in range(n):\n            p *= x\n        return p\n```", "```py\n>>> pow2= Power2()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: Can't instantiate abstract class Power2 with abstract methods __call__\n```", "```py\n>>> pow3= Power3()\n>>> pow3( 2, 5 )\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'Power3' object is not callable\n```", "```py\nclass Power4( abc.Callable ):\n    def __call__( self, x, n ):\n        if n == 0: return 1\n        elif n % 2 == 1:\n            return self.__call__(x, n-1)*x\n        else: # n % 2 == 0:\n            t= self.__call__(x, n//2)\n            return t*t\n\npow4= Power4()\n```", "```py\nimport timeit\niterative= timeit.timeit( \"pow1(2,1024)\",\"\"\"\nimport collections.abc\nclass Power1( collections.abc.Callable ):\n    def __call__( self, x, n ):\n        p= 1\n        for i in range(n):\n            p *= x\n        return p\n\npow1= Power1()\n\"\"\", number=100000 ) # otherwise it takes 3 minutes\nprint( \"Iterative\", iterative )\n```", "```py\nclass Power5( collections.abc.Callable ):\n    def __init__( self ):\n        self.memo = {}\n    def __call__( self, x, n ):\n        if (x,n) not in self.memo:\n            if n == 0:\n                self.memo[x,n]= 1\n            elif n % 2 == 1:\n                self.memo[x,n]= self.__call__(x, n-1) * x\n            elif n % 2 == 0:\n                t= self.__call__(x, n//2)\n                self.memo[x,n]= t*t\n            else:\n                raise Exception(\"Logic Error\")\n        return self.memo[x,n]\npow5= Power5()\n```", "```py\nfrom functools import lru_cache\n@lru_cache(None)\ndef pow6( x, n ):\n    if n == 0: return 1\n    elif n % 2 == 1:\n        return pow6(x, n-1)*x\n    else: # n % 2 == 0:\n        t= pow6(x, n//2)\n        return t*t\n```", "```py\nclass BettingStrategy:\n    def __init__( self ):\n       self.win= 0\n       self.loss= 0\n    def __call__( self ):\n        return 1\nbet=  BettingStrategy()\n```", "```py\n    def win( self, amount ):\n        self.bet.win += 1\n        self.stake += amount\n    def loss( self, amount ):\n         self.bet.loss += 1\n         self.stake -= amount\n```", "```py\n    def initial_bet( self ):\n        return self.bet()\n```", "```py\nclass BettingMartingale( BettingStrategy ):\n    def __init__( self ):\n        self._win= 0\n        self._loss= 0\n        self.stage= 1\n    @property\n    def win(self): return self._win\n    @win.setter\n    def win(self, value):\n        self._win = value\n        self.stage= 1\n    @property\n    def loss(self): return self._loss\n    @loss.setter\n    def loss(self, value):\n        self._loss = value\n        self.stage *= 2\n    def __call__( self ):\n       return self.stage\n```", "```py\n>>> bet= BettingMartingale()\n>>> bet()\n1\n>>> bet.win += 1\n>>> bet()\n1\n>>> bet.loss += 1\n>>> bet()\n2\n```", "```py\nclass BettingMartingale2( BettingStrategy ):\n    def __init__( self ):\n        self.win= 0\n        self.loss= 0\n        self.stage= 1\n    def __setattr__( self, name, value ):\n        if name == 'win':\n            self.stage = 1\n        elif name == 'loss':\n            self.stage *= 2\n        super().__setattr__( name, value )\n    def __call__( self ):\n       return self.stage\n```", "```py\nimport gzip\nimport csv\n**with open(\"subset.csv\", \"w\") as target:**\n    wtr= csv.writer( target )\n    **with gzip.open(path) as source:**\n        line_iter= (b.decode() for b in source)\n        match_iter = (format_1_pat.match( line ) for line in line_iter)\n        wtr.writerows( (m.groups() for m in match_iter if m is not None) )\n```", "```py\nimport re\nformat_1_pat= re.compile(\n    r\"([\\d\\.]+)\\s+\" # digits and .'s: host\n    r\"(\\S+)\\s+\"     # non-space: logname\n    r\"(\\S+)\\s+\"     # non-space: user\n    r\"\\[(.+?)\\]\\s+\" # Everything in []: time\n    r'\"(.+?)\"\\s+'   # Everything in \"\": request\n    r\"(\\d+)\\s+\"     # digits: status\n    r\"(\\S+)\\s+\"     # non-space: bytes\n    r'\"(.*?)\"\\s+'   # Everything in \"\": referrer\n    r'\"(.*?)\"\\s*'   # Everything in \"\": user agent\n)\n```", "```py\nimport decimal\nPENNY=decimal.Decimal(\"0.00\")\n\nprice= decimal.Decimal('15.99')\nrate= decimal.Decimal('0.0075')\nprint( \"Tax=\", (price*rate).quantize(PENNY), \"Fully=\", price*rate )\n\nwith decimal.localcontext() as ctx:\n    ctx.rounding= decimal.ROUND_DOWN\n    tax= (price*rate).quantize(PENNY)\n    print( \"Tax=\", tax )\n```", "```py\nimport random\nclass KnownSequence:\n    def __init__(self, seed=0):\n        self.seed= 0\n    def __enter__(self):\n        self.was= random.getstate()\n        random.seed(self.seed, version=1)\n        return self\n    def __exit__(self, exc_type, exc_value, traceback):\n        random.setstate(self.was)\n```", "```py\nprint( tuple(random.randint(-1,36) for i in range(5)) )\nwith KnownSequence():\n    print( tuple(random.randint(-1,36) for i in range(5)) )\nprint( tuple(random.randint(-1,36) for i in range(5)) )\nwith KnownSequence():\n    print( tuple(random.randint(-1,36) for i in range(5)) )\nprint( tuple(random.randint(-1,36) for i in range(5)) )\n```", "```py\n(12, 0, 8, 21, 6)\n**(23, 25, 1, 15, 31)**\n(6, 36, 1, 34, 8)\n**(23, 25, 1, 15, 31)**\n(9, 7, 13, 22, 29)\n```", "```py\nclass Deterministic_Deck:\n    def __init__( self, *args, **kw ):\n        self.args= args\n        self.kw= kw\n    def __enter__( self ):\n        self.was= random.getstate()\n        random.seed( 0, version=1 )\n        return Deck( *self.args, **self.kw )\n    def __exit__( self, exc_type, exc_value, traceback ):\n        random.setstate( self.was )\n```", "```py\nwith Deterministic_Deck( size=6 ) as deck:\n    h = Hand( deck.pop(), deck.pop(), deck.pop() )\n```", "```py\nwith Updating( \"some_file\" ):\n    with open( \"some_file\", \"w\" ) as target:\n        process( target )\n```", "```py\nimport os\nclass Updating:\n    def __init__( self, filename ):\n        self.filename= filename\n    def __enter__( self ):\n        try:\n            self.previous= self.filename+\" copy\"\n            os.rename( self.filename, self.previous )\n        except FileNotFoundError:\n            # Never existed, no previous copy\n            self.previous= None\n    def __exit__( self, exc_type, exc_value, traceback ):\n        if exc_type is not None:\n            try:\n                os.rename( self.filename, self.filename+ \" error\" )\n            except FileNotFoundError:\n                pass # Never even got created?\n            if self.previous:\n                os.rename( self.previous, self.filename )\n```", "```py\ndef x(args):\n    body\n```", "```py\nclass X(collections.abc.callable):\n    def __call__(self, args):\n        body\nx= X()\n```", "```py\nwith contextlib.closing( MyClass() ) as my_object:\n    process( my_object )\n```", "```py\nany( card(1,suit) for suit in Suits )\n```", "```py\nany( c.rank == 'A' for c in hand.cards )\n```", "```py\n'A' in hand.cards\n```", "```py\ndef __contains__( self, rank ):\n    return any( c.rank==rank for rank in hand.cards )\n```", "```py\nfrom collections import namedtuple\nBlackjackCard = namedtuple('BlackjackCard','rank,suit,hard,soft')\n```", "```py\ndef card( rank, suit ):\n    if rank == 1:\n        return BlackjackCard( 'A', suit, 1, 11 )\n    elif 2 <= rank < 11:\n        return BlackjackCard( str(rank), suit, rank, rank )\n    elif rank == 11:\n        return BlackjackCard( 'J', suit, 10, 10 )\n    elif rank == 12:\n        return BlackjackCard( 'Q', suit, 10, 10 )\n    elif rank == 13:\n        return BlackjackCard( 'K', suit, 10, 10 )\n```", "```py\nclass TheNamedTuple(tuple):\n    __slots__ = ()\n    _fields = {field_names!r}\n    def __new__(_cls, {arg_list}):\n        return _tuple.__new__(_cls, ({arg_list}))\n```", "```py\nBlackjackCard = namedtuple('BlackjackCard','rank,suit,hard,soft')\nclass AceCard( BlackjackCard ):\n    __slots__ = ()\n    def __new__( self, rank, suit ):\n        return super().__new__( AceCard, 'A', suit, 1, 11 )\n```", "```py\n>>> timeit.timeit('random.shuffle(x)',\"\"\"\n... import random\n... x=list(range(6*52))\"\"\")\n597.951664149994\n>>>\n>>> timeit.timeit('random.shuffle(d)',\"\"\"\n... from collections import deque\n... import random\n... d=deque(range(6*52))\"\"\")      \n609.9636979339994\n```", "```py\nfrom collections import dequeue\nclass Deck(dequeue):\n    def __init__( self, size=1 ):\n        super().__init__()\n        for d in range(size):\n           cards = [ card(r,s) for r in range(13) for s in Suits ]\n            super().extend( cards )\n        random.shuffle( self )\n```", "```py\n>>> timeit.timeit('x.pop()', \"x=list(range(100000))\", number=100000)\n0.032304395994287916\n>>> timeit.timeit('x.pop()', \"from collections import deque; x=deque(range(100000))\", number=100000)\n0.013504189992090687\n```", "```py\nimport argparse\nimport json\nimport os\nparser = argparse.ArgumentParser(description='Process some integers.')\nparser.add_argument( \"-c\", \"--configuration\", type=open, nargs='?')\nparser.add_argument( \"-p\", \"--playerclass\", type=str, nargs='?', default=\"Simple\" )\ncmdline= parser.parse_args('-p Aggressive'.split())\n\nif cmdline.configuration:\n    config_file= json.load( options.configuration )\n    options.configuration.close()\nelse:\n    config_file= {}\n\nwith open(\"defaults.json\") as installation:\n    defaults= json.load( installation )\n# Might want to check ~/defaults.json and /etc/thisapp/defaults.json, also.\n\nfrom collections import ChainMap\noptions = ChainMap(vars(cmdline), config_file, os.environ, defaults)\n```", "```py\n<blog>\n    <topics> \u2026 </topics> <indices> \u2026 </indices>\n</blog>\n```", "```py\n    <topics>\n        <entry ID=\"UUID98766\"><title>first</title><body>more words</body></entry>\n        <entry ID=\"UUID86543\"><title>second</title><body>words</body></entry>\n        <entry ID=\"UUID64319\"><title>third</title><body>text</body></entry>\n    </topics>\n```", "```py\n    <indices>\n        <bytag>\n            <tag text=\"#sometag\">\n                <entry IDREF=\"UUID98766\"/>\n                <entry IDREF=\"UUID86543\"/>\n            </tag>\n            <tag text=\"#anothertag\">\n                <entry IDREF=\"UUID98766\"/>\n                <entry IDREF=\"UUID64319/>\n\n            </tag>\n        </bytag>\n    </indices>\n```", "```py\nfrom collections import OrderedDict\nimport xml.etree.ElementTree as etree\n\ndoc= etree.XML( source ) # **Parse**\n\ntopics= OrderedDict() # **Gather**\nfor topic in doc.findall( \"topics/entry\" ):\n    topics[topic.attrib['ID']] = topic\n\nfor topic in topics: # **Display**\n    print( topic, topics[topic].find(\"title\").text )\n```", "```py\noutcomes = defaultdict(list)\nself.play_hand( table, hand )\noutcome= self.get_payout()\noutcomes[hand.dealer_card.rank].append(outcome)\n```", "```py\n>>> from collections import defaultdict\n>>> messages = defaultdict( lambda: \"N/A\" )\n>>> messages['error1']= 'Full Error Text'\n>>> messages['other']\n'N/A'\n```", "```py\n>>> [k for k in messages if messages[k] == \"N/A\"]\n['other']\n```", "```py\nfrequency = defaultdict(int)\nfor k in some_iterator():\n    frequency[k] += 1\n```", "```py\nby_value = defaultdict(list)\nfor k in frequency:\n    by_value[ frequency[k] ].append(k)\n```", "```py\nfor freq in sorted(by_value, reverse=True):\n    print( by_value[freq], freq )\n```", "```py\nfrom collections import Counter\nfrequency = Counter(some_iterator())\nfor k,freq in frequency.most_common():\n    print( k, freq )\n```", "```py\n>>> bag1= Counter(\"aardwolves\")\n>>> bag2= Counter(\"zymologies\")\n>>> bag1\nCounter({'a': 2, 'o': 1, 'l': 1, 'w': 1, 'v': 1, 'e': 1, 'd': 1, 's': 1, 'r': 1})\n>>> bag2\nCounter({'o': 2, 'm': 1, 'l': 1, 'z': 1, 'y': 1, 'g': 1, 'i': 1, 'e': 1, 's': 1})\n```", "```py\n>>> bag1+bag2\nCounter({'o': 3, 's': 2, 'l': 2, 'e': 2, 'a': 2, 'z': 1, 'y': 1, 'w': 1, 'v': 1, 'r': 1, 'm': 1, 'i': 1, 'g': 1, 'd': 1})\n```", "```py\n>>> bag1-bag2\nCounter({'a': 2, 'w': 1, 'v': 1, 'd': 1, 'r': 1})\n>>> bag2-bag1\nCounter({'o': 1, 'm': 1, 'z': 1, 'y': 1, 'g': 1, 'i': 1})\n```", "```py\ndef mean( outcomes ):\n    return sum(outcomes)/len(outcomes)\n```", "```py\ndef stdev( outcomes ):\n    n= len(outcomes)\n    return math.sqrt( n*sum(x**2 for x in outcomes)-sum(outcomes)**2 )/n\n```", "```py\nclass Statslist(list):\n    @property\n    def mean(self):\n        return sum(self)/len(self)\n    @property\n    def stdev(self):\n        n= len(self)\n        return math.sqrt( n*sum(x**2 for x in self)-sum(self)**2 )/n\n```", "```py\nfor s in SomePlayStrategy, SomeOtherStrategy:\n    sim = Simulator( s, SimpleBet() )\n    data = sim.run( hands=200 )\n    print( s.__class__.__name__, data.mean, data.stdev )\n```", "```py\nclass StatsList2(list):\n    \"\"\"Eager Stats.\"\"\"\n    def __init__( self, *args, **kw ):\n        self.sum0 = 0 # len(self)\n        self.sum1 = 0 # sum(self)\n        self.sum2 = 0 # sum(x**2 for x in self)\n        super().__init__( *args, **kw )\n        for x in self:\n            self._new(x)\n    def _new( self, value ):\n        self.sum0 += 1\n        self.sum1 += value\n        self.sum2 += value*value\n    def _rmv( self, value ):\n        self.sum0 -= 1\n        self.sum1 -= value\n        self.sum2 -= value*value\n    def insert( self, index, value ):\n        super().insert( index, value )\n        self._new(value)\n    def pop( self, index=0 ):\n        value= super().pop( index )\n        self._rmv(value)\n        return value\n```", "```py\n>>> sl2 = StatsList2( [2, 4, 3, 4, 5, 5, 7, 9, 10] )\n>>> sl2.sum0, sl2.sum1, sl2.sum2\n(9, 49, 325)\n>>> sl2[2]= 4\n>>> sl2.sum0, sl2.sum1, sl2.sum2\n(9, 50, 332)\n>>> del sl2[-1]\n>>> sl2.sum0, sl2.sum1, sl2.sum2\n(8, 40, 232)\n>>> sl2.insert( 0, -1 )\n>>> sl2.pop()                            \n-1\n>>> sl2.sum0, sl2.sum1, sl2.sum2\n(8, 40, 232)\n```", "```py\n    @property\n    def mean(self):\n        return self.sum1/self.sum0\n    @property\n    def stdev(self):\n        return math.sqrt( self.sum0*self.sum2-self.sum1*self.sum1 )/self.sum0\n```", "```py\nclass Explore(list):\n    def __getitem__( self, index ):\n        print( index, index.indices(len(self)) )\n        return super().__getitem__( index )\n```", "```py\n>>> x= Explore('abcdefg')\n>>> x[:]\nslice(None, None, None) (0, 7, 1)\n['a', 'b', 'c', 'd', 'e', 'f', 'g']\n>>> x[:-1]\nslice(None, -1, None) (0, 6, 1)\n['a', 'b', 'c', 'd', 'e', 'f']\n>>> x[1:]\nslice(1, None, None) (1, 7, 1)\n['b', 'c', 'd', 'e', 'f', 'g']\n>>> x[::2]\nslice(None, None, 2) (0, 7, 2)\n['a', 'c', 'e', 'g']\n```", "```py\n    def __setitem__( self, index, value ):\n        if isinstance(index, slice):\n            start, stop, step = index.indices(len(self))\n            olds = [ self[i] for i in range(start,stop,step) ]\n            super().__setitem__( index, value )\n            for x in olds:\n                self._rmv(x)\n            for x in value:\n                self._new(x)\n        else:\n            old= self[index]\n            super().__setitem__( index, value )\n            self._rmv(old)\n            self._new(value)\n```", "```py\n    def __delitem__( self, index ):\n        # Index may be a single integer, or a slice\n        if isinstance(index, slice):\n            start, stop, step = index.indices(len(self))\n            olds = [ self[i] for i in range(start,stop,step) ]\n            super().__delitem__( index )\n            for x in olds:\n                self._rmv(x)\n        else:\n            old= self[index]\n            super().__delitem__( index )\n            self._rmv(old)\n```", "```py\nclass StatsList3:\n    def __init__( self ):\n        self._list= list()\n        self.sum0 = 0 # len(self), sometimes called \"N\"\n        self.sum1 = 0 # sum(self)\n        self.sum2 = 0 # sum(x**2 for x in self)\n    def append( self, value ):\n        self._list.append(value)\n        self.sum0 += 1\n        self.sum1 += value\n        self.sum2 += value*value\n    def __getitem__( self, index ):\n        return self._list.__getitem__( index )\n    @property\n    def mean(self):\n        return self.sum1/self.sum0\n    @property\n    def stdev(self):\n        return math.sqrt( self.sum0*self.sum2-self.sum1*self.sum1 )/self.sum0\n```", "```py\n>>> sl3= StatsList3()\n>>> for data in 2, 4, 4, 4, 5, 5, 7, 9:\n...     sl3.append(data)\n...\n>>> sl3.mean\n5.0\n>>> sl3.stdev   \n2.0\n```", "```py\n>>> sl3[0]\n2\n>>> for x in sl3:\n...     print(x)\n...\n2\n4\n4\n4\n5\n5\n7\n9\n```", "```py\n>>> len(sl3)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: object of type 'StatsList3' has no len()\n```", "```py\n    def __iter__(self):\n        return iter(self._list)\n```", "```py\nfrom collections import Counter\nclass StatsCounter(Counter):\n    @property\n    def mean( self ):\n        sum0= sum( v for k,v in self.items() )\n        sum1= sum( k*v for k,v in self.items() )\n        return sum1/sum0\n    @property\n    def stdev( self ):\n        sum0= sum( v for k,v in self.items() )\n        sum1= sum( k*v for k,v in self.items() )\n        sum2= sum( k*k*v for k,v in self.items() )\n        return math.sqrt( sum0*sum2-sum1*sum1 )/sum0\n```", "```py\n>>> sc = StatsCounter( [2, 4, 4, 4, 5, 5, 7, 9] )\n>>> sc.mean\n5.0\n>>> sc.stdev\n2.0\n>>> sc.most_common(1)\n[(4, 3)]\n>>> list(sorted(sc.elements()))\n[2, 4, 4, 4, 5, 5, 7, 9]\n```", "```py\n    @property\n    def median( self ):\n        all= list(sorted(sc.elements()))\n        return all[len(all)//2]\n```", "```py\n    @property\n    def median( self ):\n        mid = sum(self.values())//2\n        low= 0\n        for k,v in sorted(self.items()):\n            if low <= mid < low+v: return k\n            low += v\n```", "```py\nclass Tree(collections.abc.MutableSet):\n    def __init__( self, iterable=None ):\n        self.root= TreeNode(None)\n        self.size= 0\n        if iterable:\n            for item in iterable:\n                self.root.add( item )\n    def add( self, item ):\n        self.root.add( item )\n        self.size += 1\n    def discard( self, item ):\n        try:\n            self.root.more.remove( item )\n            self.size -= 1\n        except KeyError:\n            pass\n    def __contains__( self, item ):\n        try:\n            self.root.more.find( item )\n            return True\n        except KeyError:\n            return False\n    def __iter__( self ):\n        for item in iter(self.root.more):\n            yield item\n    def __len__( self ):\n        return self.size\n```", "```py\nimport weakref\nclass TreeNode:\n    def __init__( self, item, less=None, more=None, parent=None ):\n        self.item= item\n        self.less= less\n        self.more= more\n        if parent != None:\n            self.parent = parent\n    @property\n    def parent( self ):\n        return self.parent_ref()\n    @parent.setter\n    def parent( self, value ):\n        self.parent_ref= weakref.ref(value)\n    def __repr__( self ):\n        return( \"TreeNode({item!r},{less!r},{more!r})\".format( **self.__dict__ ) )\n    def find( self, item ):\n        if self.item is None: # Root\n            if self.more: return self.more.find(item)\n        elif self.item == item: return self\n        elif self.item > item and self.less: return self.less.find(item)\n        elif self.item < item and self.more: return self.more.find(item)\n        raise KeyError\n    def __iter__( self ):\n        if self.less:\n            for item in iter(self.less):\n                yield item\n        yield self.item\n        if self.more:\n            for item in iter(self.more):\n                yield item\n```", "```py\n    def add( self, item ):\n        if self.item is None: # Root Special Case\n            if self.more:\n                self.more.add( item )\n            else:\n                self.more= TreeNode( item, parent=self )\n        elif self.item >= item:\n            if self.less:\n                self.less.add( item )\n            else:\n                self.less= TreeNode( item, parent=self )\n        elif self.item < item:\n            if self.more:\n                self.more.add( item )\n            else:\n                self.more= TreeNode( item, parent=self )\n```", "```py\n    def remove( self, item ):\n        # Recursive search for node\n        if self.item is None or item > self.item:\n            if self.more:\n                self.more.remove(item)\n            else:\n                raise KeyError\n        elif item < self.item:\n            if self.less:\n                self.less.remove(item)\n            else:\n                raise KeyError\n        else: # self.item == item\n            if self.less and self.more: # Two children are present\n                successor = self.more._least() \n                self.item = successor.item\n                successor.remove(successor.item)\n            elif self.less:   # One child on less\n                self._replace(self.less)\n            elif self.more:  # On child on more\n                self._replace(self.more)\n            else: # Zero children\n                self._replace(None)\n    def _least(self):\n        if self.less is None: return self\n        return self.less._least()\n    def _replace(self,new=None):\n        if self.parent:\n            if self == self.parent.less:\n                self.parent.less = new\n            else:\n                self.parent.more = new\n        if new is not None:\n            new.parent = self.parent\n```", "```py\n>>> s1 = Tree( [\"Item 1\", \"Another\", \"Middle\"] )\n>>> list(s1)\n['Another', 'Item 1', 'Middle']\n>>> len(s1)\n3\n>>> s2 = Tree( [\"Another\", \"More\", \"Yet More\"] )\n>>>\n>>> union= s1|s2\n>>> list(union)\n['Another', 'Another', 'Item 1', 'Middle', 'More', 'Yet More']\n>>> len(union)\n6\n>>> union.remove('Another')\n>>> list(union)\n['Another', 'Item 1', 'Middle', 'More', 'Yet More']\n```", "```py\n>>> import timeit\n>>> timeit.timeit( 'l.remove(10); l.append(10)', 'l = list(range(20))' )\n0.8182099789992208\n>>> timeit.timeit( 'l.remove(10); l.add(10)', 'l = set(range(20))' )\n0.30278149300283985\n```", "```py\n>>> timeit.timeit( 'i= k.index(10); v[i]= 0', 'k=list(range(20)); v=list(range(20))' )\n0.6549435159977293\n>>> timeit.timeit( 'm[10]= 0', 'm=dict(zip(list(range(20)),list(range(20))))' )\n0.0764331009995658\n```", "```py\ndef trace( frame, event, arg ):\n    if frame.f_code.co_name.startswith(\"__\"):\n        print( frame.f_code.co_name, frame.f_code.co_filename, event )\n```", "```py\nimport sys\nsys.settrace(trace)\n```", "```py\nclass noisyfloat( float ):\n    def __add__( self, other ):\n        print( self, \"+\", other )\n        return super().__add__( other )\n    def __radd__( self, other ):\n        print( self, \"r+\", other )\n        return super().__radd__( other )\n```", "```py\n>>> x = noisyfloat(2)\n>>> x+3\n__add__ <stdin> call\n2.0 + 3\n5.0\n>>> 2+x\n__radd__ <stdin> call\n2.0 r+ 2\n4.0\n>>> x+2.3\n__add__ <stdin> call\n2.0 + 2.3\n4.3\n>>> 2.3+x\n__radd__ <stdin> call\n2.0 r+ 2.3\n4.3\n```", "```py\nimport numbers\nimport math\n\nclass FixedPoint( numbers.Rational ):\n    __slots__ = ( \"value\", \"scale\", \"default_format\" )\n    def __new__( cls, value, scale=100 ):\n        self = super().__new__(cls)\n        if isinstance(value,FixedPoint):\n            self.value= value.value\n            self.scale= value.scale\n        elif isinstance(value,int):\n            self.value= value\n            self.scale= scale\n        elif isinstance(value,float):\n            self.value= int(scale*value+.5) # Round half up\n            self.scale= scale\n        else:\n            raise TypeError\n        digits= int( math.log10( scale ) )\n        self.default_format= \"{{0:.{digits}f}}\".format(digits=digits)\n        return self\n    def __str__( self ):\n        return self.__format__( self.default_format )\n    def __repr__( self ):\n        return \"{__class__.__name__:s}({value:d},scale={scale:d})\".format( __class__=self.__class__, value=self.value, scale=self.scale )\n    def __format__( self, specification ):\n        if specification == \"\": specification= self.default_format\n        return specification.format( self.value/self.scale ) # no rounding\n    def numerator( self ):\n        return self.value\n    def denominator( self ):\n        return self.scale\n```", "```py\n    def __add__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_scale= self.scale\n            new_value= self.value + other*self.scale\n        else:\n            new_scale= max(self.scale, other.scale)\n            new_value= (self.value*(new_scale//self.scale)\n            + other.value*(new_scale//other.scale))\n        return FixedPoint( int(new_value), scale=new_scale )\n    def __sub__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_scale= self.scale\n            new_value= self.value - other*self.scale\n        else:\n            new_scale= max(self.scale, other.scale)\n            new_value= (self.value*(new_scale//self.scale)\n            - other.value*(new_scale//other.scale))\n        return FixedPoint( int(new_value), scale=new_scale )\n    def __mul__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_scale= self.scale\n            new_value= self.value * other\n        else:\n            new_scale= self.scale * other.scale\n            new_value= self.value * other.value\n        return FixedPoint( int(new_value), scale=new_scale )\n    def __truediv__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_value= int(self.value / other)\n        else:\n            new_value= int(self.value / (other.value/other.scale))\n        return FixedPoint( new_value, scale=self.scale )\n    def __floordiv__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_value= int(self.value // other)\n        else:\n            new_value= int(self.value // (other.value/other.scale))\n        return FixedPoint( new_value, scale=self.scale )\n    def __mod__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_value= (self.value/self.scale) % other\n        else:\n            new_value= self.value % (other.value/other.scale)\n        return FixedPoint( new_value, scale=self.scale )\n    def __pow__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_value= (self.value/self.scale) ** other\n        else:\n            new_value= (self.value/self.scale) ** (other.value/other.scale)\n        return FixedPoint( int(new_value)*self.scale, scale=self.scale )\n```", "```py\n    def __abs__( self ):\n        return FixedPoint( abs(self.value), self.scale )\n    def __float__( self ):\n        return self.value/self.scale\n    def __int__( self ):\n        return int(self.value/self.scale)\n    def __trunc__( self ):\n        return FixedPoint( math.trunc(self.value/self.scale), self.scale )\n    def __ceil__( self ):\n        return FixedPoint( math.ceil(self.value/self.scale), self.scale )\n    def __floor__( self ):\n        return FixedPoint( math.floor(self.value/self.scale), self.scale )\n    def __round__( self, ndigits ):\n        return FixedPoint( round(self.value/self.scale, ndigits=0), self.scale )\n    def __neg__( self ):\n        return FixedPoint( -self.value, self.scale )\n    def __pos__( self ):\n        return self\n```", "```py\n    def __radd__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_scale= self.scale\n            new_value= other*self.scale + self.value\n        else:\n            new_scale= max(self.scale, other.scale)\n            new_value= (other.value*(new_scale//other.scale)\n            + self.value*(new_scale//self.scale))\n        return FixedPoint( int(new_value), scale=new_scale )\n    def __rsub__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_scale= self.scale\n            new_value= other*self.scale - self.value\n        else:\n            new_scale= max(self.scale, other.scale)\n            new_value= (other.value*(new_scale//other.scale)\n            - self.value*(new_scale//self.scale))\n        return FixedPoint( int(new_value), scale=new_scale )\n    def __rmul__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_scale= self.scale\n            new_value= other*self.value\n        else:\n            new_scale= self.scale*other.scale\n            new_value= other.value*self.value\n        return FixedPoint( int(new_value), scale=new_scale )\n    def __rtruediv__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_value= self.scale*int(other / (self.value/self.scale))\n        else:\n            new_value= int((other.value/other.scale) / self.value)\n        return FixedPoint( new_value, scale=self.scale )\n    def __rfloordiv__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_value= self.scale*int(other // (self.value/self.scale))\n        else:\n            new_value= int((other.value/other.scale) // self.value)\n        return FixedPoint( new_value, scale=self.scale )\n    def __rmod__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_value= other % (self.value/self.scale)\n        else:\n            new_value= (other.value/other.scale) % (self.value/self.scale)\n        return FixedPoint( new_value, scale=self.scale )\n    def __rpow__( self, other ):\n        if not isinstance(other,FixedPoint):\n            new_value= other ** (self.value/self.scale)\n        else:\n            new_value= (other.value/other.scale) ** self.value/self.scale\n        return FixedPoint( int(new_value)*self.scale, scale=self.scale )\n```", "```py\n    def __eq__( self, other ):\n        if isinstance(other, FixedPoint):\n            if self.scale == other.scale:\n                return self.value == other.value\n            else:\n                return self.value*other.scale//self.scale == other.value\n        else:\n            return abs(self.value/self.scale - float(other)) < .5/self.scale\n    def __ne__( self, other ):\n        return not (self == other)\n    def __le__( self, other ):\n        return self.value/self.scale <= float(other)\n    def __lt__( self, other ):\n        return self.value/self.scale <  float(other)\n    def __ge__( self, other ):\n        return self.value/self.scale >= float(other)\n    def __gt__( self, other ):\n        return self.value/self.scale >  float(other)\n```", "```py\n    def __hash__( self ):\n        P = sys.hash_info.modulus\n        m, n = self.value, self.scale\n        # Remove common factors of P.  (Unnecessary if m and n already coprime.)\n        while m % P == n % P == 0:\n            m, n = m // P, n // P\n        if n % P == 0:\n            hash_ = sys.hash_info.inf\n        else:\n            # Fermat's Little Theorem: pow(n, P-1, P) is 1, so\n            # pow(n, P-2, P) gives the inverse of n modulo P.\n            **hash_ = (abs(m) % P) * pow(n, P - 2, P) % P**\n        if m < 0:\n            hash_ = -hash_\n        if hash_ == -1:\n            hash_ = -2\n        return hash_\n```", "```py\n>>> price= FixedPoint( 1299, 100 )\n>>> tax_rate= FixedPoint( 725, 1000 )\n>>> price * tax_rate\nFixedPoint(941775,scale=100000)\n```", "```py\n    def round_to( self, new_scale ):\n        f = new_scale/self.scale\n        return FixedPoint( int(self.value*f+.5), scale=new_scale )\n```", "```py\n>>> price= FixedPoint( 1299, 100 )\n>>> tax_rate= FixedPoint( 725, 1000 )\n>>> tax= price * tax_rate\n>>> tax.round_to(100)\nFixedPoint(942,scale=100)\n```", "```py\n    def __iadd__( self, aCard ):\n        self._cards.append( aCard )\n        return self\n```", "```py\nplayer_hand += deck.pop()\n```", "```py\n@decorate\ndef function():\n    pass\n```", "```py\ndef function():\n    pass\nfunction= decorate( function )\n```", "```py\nclass Angle( float ):\n    __slots__ = ( \"_degrees\", )\n    @staticmethod\n    def from_radians( value ):\n        return Angle(180*value/math.pi)\n    def __new__( cls, value ):\n        self = super().__new__(cls)\n        self._degrees= value\n        return self\n    @property\n    def radians( self ):\n        return math.pi*self._degrees/180\n    @property\n    def degrees( self ):\n        return self._degrees\n```", "```py\n>>> b=Angle.from_radians(.227)\n>>> b.degrees\n13.006141949469686\n```", "```py\nimport functools\n@functools.total_ordering\nclass Card:\n    __slots__ = ( \"rank\", \"suit\" )\n    def __new__( cls, rank, suit ):\n        self = super().__new__(cls)\n        self.rank= rank\n        self.suit= suit\n        return self\n    def __eq__( self, other ):\n        return self.rank == other.rank\n    def __lt__( self, other ):\n        return self.rank < other.rank\n```", "```py\n>>> c1= Card( 3, '\u2660' )\n>>> c2= Card( 3, '\u2665' )\n>>> c1 == c2\nTrue\n>>> c1 < c2\nFalse\n>>> c1 <= c2\nTrue\n>>> c1 >= c2\nTrue\n```", "```py\nclass Deck( list ):\n    def __init__( self, size=1 ):\n        super().__init__()\n        self.rng= random.Random()\n        for d in range(size):\n            cards = [ card(r,s) for r in range(13) for s in Suits ]\n            super().extend( cards )\n        self._init_shuffle()\n    def _init_shuffle( self ):\n        self.rng.shuffle( self )\n```", "```py\nclass TestDeck( ContextDecorator, Deck ):\n    def __init__( self, size= 1, seed= 0 ):\n        super().__init__( size=size )\n        self.seed= seed\n    def _init_shuffle( self ):\n        \"\"\"Don't shuffle during __init__.\"\"\"\n        pass\n    def __enter__( self ):\n        self.rng.seed( self.seed, version=1 )\n        self.rng.shuffle( self )\n        return self\n    def __exit__( self, exc_type, exc_value, traceback ):\n        pass\n```", "```py\nfor i in range(3):\n    d1= Deck(5)\n    print( d1.pop(), d1.pop(), d1.pop() )\n```", "```py\nfor i in range(3):\n    with TestDeck(5, seed=0) as d2:\n        print( d2.pop(), d2.pop(), d2.pop() )\n```", "```py\n_init_shuffle= None\n```", "```py\ntry:\n    self._init_shuffle()\nexcept AttributeError, TypeError:\n    pass\n```", "```py\nlogging.debug( \"function(\", args, kw, \")\" )\nresult= some_function( *args, **kw )\nlogging.debug( \"result = \", result )\nreturn result\n```", "```py\ndef debug( function ):\n    @functools.wraps( function )\n    def logged_function( *args, **kw ):\n        logging.debug( \"%s( %r, %r )\", function.__name__, args, kw, )\n        result= function( *args, **kw )\n        logging.debug( \"%s = %r\", function.__name__, result )\n        return result\n    return logged_function\n```", "```py\n@debug\ndef ackermann( m, n ):\n    if m == 0: return n+1\n    elif m > 0 and n == 0: return ackermann( m-1, 1 )\n    elif m > 0 and n > 0: return ackermann( m-1, ackermann( m, n-1 ) )\n```", "```py\nlogging.basicConfig(stream=sys.stderr, level=logging.DEBUG)\n```", "```py\nDEBUG:root:ackermann( (2, 4), {} )\nDEBUG:root:ackermann( (2, 3), {} )\nDEBUG:root:ackermann( (2, 2), {} )\n.\n.\n.\nDEBUG:root:ackermann( (0, 10), {} )\nDEBUG:root:ackermann = 11\nDEBUG:root:ackermann = 11\nDEBUG:root:ackermann = 11\n```", "```py\ndef debug2( function ):\n    @functools.wraps( function )\n    def logged_function( *args, **kw ):\n        log= logging.getLogger( function.__name__ )\n        log.debug( \"call( %r, %r )\", args, kw, )\n        result= function( *args, **kw )\n        log.debug( \"result %r\", result )\n        return result\n    return logged_function\n```", "```py\nDEBUG:ackermann:call( (2, 4), {} )\nDEBUG:ackermann:call( (2, 3), {} )\nDEBUG:ackermann:call( (2, 2), {} )\n.\n.\n.\nDEBUG:ackermann:call( (0, 10), {} )\nDEBUG:ackermann:result 11\nDEBUG:ackermann:result 11\nDEBUG:ackermann:result 11\n```", "```py\n@decorator(arg)\ndef func( ):\n    pass\n```", "```py\ndef func( ):\n    pass\nfunc= decorator(arg)(func)\n```", "```py\n@debug(\"log_name\")\ndef some_function( args ):\n    pass\n```", "```py\ndef decorator(config):\n    def concrete_decorator(function):\n        @functools.wraps( function )\n        def wrapped( *args, **kw ):\n            return function( *args, ** kw )\n        return wrapped\n    return concrete_decorator\n```", "```py\ndef debug_named(log_name):\n    def concrete_decorator(function):\n        @functools.wraps( function )\n        def wrapped( *args, **kw ):\n            log= logging.getLogger( log_name )\n            log.debug( \"%s( %r, %r )\", function.__name__, args, kw, )\n            result= function( *args, **kw )\n            log.debug( \"%s = %r\", function.__name__, result )\n            return result\n        return wrapped\n    return concrete_decorator\n```", "```py\n@debug_named(\"recursion\")\ndef ackermann( m, n ):\n    if m == 0: return n+1\n    elif m > 0 and n == 0: return ackermann( m-1, 1 )\n    elif m > 0 and n > 0: return ackermann( m-1, ackermann( m, n-1 ) )\n```", "```py\ndef audit( method ):\n    @functools.wraps(method)\n    def wrapper( self, *args, **kw ):\n        audit_log= logging.getLogger( 'audit' )\n        before= repr(self)\n        try:\n            result= method( self, *args, **kw )\n            after= repr(self)\n        except Exception as e:\n           audit_log.exception(\n               '%s before %s\\n after %s', method.__qualname__, before, after )\n           raise\n        audit_log.info(\n               '%s before %s\\n after %s', method.__qualname__, before, after )\n        return result\n    return wrapper\n```", "```py\nclass Hand:\n    def __init__( self, *cards ):\n        self._cards = list(cards)\n    **@audit**\n    def __iadd__( self, card ):\n        self._cards.append( card )\n        return self\n    def __repr__( self ):\n        cards= \", \".join( map(str,self._cards) )\n        return \"{__class__.__name__}({cards})\".format(__class__=self.__class__, cards=cards)\n```", "```py\ntry:\n    before= repr(self)\nexcept AttributeError as e:\n    before= repr(e)\n```", "```py\nclass UglyClass1:\n    def __init__( self ):\n        self.logger= logging.getLogger(self.__class__.__qualname__)\n        self.logger.info( \"New thing\" )\n    def method( self, *args ):\n        self.logger.info( \"method %r\", args )\n```", "```py\nclass UglyClass2:\n    logger= logging.getLogger(\"UglyClass2\")\n    def __init__( self ):\n        self.logger.info( \"New thing\" )\n    def method( self, *args ):\n        self.logger.info( \"method %r\", args )\n```", "```py\ndef logged( class_ ):\n    class_.logger= logging.getLogger( class_.__qualname__ )\n    return class_\n```", "```py\n@logged\nclass SomeClass:\n    def __init__( self ):\n        self.logger.info( \"New thing\" )\n    def method( self, *args ):\n        self.logger.info( \"method %r\", args )\n```", "```py\ndef memento( class_ ):\n    def memento( self ):\n        return \"{0.__class__.__qualname__}({0!r})\".format(self)\n    class_.memento= memento\n    return class_\n```", "```py\n@memento\nclass SomeClass:\n    def __init__( self, value ):\n        self.value= value\n    def __repr__( self ):\n        return \"{0.value}\".format(self)\n```", "```py\nclass Memento:\n    def memento( self ):\n        return \"{0.__class__.__qualname__}({0!r})\".format(self)\n```", "```py\nclass SomeClass2( Memento ):\n    def __init__( self, value ):\n        self.value= value\n    def __repr__( self ):\n        return \"{0.value}\".format(self)\n```", "```py\ndef user_has_feature( feature_name ):\n    def has_feature( user ):\n        return feature_name in (f.name for f in user.feature_set())\n    return user_passes_test( has_feature )\n```", "```py\n@user_has_feature( 'special_bonus' )\ndef bonus_view( request ):\n    pass\n```"]