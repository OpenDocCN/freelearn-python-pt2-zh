["```py\nimport logging\nclass Player:\n    def __init__( self, bet, strategy, stake ):\n        self.logger= logging.getLogger( self.__class__.__qualname__ )\n        self.logger.debug( \"init bet {0}, strategy {1}, stake {2}\".format(\n            bet, strategy, stake) )\n```", "```py\ndef logged( class_ ):\n    class_.logger= logging.getLogger( class_.__qualname__ )\n    return class_\n```", "```py\n@logged\nclass Player:\n    def __init__( self, bet, strategy, stake ):\n        self.logger.debug( \"init bet {0}, strategy {1}, stake {2}\".format(\n            bet, strategy, stake) )\n```", "```py\nimport logging\nimport sys\nlogging.basicConfig( stream=sys.stderr, level=logging.DEBUG )\n```", "```py\n>>> p= Player( 1, 2, 3 )\nDEBUG:Player:init bet 1, strategy 2, stake 3\n```", "```py\nimport sys\nif __name__ == \"__main__\":\n    logging.config.dictConfig( yaml.load(\"log_config.yaml\") )\n    try:\n        application= Main()\n        status= application.run()\n    except Exception as e:\n        logging.exception( e )\n        status= 2\n    finally:\n        logging.shutdown()\n    sys.exit(status)\n```", "```py\nimport atexit\nimport sys\nif __name__ == \"__main__\":\n    logging.config.dictConfig( yaml.load(\"log_config.yaml\") )\n    atexit.register(logging.shutdown)\n    try:\n        application= Main()\n        status= application.run()\n    except Exception as e:\n        logging.exception( e )\n        status= 2\n    sys.exit(status)\n```", "```py\n    import logging\n    logger= logging.getLogger( __name__ )\n    ```", "```py\n    def __init__( self, player_name )\n        self.name= player_name\n        self.logger= logging.getLogger( \"{0}.{1}\".format(\n            self.__class__.__qualname__, player_name ) )\n    ```", "```py\n    def main():\n        log= logging.getLogger(\"main\")\n    ```", "```py\nself.audit_log= logging.getLogger( \"audit.\" + self.__class__.__qualname__ )\n```", "```py\nlogging.addLevelName(15, \"VERBOSE\")\nlogging.VERBOSE= 15\n```", "```py\nself.logger.log( logging.VERBOSE, \"Some Message\" )\n```", "```py\nversion: 1\nhandlers:\n  console:\n    class: logging.StreamHandler\n    stream: ext://sys.stderr\n    formatter: basic\n  audit_file:\n    class: logging.FileHandler\n    filename: p3_c14_audit.log\n    encoding: utf-8\n    formatter: basic\nformatters:\n  basic:\n    style: \"{\"\n    format: \"{levelname:s}:{name:s}:{message:s}\"\nloggers:\n  verbose:\n    handlers: [console]\n    level: INFO\n  audit:\n    handlers: [audit_file]\n    level: INFO\n```", "```py\nimport logging.config\nimport yaml\nconfig_dict= yaml.load(config)\nlogging.config.dictConfig(config_dict)\n```", "```py\nverbose= logging.getLogger( \"verbose.example.SomeClass\" )\naudit= logging.getLogger( \"audit.example.SomeClass\" )\nverbose.info( \"Verbose information\" )\naudit.info( \"Audit record with before and after\" )\n```", "```py\nloggers:\n  verbose:\n    handlers: [console]\n    level: INFO\n    propagate: False # Added\n  audit:\n    handlers: [audit_file]\n    level: INFO\n    propagate: False # Added\nroot: # Added\n  handlers: [console]\n  level: INFO\n```", "```py\ndisable_existing_loggers: False\n```", "```py\nfrom collections import Counter\nclass Main:\n    def __init__( self ):\n        self.balance= Counter()\n        self.log= logging.getLogger( self.__class__.__qualname__ )\n    def run( self ):\n        self.log.info( \"Start\" )\n\n        # Some processing\n        self.balance['count'] += 1\n        self.balance['balance'] += 3.14\n\n        self.log.info( \"Counts {0}\".format(self.balance) )\n\n        for k in self.balance:\n            self.log.info( \"{0:.<16s} {1:n}\".format(\n                k, self.balance[k]) )\n```", "```py\n    for k in balance:\n        self.log.info( \"{0:.<16s} {1:n}\".format(k, balance[k]) )\n```", "```py\nformatters:\n  control:\n    style: \"{\"\n    format: \"{levelname:s}:{message:s}\"\n```", "```py\nhandlers:\n  console:\n    class: logging.StreamHandler\n    stream: ext://sys.stderr\n    formatter: control\n```", "```py\n@logged\nclass OneThreeTwoSix( BettingStrategy ):\n    def __init__( self ):\n        self.wins= 0\n    def _state( self ):\n        return dict( wins= self.wins )\n    def bet( self ):\n        bet= { 0: 1, 1: 3, 2: 2, 3: 6 }[self.wins%4]\n        self.logger.debug( \"Bet {1}; based on {0}\".format(self._state(), bet) )\n    def record_win( self ):\n        self.wins += 1\n        self.logger.debug( \"Win: {0}\".format(self._state()) )\n    def record_loss( self ):\n        self.wins = 0\n        self.logger.debug( \"Loss: {0}\".format(self._state()) )\n```", "```py\nloggers:\n    betting.OneThreeTwoSix:\n       handlers: [console]\n       level: DEBUG\n       propagate: False\n```", "```py\ndef audited( class_ ):\n    class_.logger= logging.getLogger( class_.__qualname__ )\n    class_.audit= logging.getLogger( \"audit.\" + class_.__qualname__ )\n    return class_\n```", "```py\n@audited\nclass Table:\n    def bet( self, bet, amount ):\n        self.audit.info( \"Bet {0} Amount {1}\".format(bet, amount) )\n```", "```py\nhandlers:\n  console:\n    class: logging.StreamHandler\n    stream: ext://sys.stderr\n    formatter: basic\n  audit_file:\n    class: logging.FileHandler\n    filename: p3_c14_audit.log\n    encoding: utf-8\n    formatter: detailed\n```", "```py\nformatters:\n  basic:\n    style: \"{\"\n    format: \"{levelname:s}:{name:s}:{message:s}\"\n  detailed:\n    style: \"{\"\n    format: \"{levelname:s}:{name:s}:{asctime:s}:{message:s}\"\n    datefmt: \"%Y-%m-%d %H:%M:%S\"\n```", "```py\nloggers:\n  audit:\n    handlers: [console,audit_file]\n    level: INFO\n    propagate: True\nroot:\n  handlers: [console]\n  level: INFO\n```", "```py\nINFO:audit.Table:Bet One Amount 1\nINFO:audit.Table:Bet Two Amount 2\n```", "```py\nINFO:audit.Table:2013-12-29 10:24:57:Bet One Amount 1\nINFO:audit.Table:2013-12-29 10:24:57:Bet Two Amount 2\n```", "```py\nimport warnings\nclass Player:\n    __version__= \"2.2\"\n    def bet( self ):\n        warnings.warn( \"bet is deprecated, use place_bet\", DeprecationWarning, stacklevel=2 )\n        etc.\n```", "```py\n>>> warnings.simplefilter(\"always\", category=DeprecationWarning)\n>>> p2= Player()\n>>> p2.bet()\n__main__:4: DeprecationWarning: bet is deprecated, use place_bet\n```", "```py\nimport warnings\ntry:\n    import simulation_model_1 as model\nexcept ImportError as e:\n    warnings.warn( e )\nif 'model' not in globals():\n    try:\n        import simulation_model_2 as model\n    except ImportError as e:\n        warnings.warn( e )\nif 'model' not in globals():\n    raise ImportError( \"Missing simulation_model_1 and simulation_model_2\" )\n```", "```py\nwarnings.warn( e, ImportWarning )\n```", "```py\ntry:\n    with urllib.request.urlopen(\"http://host/resource/\", timeout= 30 ) as resource:\n        content= json.load(resource)\nexcept socket.timeout as e:\n    self.log.warn(\"Missing information from  http://host/resource\")\n    content= []\n```", "```py\nclass TailHandler(logging.handlers.MemoryHandler):\n    def shouldFlush(self, record):\n        \"\"\"\n        Check for buffer full or a record at the flushLevel or higher.\n        \"\"\"\n        if record.levelno >= self.flushLevel: return True\n        while len(self.buffer) >= self.capacity:\n            self.acquire()\n            try:\n                del self.buffer[0]\n            finally:\n                self.release()\n```", "```py\nversion: 1\ndisable_existing_loggers: False\nhandlers:\n  console:\n    class: logging.StreamHandler\n    stream: ext://sys.stderr\n    formatter: basic\n  tail:\n    (): __main__.TailHandler\n    target: cfg://handlers.console\n    capacity: 5\nformatters:\n  basic:\n    style: \"{\"\n    format: \"{levelname:s}:{name:s}:{message:s}\"\nloggers:\n  test:\n    handlers: [tail]\n    level: DEBUG\n    propagate: False\nroot:\n  handlers: [console]\n  level: INFO\n```", "```py\nlogging.config.dictConfig( yaml.load(config8) )\nlog= logging.getLogger( \"test.demo8\" )\n\nprint( \"Last 5 before error\" )\nfor i in range(20):\n    log.debug( \"Message {:d}\".format(i) )\nlog.error( \"Error causes dump of last 5\" )\n\nprint( \"Last 5 before shutdown\" )\nfor i in range(20,40):\n    log.debug( \"Message {:d}\".format(i) )\nlogging.shutdown()\n```", "```py\nLast 5 before error\nDEBUG:test.demo8:Message 16\nDEBUG:test.demo8:Message 17\nDEBUG:test.demo8:Message 18\nDEBUG:test.demo8:Message 19\nERROR:test.demo8:Error causes dump of last 5\nLast 5 before shutdown\nDEBUG:test.demo8:Message 36\nDEBUG:test.demo8:Message 37\nDEBUG:test.demo8:Message 38\nDEBUG:test.demo8:Message 39\n```", "```py\nimport collections\nimport logging\nimport multiprocessing\nclass Log_Consumer_1(multiprocessing.Process):\n    \"\"\"In effect, an instance of QueueListener.\"\"\"\n    def __init__( self, queue ):\n        self.source= queue\n        super().__init__()\n        logging.config.dictConfig( yaml.load(consumer_config) )\n        self.combined= logging.getLogger(\n            \"combined.\" + self.__class__.__qualname__ )\n        self.log= logging.getLogger( self.__class__.__qualname__  )\n        self.counts= collections.Counter()\n    def run( self ):\n        self.log.info( \"Consumer Started\" )\n        while True:\n            log_record= self.source.get()\n            if log_record == None: break\n            self.combined.handle( log_record )\n            words= log_record.getMessage().split()\n            self.counts[words[1]] += 1\n        self.log.info( \"Consumer Finished\" )\n        self.log.info( self.counts )\n```", "```py\nversion: 1\ndisable_existing_loggers: False\nhandlers:\n  console:\n    class: logging.StreamHandler\n    stream: ext://sys.stderr\n    formatter: basic\nformatters:\n  basic:\n    style: \"{\"\n    format: \"{levelname:s}:{name:s}:{message:s}\"\nloggers:\n  combined:\n    handlers: [ console ]\n    formatter: detail\n    level: INFO\n    propagate: False\nroot:\n  handlers: [ console ]\n  level: INFO\n```", "```py\nclass Log_Producer(multiprocessing.Process):\n    handler_class= logging.handlers.QueueHandler\n    def __init__( self, proc_id, queue ):\n        self.proc_id= proc_id\n        self.destination= queue\n        super().__init__()\n **self.log= logging.getLogger(**\n **\"{0}.{1}\".format(self.__class__.__qualname__, self.proc_id) )**\n **self.log.handlers = [ self.handler_class( self.destination ) ]**\n **self.log.setLevel( logging.INFO )**\n    def run( self ):\n        self.log.info( \"Producer {0} Started\".format(self.proc_id) )\n        for i in range(100):\n            self.log.info( \"Producer {:d} Message {:d}\".format(self.proc_id, i) )\n        self.log.info( \"Producer {0} Finished\".format(self.proc_id) )\n```", "```py\nimport multiprocessing\nqueue= multiprocessing.Queue(100)\n```", "```py\nconsumer = Log_Consumer_1( queue )\nconsumer.start()\n```", "```py\nproducers = []\nfor i in range(10):\n    proc= Log_Producer( i, queue )\n    proc.start()\n    producers.append( proc )\n```", "```py\nfor p in producers:\n    p.join()\nqueue.put( None )\nconsumer.join()\n```", "```py\nclass WaitQueueHandler( logging.handlers.QueueHandler ):\n    def enqueue(self, record):\n        self.queue.put( record )\n```", "```py\nclass Log_Producer_2(Log_Producer):\n    handler_class= WaitQueueHandler\n```", "```py\nclass Card:\n    def __init__( self, rank, suit, hard=None, soft=None ):\n        self.rank= rank\n        self.suit= suit\n        self.hard= hard or int(rank)\n        self.soft= soft or int(rank)\n    def __str__( self ):\n        return \"{0.rank!s}{0.suit!s}\".format(self)\n\nclass AceCard( Card ):\n    def __init__( self, rank, suit ):\n        super().__init__( rank, suit, 1, 11 )\n\nclass FaceCard( Card ):\n    def __init__( self, rank, suit ):\n        super().__init__( rank, suit, 10, 10 )\n```", "```py\nSuits = '\u2663', '\u2666', '\u2665', '\u2660'\nclass Deck1( list ):\n    def __init__( self, size=1 ):\n        super().__init__()\n        self.rng= random.Random()\n        for d in range(size):\n            for s in Suits:\n                cards = ([AceCard(1, s)]\n                + [Card(r, s) for r in range(2, 12)]\n                + [FaceCard(r, s) for r in range(12, 14)])\n                super().extend( cards )\n        self.rng.shuffle( self )\n```", "```py\ndef card( rank, suit ):\n    if rank == 1: return AceCard( rank, suit )\n    elif 2 <= rank < 11: return Card( rank, suit )\n    elif 11 <= rank < 14: return FaceCard( rank, suit )\n    else: raise Exception( \"LogicError\" )\n```", "```py\nclass Deck2( list ):\n    def __init__( self, size=1,\n        random=random.Random(),\n        ace_class=AceCard, card_class=Card, face_class=FaceCard ):\n        super().__init__()\n        self.rng= random\n        for d in range(size):\n            for s in Suits:\n                cards =  ([ace_class(1, s)]\n                + [ card_class(r, s) for r in range(2, 12) ]\n                + [ face_class(r, s) for r in range(12, 14) ] )\n                super().extend( cards )\n        self.rng.shuffle( self )\n```", "```py\nclass TestCard( unittest.TestCase ):\n    def setUp( self ):\n        self.three_clubs= Card( 3, '\u2663' )\n    def test_should_returnStr( self ):\n        self.assertEqual( \"3\u2663\", str(self.three_clubs) )\n    def test_should_getAttrValues( self ):\n        self.assertEqual( 3, self.three_clubs.rank )\n        self.assertEqual( \"\u2663\", self.three_clubs.suit )\n        self.assertEqual( 3, self.three_clubs.hard )\n        self.assertEqual( 3, self.three_clubs.soft )\n```", "```py\nclass TestAceCard( unittest.TestCase ):\n    def setUp( self ):\n        self.ace_spades= AceCard( 1, '\u2660' )\n    def test_should_returnStr( self ):\n        self.assertEqual( \"A\u2660\", str(self.ace_spades) )\n    def test_should_getAttrValues( self ):\n        self.assertEqual( 1, self.ace_spades.rank )\n        self.assertEqual( \"\u2660\", self.ace_spades.suit )\n        self.assertEqual( 1, self.ace_spades.hard )\n        self.assertEqual( 11, self.ace_spades.soft )\n```", "```py\ndef suite2():\n    s= unittest.TestSuite()\n    load_from= unittest.defaultTestLoader.loadTestsFromTestCase\n    s.addTests( load_from(TestCard) )\n    s.addTests( load_from(TestAceCard) )\n    s.addTests( load_from(TestFaceCard) )\n    return s\n```", "```py\nif __name__ == \"__main__\":\n    t= unittest.TextTestRunner()\n    t.run( suite2() )\n```", "```py\n...F.F\n======================================================================\nFAIL: test_should_returnStr (__main__.TestAceCard)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"p3_c15.py\", line 80, in test_should_returnStr\n    self.assertEqual( \"A\u2660\", str(self.ace_spades) )\nAssertionError: 'A\u2660' != '1\u2660'\n- A\u2660\n+ 1\u2660\n======================================================================\nFAIL: test_should_returnStr (__main__.TestFaceCard)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"p3_c15.py\", line 91, in test_should_returnStr\n    self.assertEqual( \"Q\u2665\", str(self.queen_hearts) )\nAssertionError: 'Q\u2665' != '12\u2665'\n- Q\u2665\n+ 12\u2665\n\n----------------------------------------------------------------------\nRan 6 tests in 0.001s\n\nFAILED (failures=2)\n```", "```py\nclass TestCardFactory( unittest.TestCase ):\n    def test_rank1_should_createAceCard( self ):\n        c = card( 1, '\u2663' )\n        self.assertIsInstance( c, AceCard )\n    def test_rank2_should_createCard( self ):\n        c = card( 2, '\u2666' )\n        self.assertIsInstance( c, Card )\n    def test_rank10_should_createCard( self ):\n        c = card( 10, '\u2665' )\n        self.assertIsInstance( c, Card )\n    def test_rank10_should_createFaceCard( self ):\n        c = card( 11, '\u2660' )\n        self.assertIsInstance( c, Card )\n    def test_rank13_should_createFaceCard( self ):\n        c = card( 13, '\u2663' )\n        self.assertIsInstance( c, Card )\n    def test_otherRank_should_exception( self ):\n        with self.assertRaises( LogicError ):\n            c = card(14, '\u2666')\n        with self.assertRaises( LogicError ):\n            c = card(0, '\u2666')\n```", "```py\nclass Deck3( list ):\n    def __init__( self, size=1,\n        random=random.Random(),\n        card_factory=card ):\n        super().__init__()\n        self.rng= random\n        for d in range(size):\n            super().extend(\n                 card_factory(r,s) for r in range(1,13) for s in Suits )\n        self.rng.shuffle( self )\n    def deal( self ):\n        try:\n            return self.pop(0)\n        except IndexError:\n            raise DeckEmpty()\n```", "```py\nimport unittest\nimport unittest.mock\n\nclass TestDeckBuid( unittest.TestCase ):\n    def setUp( self ):\n        self.test_card= unittest.mock.Mock( return_value=unittest.mock.sentinel )\n        self.test_rng= random.Random()\n        self.test_rng.shuffle= unittest.mock.Mock( return_value=None )\n    def test_deck_1_should_build(self):\n        d= Deck3( size=1, random=self.test_rng, card_factory= self.test_card )\n        self.assertEqual( 52*[unittest.mock.sentinel], d )\n        self.test_rng.shuffle.assert_called_with( d )\n        self.assertEqual( 52, len(self.test_card.call_args_list) )\n        expected = [\n            unittest.mock.call(r,s)\n                for r in range(1,14)\n                    for s in ('\u2663', '\u2666', '\u2665', '\u2660') ]\n        self.assertEqual( expected, self.test_card.call_args_list )\n```", "```py\nclass TestDeckDeal( unittest.TestCase ):\n    def setUp( self ):\n        self.test_card= unittest.mock.Mock( side_effect=range(52) )\n        self.test_rng= random.Random()\n        self.test_rng.shuffle= unittest.mock.Mock( return_value=None )\n    def test_deck_1_should_deal( self ):\n        d= Deck3( size=1, random=self.test_rng, card_factory= self.test_card )\n        dealt = []\n        for c in range(52):\n            c= d.deal()\n            dealt.append(c)\n        self.assertEqual( dealt, list(range(52)) )\n    def test_empty_deck_should_exception( self ):\n        d= Deck3( size=1, random=self.test_rng, card_factory= self.test_card )\n        for c in range(52):\n            c= d.deal()\n        self.assertRaises( DeckEmpty, d.deal )\n```", "```py\ndef ackermann( m, n ):\n    \"\"\"Ackermann's Function\n    ackermann( m, n ) -> 2\u2191^{m-2}(n+3) - 3\n\n    See http://en.wikipedia.org/wiki/Ackermann_function and\n    http://en.wikipedia.org/wiki/Knuth%27s_up-arrow_notation.\n\n    >>> from p3_c15 import ackermann\n    >>> ackermann(2,4)\n    11\n    >>> ackermann(0,4)\n    5\n    >>> ackermann(1,0)\n    2\n    >>> ackermann(1,1)\n    3\n\n    \"\"\"\n    if m == 0: return n+1\n    elif m > 0 and n == 0: return ackermann( m-1, 1 )\n    elif m > 0 and n > 0: return ackermann( m-1, ackermann( m, n-1 ) )\n```", "```py\n**python3.3 -m doctest p3_c15.py**\n\n```", "```py\n**python3.3 -m doctest -v p3_c15.py**\n\n```", "```py\n**# doctest: +DIRECTIVE**\n\n```", "```py\n**# doctest: -DIRECTIVE**\n\n```", "```py\n>>> sum(values)/len(values)\n3.142857142857143\n```", "```py\n>>> round(sum(values)/len(values),4)\n3.1429\n```", "```py\n    import doctest\n    suite5= doctest.DocTestSuite()\n    t= unittest.TextTestRunner(verbosity=2)\n    t.run( suite5 )\n```", "```py\nsrc\n    __init__.py\n    __main__.py\n    module1.py\n    module2.py\n    setup.py\ntest\n    __init__.py\n    module1.py\n    module2.py\n    all.py\n```", "```py\nimport module1\nimport module2\nimport unittest\nimport doctest\nall_tests= unittest.TestSuite()\nfor mod in module1, module2:\n    all_tests.addTests( mod.suite() )    \n    all_tests.addTests( doctest.DocTestSuite(mod) )\nt= unittest.TextTestRunner()\nt.run( all_tests )\n```", "```py\n**python3.3 -m unittest test/*.py**\n\n```", "```py\nimport os\nclass Test_Missing( unittest.TestCase ):\n    def setUp( self ):\n        try:\n            os.remove( \"p3_c15_sample.csv\" )\n        except OSError as e:\n            pass\n    def test_missingFile_should_returnDefault( self ):\n        self.assertRaises( FileNotFoundError, rounds_final,  \"p3_c15_sample.csv\", )\n```", "```py\nfrom p2_c11 import Base, Blog, Post, Tag, assoc_post_tag\nimport datetime\n\nimport sqlalchemy.exc\nfrom sqlalchemy import create_engine\n\ndef build_test_db( name='sqlite:///./p3_c15_blog.db' ):\n    engine = create_engine(name, echo=True)\n    Base.metadata.drop_all(engine)\n    Base.metadata.create_all(engine)\n    return engine\n```", "```py\nfrom sqlalchemy.orm import sessionmaker\nclass Test_Blog_Queries( unittest.TestCase ):\n    @staticmethod\n    def setUpClass():\n        engine= build_test_db()\n **Test_Blog_Queries.Session = sessionmaker(bind=engine)**\n        session= Test_Blog_Queries.Session()\n\n        tag_rr= Tag( phrase=\"#RedRanger\" )\n        session.add( tag_rr )\n        tag_w42= Tag( phrase=\"#Whitby42\" )\n        session.add( tag_w42 )\n        tag_icw= Tag( phrase=\"#ICW\" )\n        session.add( tag_icw )\n        tag_mis= Tag( phrase=\"#Mistakes\" )\n        session.add( tag_mis )\n\n        blog1= Blog( title=\"Travel 2013\" )\n        session.add( blog1 )\n        b1p1= Post( date=datetime.datetime(2013,11,14,17,25),\n            title=\"Hard Aground\",\n            rst_text=\"\"\"Some embarrassing revelation. Including \u2639 and \u2395\"\"\",\n            blog=blog1,\n            tags=[tag_rr, tag_w42, tag_icw],\n            )\n        session.add(b1p1)\n        b1p2= Post( date=datetime.datetime(2013,11,18,15,30),\n            title=\"Anchor Follies\",\n            rst_text=\"\"\"Some witty epigram. Including \u263a and \u2600\"\"\",\n            blog=blog1,\n            tags=[tag_rr, tag_w42, tag_mis],\n            )\n        session.add(b1p2)\n\n        blog2= Blog( title=\"Travel 2014\" )\n        session.add( blog2 )\n        session.commit()\n```", "```py\n    def setUp( self ):\n        self.session= Test_Blog_Queries.Session()\n\n    def test_query_eqTitle_should_return1Blog( self ):\n        results= self.session.query( Blog ).filter(\n            Blog.title == \"Travel 2013\" ).all()\n        self.assertEqual( 1, len(results) )\n        self.assertEqual( 2, len(**results[0].entries**) )\n\n    def test_query_likeTitle_should_return2Blog( self ):\n        results= self.session.query( Blog ).filter(\n            Blog.title.like(\"Travel %\") ).all()\n        self.assertEqual( 2, len(results) )\n```", "```py\n    def test_query_eqW42_tag_should_return2Post( self ):\n        results= self.session.query(Post)\\\n        .join(assoc_post_tag).join(Tag).filter(\n            Tag.phrase == \"#Whitby42\" ).all()\n        self.assertEqual( 2, len(results) )\n    def test_query_eqICW_tag_should_return1Post( self ):\n        results= self.session.query(Post)\\\n        .join(assoc_post_tag).join(Tag).filter(\n            Tag.phrase == \"#ICW\" ).all()\n        self.assertEqual( 1, len(results) )\n        self.assertEqual( \"Hard Aground\", results[0].title )\n        self.assertEqual( \"Travel 2013\", **results[0].blog.title** )\n        self.assertEqual( set([\"#RedRanger\", \"#Whitby42\", \"#ICW\"]), **set(t.phrase for t in results[0].tags)** )\n```", "```py\nclass RateTimeDistance( dict ):\n    def __init__( self, *args, **kw ):\n        super().__init__( *args, **kw )\n        self._solve()\n    def __getattr__( self, name ):\n        return self.get(name,None)\n    def __setattr__( self, name, value ):\n        self[name]= value\n        self._solve()\n    def __dir__( self ):\n        return list(self.keys())\n    def _solve(self):\n        if self.rate is not None and self.time is not None:\n            self['distance'] = self.rate*self.time\n        elif self.rate is not None and self.distance is not None:\n            self['time'] = self.distance / self.rate\n        elif self.time is not None and self.distance is not None:\n            self['rate'] = self.distance / self.time\n```", "```py\nself.assertAlmostEqual( object.distance, object.rate * object.time )\n```", "```py\ndef validate( self, object ):self.assertAlmostEqual( object.distance, object.rate * object.time )\n```", "```py\nfrom p1_c03 import RateTimeDistance\n```", "```py\nrate_in,time_in,distance_in,rate_out,time_out,distance_out\n2,3,,2,3,6\n5,,7,5,1.4,7\n,11,13,1.18,11,13\n```", "```py\ndef float_or_none( text ):\n    if len(text) == 0: return None\n    return float(text)\n\nclass Test_RTD( unittest.TestCase ):\n    def __init__( self, rate_in,time_in,distance_in,\n        rate_out,time_out,distance_out ):\n        super().__init__()\n        self.args = dict( rate=float_or_none(rate_in),\n            time=float_or_none(time_in),\n            distance=float_or_none(distance_in) )\n        self.result= dict( rate=float_or_none(rate_out),\n            time=float_or_none(time_out),\n            distance=float_or_none(distance_out) )\n    def shortDescription( self ):\n        return \"{0} -> {1}\".format(self.args, self.result)\n    def setUp( self ):\n        self.rtd= RateTimeDistance( **self.args )\n    def runTest( self ):\n        self.assertAlmostEqual( self.rtd.distance, self.rtd.rate*self.rtd.time )\n        self.assertAlmostEqual( self.rtd.rate, self.result['rate'] )\n        self.assertAlmostEqual( self.rtd.time, self.result['time'] )\n        self.assertAlmostEqual( self.rtd.distance, self.result['distance'] )\n```", "```py\nimport csv\ndef suite9():\n    suite= unittest.TestSuite()\n    with open(\"p3_c15_data.csv\",\"r\",newline=\"\") as source:\n        rdr= csv.DictReader( source )\n        for row in rdr:\n            suite.addTest( Test_RTD(**row) )\n    return suite\n```", "```py\n    t= unittest.TextTestRunner()\n    t.run( suite9() )\n```", "```py\n..F\n======================================================================\nFAIL: runTest (__main__.Test_RTD)\n{'rate': None, 'distance': 13.0, 'time': 11.0} -> {'rate': 1.18, 'distance': 13.0, 'time': 11.0}\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"p3_c15.py\", line 504, in runTest\n    self.assertAlmostEqual( self.rtd.rate, self.result['rate'] )\nAssertionError: 1.1818181818181819 != 1.18 within 7 places\n\n----------------------------------------------------------------------\nRan 3 tests in 0.000s\n\nFAILED (failures=1)\n```", "```py\nimport unittest\nimport timeit\nclass Test_Performance( unittest.TestCase ):\n    def test_simpleCalc_shouldbe_fastEnough( self ):\n        t= timeit.timeit(\n        stmt=\"\"\"RateTimeDistance( rate=1, time=2 )\"\"\",\n        setup=\"\"\"from p1_c03 import RateTimeDistance\"\"\"\n        )\n        print( \"Run time\", t )\n        self.assertLess( t, 10, \"run time {0} >= 10\".format(t) )\n```", "```py\n**#!/usr/bin/env python3.3**\n\n```", "```py\nparser = argparse.ArgumentParser( description=\"Simulate Blackjack\" )\n```", "```py\nconfig= parser.parse_args()\n```", "```py\nparser.add_argument( '-v', '--verbose', action='store_true', default=False )\n```", "```py\nparser.add_argument( '--debug', action='store_const', const=logging.DEBUG, default=logging.INFO, dest=\"logging_level\" )\n```", "```py\nparser.add_argument( \"-b\", \"--bet\", action=\"store\", default=\"Flat\", choices=[\"Flat\", \"Martingale\", \"OneThreeTwoSix\"], dest='betting_rule')\nparser.add_argument( \"-s\", \"--stake\", action=\"store\", default=50, type=int )\n```", "```py\nparser.add_argument( \"input_filename\", action=\"store\" )\nparser.add_argument( \"output_filename\", action=\"store\" )\n```", "```py\nparser.add_argument( \"filenames\", action=\"store\", nargs=\"*\", metavar=\"file...\" )\n```", "```py\nfor filename in config.filenames:\n    process( filename )\n```", "```py\nfor filename in config.filenames:\n    if filename == '-':\n        process(sys.stdin)\n    else:\n        with open(filename) as input:\n            process(input)\n```", "```py\nparser.add_argument( \"-V\", \"--version\", action=\"version\", version=__version__ )\n```", "```py\n    parser.add_argument( \"--samples\", action=\"store\",\n        **default=int(os.environ.get(\"SIM_SAMPLES\",100)),**\n        type=int, help=\"Samples to generate\" )\n    ```", "```py\n    config4= argparse.Namespace()\n    config4.samples= int(os.environ.get(\"SIM_SAMPLES\",100))\n    config4a= parser.parse_args( namespace=config4 )\n    ```", "```py\nenv_values= [\n    (\"attribute_name\", os.environ.get( \"SOMEAPP_VARNAME\", None )),\n    (\"another_name\", os.environ.get( \"SOMEAPP_OTHER\", None )),\n    etc.\n]\n```", "```py\nconfig_name= \"someapp.yaml\"\nconfig_locations = (\n        os.path.curdir,\n        os.path.expanduser(\"~/\"),\n        \"/etc\",\n        os.path.expanduser(\"~thisapp/\"), # or thisapp.__file__,\n)\ncandidates = ( os.path.join(dir,config_name)\n   for dir in config_locations )\nconfig_names = ( name for name in candidates if os.path.exists(name) )\nfiles_values = [yaml.load(file) for file in config_names]\n```", "```py\ndefaults= ChainMap( dict( (k,v) for k,v in env_values if v is not None ), *files_values )\n```", "```py\nconfig= parser.parse_args( namespace=argparse.Namespace( **defaults ) )\n```", "```py\ndefaults= ChainMap( *files_values )\ndefaults.maps.append( dict( (k,v) for k,v in env_values if v is not None ) )\n```", "```py\nconfig= parser.parse_args( namespace=argparse.Namespace( **defaults ) )\n```", "```py\ndef nint( x ):\n    if x is None: return x\n    return int(x)\n```", "```py\nenv_values= [\n    ('samples', nint(os.environ.get(\"SIM_SAMPLES\", None)) ),\n    ('stake', nint(os.environ.get( \"SIM_STAKE\", None )) ),\n    ('rounds', nint(os.environ.get( \"SIM_ROUNDS\", None )) ),\n]\n```", "```py\nusage: p3_c16.py [-v] [--debug] [--dealerhit {Hit17,Stand17}]\n                 [--resplit {ReSplit,NoReSplit,NoReSplitAces}] [--decks DECKS]\n                 [--limit LIMIT] [--payout PAYOUT]\n                 [-p {SomeStrategy,AnotherStrategy}]\n                 [-b {Flat,Martingale,OneThreeTwoSix}] [-r ROUNDS] [-s STAKE]\n                 [--samples SAMPLES] [-V] [-?]\n                 output\n\nSimulate Blackjack\n\npositional arguments:\n  output\n\noptional arguments:\n  -v, --verbose\n  --debug\n  --dealerhit {Hit17,Stand17}\n  --resplit {ReSplit,NoReSplit,NoReSplitAces}\n  --decks DECKS\n  --limit LIMIT\n  --payout PAYOUT\n  -p {SomeStrategy,AnotherStrategy}, --playerstrategy {SomeStrategy,AnotherStrategy}\n  -b {Flat,Martingale,OneThreeTwoSix}, --bet {Flat,Martingale,OneThreeTwoSix}\n  -r ROUNDS, --rounds ROUNDS\n  -s STAKE, --stake STAKE\n  --samples SAMPLES\n  -V, --version         show program's version number and exit\n  -?, --help\n```", "```py\nimport ast\nimport csv\ndef simulate_blackjack( config ):\n    dealer_rule= {'Hit17': Hit17, 'Stand17': Stand17,\n  }[config.dealer_rule]()\n    split_rule= {'ReSplit': ReSplit,\n  'NoReSplit': NoReSplit, 'NoReSplitAces':NoReSplitAces,\n  }[config.split_rule]()\n    try:\n       payout= ast.literal_eval( config.payout )\n       assert len(payout) == 2\n    except Exception as e:\n       raise Exception( \"Invalid payout {0}\".format(config.payout) ) from e\n    table= Table( decks=config.decks, limit=config.limit, dealer=dealer_rule,\n        split=split_rule, payout=payout )\n    player_rule= {'SomeStrategy': SomeStrategy,\n  'AnotherStrategy': AnotherStrategy,\n  }[config.player_rule]()\n    betting_rule= {\"Flat\":Flat,\n  \"Martingale\":Martingale, \"OneThreeTwoSix\":OneThreeTwoSix,\n  }[config.betting_rule]()\n    player= Player( play=player_rule, betting=betting_rule,\n        rounds=config.rounds, stake=config.stake )\n    simulate= Simulate( table, player, config.samples )\n    with open(config.outputfile, \"w\", newline=\"\") as target:\n        wtr= csv.writer( target )\n        **wtr.writerows( simulate )**\n\n```", "```py\nif __name__ == \"__main__\":\n        logging.config.dictConfig( yaml.load(\"logging.config\") )\n    config5= gather_configuration()\n    simulate_blackjack( config5 )\n    logging.shutdown()\n```", "```py\ndealer_rule_map = { \"Hit17\": Hit17, \"Stand17\", Stand17 }\n```", "```py\nparser.add_argument( \"--dealerhit\", action=\"store\", default=\"Hit17\", choices=dealer_rule_map.keys(), dest='dealer_rule')\n```", "```py\ndealer_rule= dealer_rule_map[config.dealer_rule]()\n```", "```py\ndealer_rule_map = { \"H17\": Hit17, \"S17\": Stand17 }\n```", "```py\nif __name__ == \"__main__\":\n    with Logging_Config():\n        with Application_Config() as config:\n            simulate_blackjack( config )\n```", "```py\nclass Logging_Config:\n    def __enter__( self, filename=\"logging.config\" ):\n       logging.config.dictConfig( yaml.load(filename) )\n    def __exit__( self, *exc ):\n       logging.shutdown()\n\nclass Application_Config:\n    def __enter__( self ):\n        # Build os.environ defaults.\n        # Load files.\n        # Build ChainMap from environs and files.\n        # Parse command-line arguments.\n        return namespace\n    def __exit__( self, *exc ):\n        pass\n```", "```py\nclass Command:\n    def set_config( self, config ):\n        self.__dict__.update( config.__dict__ )\n    config= property( fset=set_config )\n    def run( self ):\n        pass\n```", "```py\n    main= SomeCommand()\n    main.config= config\n    main.run()\n```", "```py\nclass Simulate_Command( Command ):\n    dealer_rule_map = {\"Hit17\": Hit17, \"Stand17\": Stand17}\n    split_rule_map = {'ReSplit': ReSplit,\n        'NoReSplit': NoReSplit, 'NoReSplitAces': NoReSplitAces}\n    player_rule_map = {'SomeStrategy': SomeStrategy,\n        'AnotherStrategy': AnotherStrategy}\n    betting_rule_map = {\"Flat\": Flat,\n        \"Martingale\": Martingale, \"OneThreeTwoSix\": OneThreeTwoSix}\n\n    def run( self ):\n        dealer_rule= self.dealer_rule_map[self.dealer_rule]()\n        split_rule= self.split_rule_map[self.split_rule]()\n        try:\n           payout= ast.literal_eval( self.payout )\n           assert len(payout) == 2\n        except Exception as e:\n           raise Exception( \"Invalid payout {0}\".format(self.payout) ) from e\n        table= Table( decks=self.decks, limit=self.limit, dealer=dealer_rule,\n            split=split_rule, payout=payout )\n        player_rule= self.player_rule_map[self.player_rule]()\n        betting_rule= self.betting_rule_map[self.betting_rule]()\n        player= Player( play=player_rule, betting=betting_rule,\n            rounds=self.rounds, stake=self.stake )\n        simulate= Simulate( table, player, self.samples )\n        with open(self.outputfile, \"w\", newline=\"\") as target:\n            wtr= csv.writer( target )\n            wtr.writerows( simulate )\n```", "```py\nif __name__ == \"__main__\":\n    with Logging_Config():\n        with Application_Config() as config:    \n            main= Simulate_Command()\n            main.config= config\n            main.run()\n```", "```py\nclass Analyze_Command( Command ):\n    def run( self ):\n        with open(self.outputfile, \"r\", newline=\"\") as target:\n            rdr= csv.reader( target )\n            outcomes= ( float(row[10]) for row in rdr )\n            first= next(outcomes)\n            sum_0, sum_1 = 1, first\n            value_min = value_max = first\n            for value in outcomes:\n                sum_0 += 1 # value**0\n                sum_1 += value # value**1\n                value_min= min( value_min, value )\n                value_max= max( value_max, value )\n            mean= sum_1/sum_0\n            print(\n        \"{4}\\nMean = {0:.1f}\\nHouse Edge = {1:.1%}\\nRange = {2:.1f} {3:.1f}\".format(\n        mean, 1-mean/50, value_min, value_max, self.outputfile) )\n```", "```py\nparser.add_argument( \"command\", action=\"store\", default='simulate', choices=['simulate', 'analyze'] )\nparser.add_argument( \"outputfile\", action=\"store\", metavar=\"output\" )\n```", "```py\n{'simulate': Simulate_Command, 'analyze': Analyze_Command}[options.command]\n```", "```py\n    simulate_and_analyze = [Simulate(), Analyze()]\n```", "```py\nclass Command_Sequence(Command):\n    sequence = []\n    def __init__( self ):\n        self._sequence = [ class_() for class_ in self.sequence ]\n    def set_config( self, config ):\n        for step in self._sequence:\n            step.config= config\n    config= property( fset=set_config )\n    def run( self ):\n        for step in self._sequence:\n            step.run()\n```", "```py\nclass Simulate_and_Analyze(Command_Sequence):\n    sequence = [Simulate_Command, Analyze_Command]\n```", "```py\nparser.add_argument( \"command\", action=\"store\", default='simulate', choices=['simulate', 'analyze', 'simulate_analyze'] )\n```", "```py\n{'simulate': Simulate_Command, 'analyze': Analyze_Command, 'simulate_analyze': Simulate_and_Analyze}[options.command]\n```", "```py\nclass ForAllBets_Simulate( Command ):\n    def run( self ):\n        for bet_class in \"Flat\", \"Martingale\", \"OneThreeTwoSix\":\n            self.betting_rule= bet_class\n            self.outputfile= \"p3_c16_simulation7_{0}.dat\".format(bet_class)\n            sim= Simulate_Command()\n            sim.config= self\n            sim.run()\n```", "```py\nif __name__ == \"__main__\":\n    main()\n```", "```py\nif __name__ == \"__main__\":\n    with Logging_Config():\n        with Application_Config() as config:    \n            main= Simulate_Command()\n            main.config= config\n            main.run()\n```", "```py\n#!/usr/bin/env python3.3\n```", "```py\n# -*- coding: utf-8 -*-\n```", "```py\n__version__ = \"2.7.18\"\n```", "```py\n__all__ = [\"Deck\", \"Shoe\"]\nclass Suit:\n    etc.\nsuits = [ Suit(\"\u2663\"), Suit(\"\u2662\"), Suit(\"\u2661\"), Suit(\"\u2660\") ]\nclass Card:\n    etc.\ndef card( rank, suit ):\n    etc.\nclass Deck:\n    etc.\nclass Shoe( Deck ):\n    etc.\n```", "```py\nfrom cards import *\t\n```", "```py\nimport cards\n```", "```py\n    import package.module\n    ```", "```py\n    import package\n    ```", "```py\n    import package\n    ```", "```py\n\"\"\"Blackjack package\"\"\"\nfrom blackjack.cards import Shoe\nfrom blackjack.player import Strategy_1, Strategy_2\nfrom blackjack.casino import ReSplit, NoReSplit, NoReSplitAces,  Hit17, Stand17\nfrom blackjack.simulator import Table, Player, Simulate\nfrom betting import Flat, Martingale, OneThreeTwoSix\n```", "```py\n**from blackjack import ***\ntable= Table( decks=6, limit=500, dealer=Hit17(),\n        split=NoReSplitAces(), payout=(3,2)  )\nplayer= Player( play=Strategy_1(),  betting=Martingale(), rounds=100, stake=100 )\nsimulate= Simulate( table, player, 100 )\nfor result in simulate:\n    print( result )\n```", "```py\nimport platform\nbits, linkage = platform.architecture()\nif bits == '64bit':\n    from some_algorithm.long_version import *\nelse:\n    from some_algorithm.short_version import *\n```", "```py\nimport some_algorithm\nprocess= some_algorithm.SomeClass()\n```", "```py\ntry:\n    from some_algorithm.long_version import *\nexcept ImportError as e:\n    from some_algorithm.short_version import *\n```", "```py\n#!/usr/bin/env python3.3\n```", "```py\nimport simulation\nwith simulation.Logging_Config():\n   with simulation.Application_Config() as config:    \n       main= simulation.Simulate_Command()\n       main.config= config\n       main.run()\n```", "```py\nimport simulation\nwith simulation.Logging_Config():\n   with simulation.Application_Config() as config:    \n       main= simulation.Simulate_Command()\n       main.config= config\n       main.run()\n```", "```py\npython3.3 -m stats -c 10 some_file.csv\n```", "```py\nimport stats\nimport simulation\nimport types\ndef sim_and_analyze():\n    with simulation.Application_Config() as config_sim:\n        config_sim.outputfile= \"some_file.csv\" s = simulation.Simulate()\n        s.run()\n    config_stats= types.SimpleNamespace( column=10, input=\"some_file.csv\" )\n    stats.analyze( config_stats )\n```", "```py\ndef analyze( column, filename ):\n    import subprocess\n    subprocess.check_call( \"python3.3 -m stats -c {0} {1}\".format(\n        column, filename) )\n```", "```py\nroot= Tkinter.Tk()\napp= Application(root)\nroot.mainloop()\n```", "```py\nhttpd = make_server('', 8080, debug)\nhttpd.serve_forever()\n```", "```py\nPYTHONPATH=my_app python3.3 -m test\n```", "```py\nexport PYTHONPATH=~/my_app-v1.2/my_app\n```", "```py\n/Users/myapp/my_app-v1.2/my_app\n/Users/myapp/my_app-v1.3/my_app\n```", "```py\nround(...)\n    round(number[, ndigits]) -> number\n\n    Round a number to a given precision in decimal digits (default 0 digits).\n    This returns an int when called with one argument, otherwise the\n    same type as the number. ndigits may be negative.\n```", "```py\npydoc somemodule\n```", "```py\npython3.3 -m pydoc somemodule\n```", "```py\npython3.3 -m pydoc -w somemodule\n```", "```py\npython3.3 -m pydoc -p 8080\n```", "```py\npython3.3 -m pydoc -b\n```", "```py\nThis Is A Heading\n=================\n```", "```py\nBullet Lists\n\n-   Leading Special Character.\n\n-   Consistent Indent.\n```", "```py\nNumber Lists\n\n1\\.  Leading digit or letter.\n\n2\\.  Auto-numbering with #.\n\n#.  Looks like this.\n```", "```py\nHere's a paragraph with a cool quote.\n\n    Cool quotes might include a tip.\n\nHere's another paragraph.\n```", "```py\n::\n\n    x = Deck()\n    first_card= x.pop()\n\nThis shows two lines of code. It will be distinguished from surrounding text.\n```", "```py\n>>> x= Unsorted_Deck()\n>>> x.pop()\n'A\u2663'\n```", "```pyliteral```", "```py\n..  image:: media/some_file.png\n    :width: 6in\n```", "```py\n..  csv-table:: Suits\n    :header: symbol, name\n\n    \"'\u2663'\", Clubs\n    \"'\u2666'\", Diamonds\n    \"'\u2665'\", Hearts\n    \"'\u2660'\", Spades\n```", "```py\n..  math::\n    c = 2 \\pi r\n```", "```py\nHere's an example::\n\n    d= Deck()\n    c= d.pop()\n```", "```py\nBlackjack Cards and Decks\n=========================\n\nThis module contains a definition of ``Card``, ``Deck`` and ``Shoe`` suitable for Blackjack.\n\nThe ``Card`` class hierarchy\n-----------------------------\n\nThe ``Card`` class hierarchy includes the following class definitions.\n\n``Card`` is the superclass as well as being the class for number cards.\n``FaceCard`` defines face cards: J, Q and K.\n``AceCard`` defines the Ace. This is special in Blackjack because it creates a soft total for a hand.\n\nWe create cards using the ``card()`` factory function to create the proper\n``Card`` subclass instances from a rank and suit.\n\nThe ``suits`` global variable is a sequence of Suit instances.\n>>> import cards\n>>> ace_clubs= cards.card( 1, cards.suits[0] )\n>>> ace_clubs\n'A\u2663'\n>>> ace_diamonds= cards.card( 1, cards.suits[1] )\n>>> ace_clubs.rank ==  ace_diamonds.rank\nTrue\n\nThe ``Deck`` and ``Shoe`` class hierarchy\n-------------------------------------------\n\nThe basic ``Deck`` creates a single 52-card deck. The ``Shoe`` subclass creates a given number of decks. A ``Deck`` can be shuffled before the cards can be extracted with the ``pop()`` method. A ``Shoe`` must be shuffled and *burned*. The burn operation sequesters a random number of cards based on a mean and standard deviation. The mean is a number of cards (52 is the default.) The standard deviation for the burn is also given as a number of cards (2 is the default.)\n```", "```py\n:field1: some value\n:field2: another value\n```", "```py\nfield1\tsome value\nfield2\tanother value\n```", "```py\n:param rank: Numeric rank of the card\n:param suit: Suit of the card\n```", "```py\n:type rank: integer in the range 1-13.\n```", "```py\n:returns: soft total for this card\n:rtype: integer\n```", "```py\n:raises TypeError: rank value not in range(1, 14).\n```", "```py\n:ivar soft: soft points for this card; usually hard points, except for aces.\n:ivar hard: hard points for this card; usually the rank, except for face cards.\n```", "```py\nclass Card:\n    \"\"\"Definition of a numeric rank playing card.\n    Subclasses will define ``FaceCard`` and ``AceCard``.\n\n    :ivar rank: Rank\n    :ivar suit: Suit\n    :ivar hard: Hard point total for a card\n    :ivar soft: Soft total; same as hard for all cards except Aces.\n    \"\"\"\n    def __init__( self, rank, suit, hard, soft=None ):\n        \"\"\"Define the values for this card.\n\n        :param rank: Numeric rank in the range 1-13.\n        :param suit: Suit object (often a character from '\u2663\u2661\u2662\u2660')\n        :param hard: Hard point total (or 10 for FaceCard or 1 for AceCard)\n        :param soft: The soft total for AceCard, otherwise defaults to hard.\n        \"\"\"\n        self.rank= rank\n        self.suit= suit\n        self.hard= hard\n        self.soft= soft if soft is not None else hard\n```", "```py\ndef card( rank, suit ):\n    \"\"\"Create a ``Card`` instance from rank and suit.\n\n    :param rank: Numeric rank in the range 1-13.\n    :param suit: Suit object (often a character from '\u2663\u2661\u2662\u2660')\n    :returns: Card instance\n    :raises TypeError: rank out of range.\n\n    >>> import p3_c18\n    >>> p3_c18.card( 3, '\u2661' )\n    3\u2661\n    \"\"\"\n    if rank == 1: return AceCard( rank, suit, 1, 11 )\n    elif 2 <= rank < 11: return Card( rank, suit, rank )\n    elif 11 <= rank < 14: return FaceCard( rank, suit, 10 )\n    else:\n        raise TypeError( 'rank out of range' )\n```", "```py\nEnter the root path for documentation.\n**> Root path for the documentation [.]: doc**\n\n```", "```py\nYou have two options for placing the build directory for Sphinx output.\nEither, you use a directory \"_build\" within the root path, or you separate\n\"source\" and \"build\" directories within the root path.\n**> Separate source and build directories (y/N) [n]: y**\n\n```", "```py\nPlease indicate if you want to use one of the following Sphinx extensions:\n```", "```py\n**> autodoc: automatically insert docstrings from modules (y/N) [n]: y**\n\n```", "```py\n**> doctest: automatically test code snippets in doctest blocks (y/N) [n]: y**\n\n```", "```py\n> intersphinx: link between Sphinx documentation of different projects (y/N) [n]:\n```", "```py\n> todo: write \"todo\" entries that can be shown or hidden on build (y/N) [n]:\n```", "```py\n> coverage: checks for documentation coverage (y/N) [n]:\n```", "```py\n**> pngmath: include math, rendered as PNG images (y/N) [n]: y**\n> mathjax: include math, rendered in the browser by MathJax (y/N) [n]:\n```", "```py\n> ifconfig: conditional inclusion of content based on config values (y/N) [n]:\n```", "```py\n**> viewcode: include links to the source code of documented Python objects (y/N) [n]: y**\n\n```", "```py\n.. Mastering OO Python documentation master file, created by\n   sphinx-quickstart on Fri Jan 31 09:21:55 2014.\n   You can adapt this file completely to your liking, but it should at least\n   contain the root `toctree` directive.\n\nWelcome to Mastering OO Python's documentation!\n===============================================\n\nContents:\n\n.. toctree::\n   :maxdepth: 2\n\n   user_stories\n logical\n process\n implementation\n physical\n\nIndices and tables\n==================\n* :ref:`genindex`\n* :ref:`modindex`\n* :ref:`search`\n```", "```py\nmake doctest html\n```", "```py\nImplementation\n================\n\nHere's a reference to the `inception document <_static/inception_doc/index.html>`_\n\nThe p3_c18 module\n-----------------------\n\n..  automodule:: p3_c18\n    :members:\n    :undoc-members:\n    :special-members:\n\nThe simulation_model module\n--------------------------------\n\n..  automodule:: simulation_model\n    :members:\n    :undoc-members:\n    :special-members:\n```", "```pySomeClass```", "```py\ndef card( rank, suit ):\n    \"\"\"Create a :py:class:`Card` instance from rank and suit.\n\n    :param rank: Numeric rank in the range 1-13.\n    :param suit: Suit object (often a character from '\u2663\u2661\u2662\u2660')\n    :returns: :py:class:`Card` instance\n    :raises :py:exc:`TypeError`: rank out of range.\n    Etc.\n    \"\"\"\n```", "```pyCard```", "```py\n#############\nCombinations\n#############\n\n..  contents::\n\nDefinition\n==========\n\nFor some deeper statistical calculations,\nwe need the number of combinations of *n* things\ntaken *k* at a time, :math:`\\binom{n}{k}`.\n\n..  math::\n\n    \\binom{n}{k} = \\dfrac{n!}{k!(n-k)!}\n\nThe function will use an internal ``fact()`` function because\nwe don't need factorial anywhere else in the application.\n\nWe'll rely on a simplistic factorial function without memoization.\n\nTest Case\n=========\n\nHere are two simple unit tests for this function provided\nas doctest examples.\n\n>>> from combo import combinations\n>>> combinations(4,2)\n6\n>>> combinations(8,4)\n70\n\nImplementation\n===============\nHere's the essential function definition, with docstring:\n::\n\n  def combinations( n, k ):\n      \"\"\"Compute :math:`\\binom{n}{k}`, the number of\n      combinations of *n* things taken *k* at a time.\n\n      :param n: integer size of population\n      :param k: groups within the population\n      :returns: :math:`\\binom{n}{k}`\n      \"\"\"\n\nAn important consideration here is that someone hasn't confused\nthe two argument values.\n::\n\n      assert k <= n\n\nHere's the embedded factorial function. It's recursive. The Python\nstack limit is a limitation on the size of numbers we can use.\n::\n\n      def fact(a):\n          if a == 0: return 1\n          return a*fact(a-1)\n\nHere's the final calculation. Note that we're using integer division.\nOtherwise, we'd get an unexpected conversion to float.\n::\n\n      return fact(n)//( fact(k)*fact(n-k) )\n```", "```py\n    python3.3 -m pylit combo.py.txt\n    ```", "```py\n    rst2html.py combo.py.txt combo.py.html\n    ```", "```py\n    python3.3 -m pylit --doctest combo.py.txt\n    ```"]