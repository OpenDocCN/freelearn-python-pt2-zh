["```py\nimport asyncio\n\n@asyncio.coroutine\ndef sleeper():\n    yield from asyncio.sleep(1)\n```", "```py\nasync def some_coroutine():\n    pass\n```", "```py\nimport asyncio\n\n@asyncio.coroutine\ndef some_coroutine():\n    pass\n```", "```py\nimport asyncio\n\nasync def sleeper():\n    await asyncio.sleep(1)\n```", "```py\n**>>> import asyncio**\n\n**>>> async def sleeper(delay):**\n**...     await asyncio.sleep(delay)**\n**...     print('Finished sleeper with delay: %d' % delay)**\n\n**>>> loop = asyncio.get_event_loop()**\n**>>> results = loop.run_until_complete(asyncio.wait((**\n**...     sleeper(1),**\n**...     sleeper(3),**\n**...     sleeper(2),**\n**... )))**\n**Finished sleeper with delay: 1**\n**Finished sleeper with delay: 2**\n**Finished sleeper with delay: 3**\n\n```", "```py\n**>>> import asyncio**\n\n**>>> async def sleeper(delay):**\n**...     await asyncio.sleep(delay)**\n**...     print('Finished sleeper with delay: %d' % delay)**\n\n**# Create an event loop**\n**>>> loop = asyncio.get_event_loop()**\n\n**# Create the task**\n**>>> result = loop.call_soon(loop.create_task, sleeper(1))**\n\n**# Make sure the loop stops after 2 seconds**\n**>>> result = loop.call_later(2, loop.stop)**\n\n**# Start the loop and make it run forever. Or at least until the loop.stop gets**\n**# called in 2 seconds.**\n**>>> loop.run_forever()**\n**Finished sleeper with delay: 1**\n\n```", "```py\n**>>> import asyncio**\n\n**>>> async def stack_printer():**\n**...     for task in asyncio.Task.all_tasks():**\n**...         task.print_stack()**\n\n**# Create an event loop**\n**>>> loop = asyncio.get_event_loop()**\n\n**# Create the task**\n**>>> result = loop.run_until_complete(stack_printer())**\n\n```", "```py\nimport asyncio\n\nloop = asyncio.ProActorEventLoop()\nasyncio.set_event_loop(loop)\n```", "```py\nimport sys\nimport selectors\n\ndef read(fh):\n    print('Got input from stdin: %r' % fh.readline())\n\nif __name__ == '__main__':\n    # Create the default selector\n    selector = selectors.DefaultSelector()\n\n    # Register the read function for the READ event on stdin\n    selector.register(sys.stdin, selectors.EVENT_READ, read)\n\n    while True:\n        for key, mask in selector.select():\n            # The data attribute contains the read function here\n            callback = key.data\n            # Call it with the fileobj (stdin here)\n            callback(key.fileobj)\n```", "```py\nimport asyncio\nimport selectors\n\nselector = selectors.SelectSelector()\nloop = asyncio.SelectorEventLoop(selector)\nasyncio.set_event_loop(loop)\n```", "```py\nimport asyncio\n\nclass ProActorEventLoopPolicy(\n        asyncio.events.BaseDefaultEventLoopPolicy):\n    _loop_factory = asyncio.SelectorEventLoop\n\npolicy = ProActorEventLoopPolicy()\nasyncio.set_event_loop_policy(policy)\n```", "```py\n**>>> import time**\n**>>> import asyncio**\n\n**>>> t = time.time()**\n\n**>>> def printer(name):**\n**...     print('Started %s at %.1f' % (name, time.time() - t))**\n**...     time.sleep(0.2)**\n**...     print('Finished %s at %.1f' % (name, time.time() - t))**\n\n**>>> loop = asyncio.get_event_loop()**\n**>>> result = loop.call_at(loop.time() + .2, printer, 'call_at')**\n**>>> result = loop.call_later(.1, printer, 'call_later')**\n**>>> result = loop.call_soon(printer, 'call_soon')**\n**>>> result = loop.call_soon_threadsafe(printer, 'call_soon_threadsafe')**\n\n**>>> # Make sure we stop after a second**\n**>>> result = loop.call_later(1, loop.stop)**\n\n**>>> loop.run_forever()**\n**Started call_soon at 0.0**\n**Finished call_soon at 0.2**\n**Started call_soon_threadsafe at 0.2**\n**Finished call_soon_threadsafe at 0.4**\n**Started call_later at 0.4**\n**Finished call_later at 0.6**\n**Started call_at at 0.6**\n**Finished call_at at 0.8**\n\n```", "```py\n**>>> import time**\n**>>> import asyncio**\n\n**>>> t = time.time()**\n\n**>>> async def printer(name):**\n**...     print('Started %s at %.1f' % (name, time.time() - t))**\n**...     await asyncio.sleep(0.2)**\n**...     print('Finished %s at %.1f' % (name, time.time() - t))**\n\n**>>> loop = asyncio.get_event_loop()**\n\n**>>> result = loop.call_at(**\n**...     loop.time() + .2, loop.create_task, printer('call_at'))**\n**>>> result = loop.call_later(.1, loop.create_task,**\n**...     printer('call_later'))**\n**>>> result = loop.call_soon(loop.create_task,**\n**...     printer('call_soon'))**\n\n**>>> result = loop.call_soon_threadsafe(**\n**...     loop.create_task, printer('call_soon_threadsafe'))**\n\n**>>> # Make sure we stop after a second**\n**>>> result = loop.call_later(1, loop.stop)**\n\n**>>> loop.run_forever()**\n**Started call_soon at 0.0**\n**Started call_soon_threadsafe at 0.0**\n**Started call_later at 0.1**\n**Started call_at at 0.2**\n**Finished call_soon at 0.2**\n**Finished call_soon_threadsafe at 0.2**\n**Finished call_later at 0.3**\n**Finished call_at at 0.4**\n\n```", "```py\n**>>> import time**\n**>>> import subprocess**\n**>>>**\n**>>>**\n**>>> t = time.time()**\n**>>>**\n**>>>**\n**>>> def process_sleeper():**\n**...     print('Started sleep at %.1f' % (time.time() - t))**\n**...     process = subprocess.Popen(['sleep', '0.1'])**\n**...     process.wait()**\n**...     print('Finished sleep at %.1f' % (time.time() - t))**\n**...**\n**>>>**\n**>>> for i in range(3):**\n**...     process_sleeper()**\n**Started sleep at 0.0**\n**Finished sleep at 0.1**\n**Started sleep at 0.1**\n**Finished sleep at 0.2**\n**Started sleep at 0.2**\n**Finished sleep at 0.3**\n\n```", "```py\n**>>> import time**\n**>>> import subprocess\u2029**\n\n**>>> t = time.time()**\n\n**>>> def process_sleeper():**\n**...     print('Started sleep at %.1f' % (time.time() - t))**\n**...     return subprocess.Popen(['sleep', '0.1'])**\n**...**\n**>>>**\n**>>> processes = []**\n**>>> for i in range(5):**\n**...     processes.append(process_sleeper())**\n**Started sleep at 0.0**\n**Started sleep at 0.0**\n**Started sleep at 0.0**\n**Started sleep at 0.0**\n**Started sleep at 0.0**\n\n**>>> for process in processes:**\n**...     returncode = process.wait()**\n**...     print('Finished sleep at %.1f' % (time.time() - t))**\n**Finished sleep at 0.1**\n**Finished sleep at 0.1**\n**Finished sleep at 0.1**\n**Finished sleep at 0.1**\n**Finished sleep at 0.1**\n\n```", "```py\n**>>> import time**\n**>>> import asyncio**\n\n**>>> t = time.time()**\n\n**>>> async def async_process_sleeper():**\n**...     print('Started sleep at %.1f' % (time.time() - t))**\n**...     process = await asyncio.create_subprocess_exec('sleep', '0.1')**\n**...     await process.wait()**\n**...     print('Finished sleep at %.1f' % (time.time() - t))**\n\n**>>> loop = asyncio.get_event_loop()**\n**>>> for i in range(5):**\n**...     task = loop.create_task(async_process_sleeper())**\n\n**>>> future = loop.call_later(.5, loop.stop)**\n\n**>>> loop.run_forever()**\n**Started sleep at 0.0**\n**Started sleep at 0.0**\n**Started sleep at 0.0**\n**Started sleep at 0.0**\n**Started sleep at 0.0**\n**Finished sleep at 0.1**\n**Finished sleep at 0.1**\n**Finished sleep at 0.1**\n**Finished sleep at 0.1**\n**Finished sleep at 0.1**\n\n```", "```py\nimport asyncio\n\nasync def run_script():\n    process = await asyncio.create_subprocess_shell(\n        'python3',\n        stdout=asyncio.subprocess.PIPE,\n        stdin=asyncio.subprocess.PIPE,\n    )\n\n    # Write a simple Python script to the interpreter\n    process.stdin.write(b'\\n'.join((\n        b'import math',\n        b'x = 2 ** 8',\n        b'y = math.sqrt(x)',\n        b'z = math.sqrt(y)',\n        b'print(\"x: %d\" % x)',\n        b'print(\"y: %d\" % y)',\n        b'print(\"z: %d\" % z)',\n        b'for i in range(int(z)):',\n        b'    print(\"i: %d\" % i)',\n    )))\n    # Make sure the stdin is flushed asynchronously\n    await process.stdin.drain()\n    # And send the end of file so the Python interpreter will\n    # start processing the input. Without this the process will\n    # stall forever.\n    process.stdin.write_eof()\n\n    # Fetch the lines from the stdout asynchronously\n    async for out in process.stdout:\n        # Decode the output from bytes and strip the whitespace\n        # (newline) at the right\n        print(out.decode('utf-8').rstrip())\n\n    # Wait for the process to exit\n    await process.wait()\n\nif __name__ == '__main__':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(run_script())\n    loop.close()\n```", "```py\n**# python3 processes.py**\n**x: 256**\n**y: 16**\n**z: 4**\n**i: 0**\n**i: 1**\n**i: 2**\n**i: 3**\n\n```", "```py\nimport time\nimport sys\nimport asyncio\n\nHOST = '127.0.0.1'\nPORT = 1234\n\nstart_time = time.time()\n\ndef printer(start_time, *args, **kwargs):\n    '''Simple function to print a message prefixed with the\n    time relative to the given start_time'''\n    print('%.1f' % (time.time() - start_time), *args, **kwargs)\n\nasync def handle_connection(reader, writer):\n    client_address = writer.get_extra_info('peername')\n    printer(start_time, 'Client connected', client_address)\n\n    # Send over the server start time to get consistent\n    # timestamps\n    writer.write(b'%.2f\\n' % start_time)\n    await writer.drain()\n\n    repetitions = int((await reader.readline()))\n    printer(start_time, 'Started sending to', client_address)\n\n    for i in range(repetitions):\n        message = 'client: %r, %d\\n' % (client_address, i)\n        printer(start_time, message, end='')\n        writer.write(message.encode())\n        await writer.drain()\n\n    printer(start_time, 'Finished sending to', client_address)\n    writer.close()\n\nasync def create_connection(repetitions):\n    reader, writer = await asyncio.open_connection(\n        host=HOST, port=PORT)\n\n    start_time = float((await reader.readline()))\n\n    writer.write(repetitions.encode() + b'\\n')\n    await writer.drain()\n\n    async for line in reader:\n        # Sleeping a little to emulate processing time and make\n        # it easier to add more simultaneous clients\n        await asyncio.sleep(1)\n\n        printer(start_time, 'Got line: ', line.decode(),\n                end='')\n\n    writer.close()\n\nif __name__ == '__main__':\n    loop = asyncio.get_event_loop()\n\n    if sys.argv[1] == 'server':\n        server = asyncio.start_server(\n            handle_connection,\n            host=HOST,\n            port=PORT,\n        )\n        running_server = loop.run_until_complete(server)\n\n        try:\n            result = loop.call_later(5, loop.stop)\n            loop.run_forever()\n        except KeyboardInterrupt:\n            pass\n\n        running_server.close()\n        loop.run_until_complete(running_server.wait_closed())\n    elif sys.argv[1] == 'client':\n        loop.run_until_complete(create_connection(sys.argv[2]))\n\n    loop.close()\n```", "```py\n**# python3 simple_connections.py server**\n**0.4 Client connected ('127.0.0.1', 59990)**\n**0.4 Started sending to ('127.0.0.1', 59990)**\n**0.4 client: ('127.0.0.1', 59990), 0**\n**0.4 client: ('127.0.0.1', 59990), 1**\n**0.4 client: ('127.0.0.1', 59990), 2**\n**0.4 Finished sending to ('127.0.0.1', 59990)**\n**2.0 Client connected ('127.0.0.1', 59991)**\n**2.0 Started sending to ('127.0.0.1', 59991)**\n**2.0 client: ('127.0.0.1', 59991), 0**\n**2.0 client: ('127.0.0.1', 59991), 1**\n**2.0 Finished sending to ('127.0.0.1', 59991)**\n\n```", "```py\n**# python3 simple_connections.py client 3**\n**1.4 Got line:  client: ('127.0.0.1', 59990), 0**\n**2.4 Got line:  client: ('127.0.0.1', 59990), 1**\n**3.4 Got line:  client: ('127.0.0.1', 59990), 2**\n\n```", "```py\n**# python3 simple_connections.py client 2**\n**3.0 Got line:  client: ('127.0.0.1', 59991), 0**\n**4.0 Got line:  client: ('127.0.0.1', 59991), 1**\n\n```"]