["```py\n**>>> class Spam(object):**\n**>>>     eggs = 'my eggs'**\n\n**>>> Spam = type('Spam', (object,), dict(eggs='my eggs'))**\n\n```", "```py\n**>>> class Spam(object):**\n**...     eggs = 'my eggs'**\n\n**>>> spam = Spam()**\n**>>> spam.eggs**\n**'my eggs'**\n**>>> type(spam)**\n**<class '\u2026Spam'>**\n**>>> type(Spam)**\n**<class 'type'>**\n\n**>>> Spam = type('Spam', (object,), dict(eggs='my eggs'))**\n\n**>>> spam = Spam()**\n**>>> spam.eggs**\n**'my eggs'**\n**>>> type(spam)**\n**<class '...Spam'>**\n**>>> type(Spam)**\n**<class 'type'>**\n\n```", "```py\n**class Spam(object):**\n **pass**\n\n```", "```py\n**class Spam(object, metaclass=type):**\n **pass**\n\n```", "```py\n**# The metaclass definition, note the inheritance of type instead**\n**# of object**\n**>>> class MetaSpam(type):**\n**...**\n**...     # Notice how the __new__ method has the same arguments**\n**...     # as the type function we used earlier?**\n**...     def __new__(metaclass, name, bases, namespace):**\n**...         name = 'SpamCreatedByMeta'**\n**...         bases = (int,) + bases**\n**...         namespace['eggs'] = 1**\n**...         return type.__new__(metaclass, name, bases, namespace)**\n\n**# First, the regular Spam:**\n**>>> class Spam(object):**\n**...     pass**\n\n**>>> Spam.__name__**\n**'Spam'**\n**>>> issubclass(Spam, int)**\n**False**\n**>>> Spam.eggs**\n**Traceback (most recent call last):**\n **...**\n**AttributeError: type object 'Spam' has no attribute 'eggs'**\n\n**# Now the meta-Spam**\n**>>> class Spam(object, metaclass=MetaSpam):**\n**...     pass**\n\n**>>> Spam.__name__**\n**'SpamCreatedByMeta'**\n**>>> issubclass(Spam, int)**\n**True**\n**>>> Spam.eggs**\n**1**\n\n```", "```py\n**>>> class MetaWithArguments(type):**\n**...     def __init__(metaclass, name, bases, namespace, **kwargs):**\n**...         # The kwargs should not be passed on to the**\n**...         # type.__init__**\n**...         type.__init__(metaclass, name, bases, namespace)**\n**...**\n**...     def __new__(metaclass, name, bases, namespace, **kwargs):**\n**...         for k, v in kwargs.items():**\n**...             namespace.setdefault(k, v)**\n**...**\n**...         return type.__new__(metaclass, name, bases, namespace)**\n\n**>>> class WithArgument(metaclass=MetaWithArguments, spam='eggs'):**\n**...     pass**\n\n**>>> with_argument = WithArgument()**\n**>>> with_argument.spam**\n**'eggs'**\n\n```", "```py\n**>>> class Meta(type):**\n**...**\n**...     @property**\n**...     def spam(cls):**\n**...         return 'Spam property of %r' % cls**\n**...**\n**...     def eggs(self):**\n**...         return 'Eggs method of %r' % self**\n\n**>>> class SomeClass(metaclass=Meta):**\n**...     pass**\n\n**>>> SomeClass.spam**\n**\"Spam property of <class '...SomeClass'>\"**\n**>>> SomeClass().spam**\n**Traceback (most recent call last):**\n **...**\n**AttributeError: 'SomeClass' object has no attribute 'spam'**\n\n**>>> SomeClass.eggs()**\n**\"Eggs method of <class '...SomeClass'>\"**\n**>>> SomeClass().eggs()**\n**Traceback (most recent call last):**\n **...**\n**AttributeError: 'SomeClass' object has no attribute 'eggs'**\n\n```", "```py\n**>>> import abc**\n\n**>>> class Spam(metaclass=abc.ABCMeta):**\n**...**\n**...     @abc.abstractmethod**\n**...     def some_method(self):**\n**...         raise NotImplemented()**\n\n**>>> class Eggs(Spam):**\n**...     def some_new_method(self):**\n**...         pass**\n\n**>>> eggs = Eggs()**\n**Traceback (most recent call last):**\n **...**\n**TypeError: Can't instantiate abstract class Eggs with abstract**\n**methods some_method**\n\n**>>> class Bacon(Spam):**\n**...     def some_method():**\n**...         pass**\n\n**>>> bacon = Bacon()**\n\n```", "```py\n**>>> import abc**\n\n**>>> class Spam(object, metaclass=abc.ABCMeta):**\n**...     @property**\n**...     @abc.abstractmethod**\n**...     def some_property(self):**\n**...         raise NotImplemented()**\n**...**\n**...     @classmethod**\n**...     @abc.abstractmethod**\n**...     def some_classmethod(cls):**\n**...         raise NotImplemented()**\n**...**\n**...     @staticmethod**\n**...     @abc.abstractmethod**\n**...     def some_staticmethod():**\n**...         raise NotImplemented()**\n**...**\n**...     @abc.abstractmethod**\n**...     def some_method():**\n**...         raise NotImplemented()**\n\n```", "```py\n**some_method.__isabstractmethod__ = True**\n\n```", "```py\n**>>> class AbstractMeta(type):**\n**...     def __new__(metaclass, name, bases, namespace):**\n**...         cls = super().__new__(metaclass, name, bases, namespace)**\n**...         cls.__abstractmethods__ = frozenset(('something',))**\n**...         return cls**\n\n**>>> class Spam(metaclass=AbstractMeta):**\n**...     pass**\n\n**>>> eggs = Spam()**\n**Traceback (most recent call last):**\n **...**\n**TypeError: Can't instantiate abstract class Spam with ...**\n\n```", "```py\n**>>> import functools**\n\n**>>> class AbstractMeta(type):**\n**...     def __new__(metaclass, name, bases, namespace):**\n**...         # Create the class instance**\n**...         cls = super().__new__(metaclass, name, bases, namespace)**\n**...**\n**...         # Collect all local methods marked as abstract**\n**...         abstracts = set()**\n**...         for k, v in namespace.items():**\n**...             if getattr(v, '__abstract__', False):**\n**...                 abstracts.add(k)**\n**...**\n**...         # Look for abstract methods in the base classes and add**\n**...         # them to the list of abstracts**\n**...         for base in bases:**\n**...             for k in getattr(base, '__abstracts__', ()):**\n**...                 v = getattr(cls, k, None)**\n**...                 if getattr(v, '__abstract__', False):**\n**...                     abstracts.add(k)**\n**...**\n**...         # store the abstracts in a frozenset so they cannot be**\n**...         # modified**\n**...         cls.__abstracts__ = frozenset(abstracts)**\n**...**\n**...         # Decorate the __new__ function to check if all abstract**\n**...         # functions were implemented**\n**...         original_new = cls.__new__**\n**...         @functools.wraps(original_new)**\n**...         def new(self, *args, **kwargs):**\n**...             for k in self.__abstracts__:**\n**...                 v = getattr(self, k)**\n**...                 if getattr(v, '__abstract__', False):**\n**...                     raise RuntimeError(**\n**...                         '%r is not implemented' % k)**\n**...**\n**...             return original_new(self, *args, **kwargs)**\n**...**\n**...         cls.__new__ = new**\n**...         return cls**\n\n**>>> def abstractmethod(function):**\n**...     function.__abstract__ = True**\n**...     return function**\n\n**>>> class Spam(metaclass=AbstractMeta):**\n**...     @abstractmethod**\n**...     def some_method(self):**\n**...         pass**\n\n**# Instantiating the function, we can see that it functions as the**\n**# regular ABCMeta does**\n**>>> eggs = Spam()**\n**Traceback (most recent call last):**\n **...**\n**RuntimeError: 'some_method' is not implemented**\n\n```", "```py\n**>>> import abc**\n\n**>>> class CustomList(abc.ABC):**\n**...     'This class implements a list-like interface'**\n**...     pass**\n\n**>>> CustomList.register(list)**\n**<class 'list'>**\n\n**>>> issubclass(list, CustomList)**\n**True**\n**>>> isinstance([], CustomList)**\n**True**\n**>>> issubclass(CustomList, list)**\n**False**\n**>>> isinstance(CustomList(), list)**\n**False**\n\n```", "```py\n**>>> import abc**\n\n**>>> class CustomList(abc.ABC, list):**\n**...     'This class implements a list-like interface'**\n**...     pass**\n\n**>>> CustomList.register(list)**\n**Traceback (most recent call last):**\n **...**\n**RuntimeError: Refusing to create an inheritance cycle**\n\n```", "```py\n**>>> import abc**\n\n**>>> class UniversalClass(abc.ABC):**\n**...    @classmethod**\n**...    def __subclasshook__(cls, subclass):**\n**...        return True**\n\n**>>> issubclass(list, UniversalClass)**\n**True**\n**>>> issubclass(bool, UniversalClass)**\n**True**\n**>>> isinstance(True, UniversalClass)**\n**True**\n**>>> issubclass(UniversalClass, bool)**\n**False**\n\n```", "```py\nimport abc\n\nclass ABC(metaclass=abc.ABCMeta):\n    pass\n```", "```py\n**>>> import abc**\n\n**>>> class Plugins(abc.ABCMeta):**\n**...     plugins = dict()**\n**...**\n**...     def __new__(metaclass, name, bases, namespace):**\n**...         cls = abc.ABCMeta.__new__(metaclass, name, bases,**\n**...                                   namespace)**\n**...         if isinstance(cls.name, str):**\n**...             metaclass.plugins[cls.name] = cls**\n**...         return cls**\n**...**\n**...     @classmethod**\n**...     def get(cls, name):**\n**...         return cls.plugins[name]**\n\n**>>> class PluginBase(metaclass=Plugins):**\n**...     @property**\n**...     @abc.abstractmethod**\n**...     def name(self):**\n**...         raise NotImplemented()**\n\n**>>> class SpamPlugin(PluginBase):**\n**...     name = 'spam'**\n\n**>>> class EggsPlugin(PluginBase):**\n**...     name = 'eggs'**\n\n**>>> Plugins.get('spam')**\n**<class '...SpamPlugin'>**\n**>>> Plugins.plugins**\n**{'spam': <class '...SpamPlugin'>,**\n **'eggs': <class '...EggsPlugin'>}**\n\n```", "```py\n# plugins/__init__.py\nfrom .base import Plugin\nfrom .base import Plugins\n\n__all__ = ['Plugin', 'Plugins']\n```", "```py\n# plugins/base.py\nimport abc\n\nclass Plugins(abc.ABCMeta):\n    plugins = dict()\n\n    def __new__(metaclass, name, bases, namespace):\n        cls = abc.ABCMeta.__new__(\n            metaclass, name, bases, namespace)\n        if isinstance(cls.name, str):\n            metaclass.plugins[cls.name] = cls\n        return cls\n\n    @classmethod\n    def get(cls, name):\n        return cls.plugins[name]\n\nclass Plugin(metaclass=Plugins):\n    @property\n    @abc.abstractmethod\n    def name(self):\n        raise NotImplemented()\n```", "```py\nfrom . import base\n\nclass Spam(base.Plugin):\n    name = 'spam'\n```", "```py\nfrom . import base\n\nclass Eggs(base.Plugin):\n    name = 'eggs'\n```", "```py\nimport abc\nimport importlib\n\nclass Plugins(abc.ABCMeta):\n    plugins = dict()\n\n    def __new__(metaclass, name, bases, namespace):\n        cls = abc.ABCMeta.__new__(\n            metaclass, name, bases, namespace)\n        if isinstance(cls.name, str):\n            metaclass.plugins[cls.name] = cls\n        return cls\n\n    @classmethod\n    def get(cls, name):\n        if name not in cls.plugins:\n            print('Loading plugins from plugins.%s' % name)\n            importlib.import_module('plugins.%s' % name)\n        return cls.plugins[name]\n```", "```py\n**>>> import plugins**\n**>>> plugins.Plugins.get('spam')**\n**Loading plugins from plugins.spam**\n**<class 'plugins.spam.Spam'>**\n\n**>>> plugins.Plugins.get('spam')**\n**<class 'plugins.spam.Spam'>**\n\n```", "```py\nimport abc\nimport importlib\n\nclass Plugins(abc.ABCMeta):\n    plugins = dict()\n\n    def __new__(metaclass, name, bases, namespace):\n        cls = abc.ABCMeta.__new__(\n            metaclass, name, bases, namespace)\n        if isinstance(cls.name, str):\n            metaclass.plugins[cls.name] = cls\n        return cls\n\n    @classmethod\n    def get(cls, name):\n        return cls.plugins[name]\n\n    @classmethod\n    def load(cls, *plugin_modules):\n        for plugin_module in plugin_modules:\n            plugin = importlib.import_module(plugin_module)\n```", "```py\n**>>> import plugins**\n\n**>>> plugins.Plugins.load(**\n**...     'plugins.spam',**\n**...     'plugins.eggs',**\n**... )**\n\n**>>> plugins.Plugins.get('spam')**\n**<class 'plugins.spam.Spam'>**\n\n```", "```py\nimport os\nimport re\nimport abc\nimport importlib\n\nMODULE_NAME_RE = re.compile('[a-z][a-z0-9_]*', re.IGNORECASE)\n\nclass Plugins(abc.ABCMeta):\n    plugins = dict()\n\n    def __new__(metaclass, name, bases, namespace):\n        cls = abc.ABCMeta.__new__(\n            metaclass, name, bases, namespace)\n        if isinstance(cls.name, str):\n            metaclass.plugins[cls.name] = cls\n        return cls\n\n    @classmethod\n    def get(cls, name):\n        return cls.plugins[name]\n\n    @classmethod\n    def load_directory(cls, module, directory):\n        for file_ in os.listdir(directory):\n            name, ext = os.path.splitext(file_)\n            full_path = os.path.join(directory, file_)\n            import_path = [module]\n            if os.path.isdir(full_path):\n                import_path.append(file_)\n            elif ext == '.py' and MODULE_NAME_RE.match(name):\n                import_path.append(name)\n            else:\n                # Ignoring non-matching files/directories\n                continue\n\n            plugin = importlib.import_module('.'.join(import_path))\n\n    @classmethod\n    def load(cls, **plugin_directories):\n        for module, directory in plugin_directories.items():\n            cls.load_directory(module, directory)\n```", "```py\n**>>> import functools**\n\n**>>> def decorator(name):**\n**...     def _decorator(cls):**\n**...         @functools.wraps(cls)**\n**...         def __decorator(*args, **kwargs):**\n**...             print('decorator(%s)' % name)**\n**...             return cls(*args, **kwargs)**\n**...         return __decorator**\n**...     return _decorator**\n\n**>>> class SpamMeta(type):**\n**...**\n**...     @decorator('SpamMeta.__init__')**\n**...     def __init__(self, name, bases, namespace, **kwargs):**\n**...         print('SpamMeta.__init__()')**\n**...         return type.__init__(self, name, bases, namespace)**\n**...**\n**...     @staticmethod**\n**...     @decorator('SpamMeta.__new__')**\n**...     def __new__(cls, name, bases, namespace, **kwargs):**\n**...         print('SpamMeta.__new__()')**\n**...         return type.__new__(cls, name, bases, namespace)**\n**...**\n**...     @classmethod**\n**...     @decorator('SpamMeta.__prepare__')**\n**...     def __prepare__(cls, names, bases, **kwargs):**\n**...         print('SpamMeta.__prepare__()')**\n**...         namespace = dict(spam=5)**\n**...         return namespace**\n\n**>>> @decorator('Spam')**\n**... class Spam(metaclass=SpamMeta):**\n**...**\n**...     @decorator('Spam.__init__')**\n**...     def __init__(self, eggs=10):**\n**...         print('Spam.__init__()')**\n**...         self.eggs = eggs**\n**decorator(SpamMeta.__prepare__)**\n**SpamMeta.__prepare__()**\n**decorator(SpamMeta.__new__)**\n**SpamMeta.__new__()**\n**decorator(SpamMeta.__init__)**\n**SpamMeta.__init__()**\n\n**# Testing with the class object**\n**>>> spam = Spam**\n**>>> spam.spam**\n**5**\n**>>> spam.eggs**\n**Traceback (most recent call last):**\n **...**\n**AttributeError: ... object has no attribute 'eggs'**\n\n**# Testing with a class instance**\n**>>> spam = Spam()**\n**decorator(Spam)**\n**decorator(Spam.__init__)**\n**Spam.__init__()**\n**>>> spam.spam**\n**5**\n**>>> spam.eggs**\n**10**\n\n```", "```py\n**>>> import itertools**\n\n**>>> class Field(object):**\n**...     counter = itertools.count()**\n**...**\n**...     def __init__(self, name=None):**\n**...         self.name = name**\n**...         self.index = next(Field.counter)**\n**...**\n**...     def __repr__(self):**\n**...         return '<%s[%d] %s>' % (**\n**...             self.__class__.__name__,**\n**...             self.index,**\n**...             self.name,**\n**...         )**\n\n**>>> class FieldsMeta(type):**\n**...     def __new__(metaclass, name, bases, namespace):**\n**...         cls = type.__new__(metaclass, name, bases, namespace)**\n**...         fields = []**\n**...         for k, v in namespace.items():**\n**...             if isinstance(v, Field):**\n**...                 fields.append(v)**\n**...                 v.name = v.name or k**\n**...**\n**...         cls.fields = sorted(fields, key=lambda f: f.index)**\n**...         return cls**\n\n**>>> class Fields(metaclass=FieldsMeta):**\n**...     spam = Field()**\n**...     eggs = Field()**\n\n**>>> Fields.fields**\n**[<Field[0] spam>, <Field[1] eggs>]**\n\n**>>> fields = Fields()**\n**>>> fields.eggs.index**\n**1**\n**>>> fields.spam.index**\n**0**\n**>>> fields.fields**\n**[<Field[0] spam>, <Field[1] eggs>]**\n\n```", "```py\n>>> import collections\n\n>>> class Field(object):\n...     def __init__(self, name=None):\n...         self.name = name\n...\n...     def __repr__(self):\n...         return '<%s %s>' % (\n...             self.__class__.__name__,\n...             self.name,\n...         )\n\n>>> class FieldsMeta(type):\n...     @classmethod\n...     def __prepare__(metaclass, name, bases):\n...         return collections.OrderedDict()\n...\n...     def __new__(metaclass, name, bases, namespace):\n...         cls = type.__new__(metaclass, name, bases, namespace)\n...         cls.fields = []\n...         for k, v in namespace.items():\n...             if isinstance(v, Field):\n...                 cls.fields.append(v)\n...                 v.name = v.name or k\n...\n...         return cls\n\n>>> class Fields(metaclass=FieldsMeta):\n...     spam = Field()\n...     eggs = Field()\n\n>>> Fields.fields\n[<Field spam>, <Field eggs>]\n>>> fields = Fields()\n>>> fields.fields\n[<Field spam>, <Field eggs>]\n```"]