["```py\nspam = eggs(spam)\n```", "```py\n@eggs\ndef spam():\n    pass\n```", "```py\ndef eggs(function):\n    return function\n```", "```py\n**>>> import functools**\n\n**>>> def eggs(function):**\n**...    @functools.wraps(function)**\n**...    def _eggs(*args, **kwargs):**\n**...        print('%r got args: %r and kwargs: %r' % (**\n**...            function.__name__, args, kwargs))**\n**...        return function(*args, **kwargs)**\n**...**\n**...    return _eggs**\n\n**>>> @eggs**\n**... def spam(a, b, c):**\n**...     return a * b + c**\n\n**>>> spam(1, 2, 3)**\n**'spam' got args: (1, 2, 3) and kwargs: {}**\n**5**\n\n```", "```py\n**>>> def eggs(function):**\n**...    def _eggs(*args, **kwargs):**\n**...        return function(*args, **kwargs)**\n**...    return _eggs**\n\n**>>> @eggs**\n**... def spam(a, b, c):**\n**...     '''The spam function Returns a * b + c'''**\n**...     return a * b + c**\n\n**>>> help(spam)**\n**Help on function _eggs in module ...:**\n**<BLANKLINE>**\n**_eggs(*args, **kwargs)**\n**<BLANKLINE>**\n\n**>>> spam.__name__**\n**'_eggs'**\n\n```", "```py\n**>>> import functools**\n\n**>>> def eggs(function):**\n**...     @functools.wraps(function)**\n**...     def _eggs(*args, **kwargs):**\n**...         return function(*args, **kwargs)**\n**...     return _eggs**\n\n**>>> @eggs**\n**... def spam(a, b, c):**\n**...     '''The spam function Returns a * b + c'''**\n**...     return a * b + c**\n\n**>>> help(spam)**\n**Help on function spam in module ...:**\n**<BLANKLINE>**\n**spam(a, b, c)**\n **The spam function Returns a * b + c**\n**<BLANKLINE>**\n\n**>>> spam.__name__**\n**'spam'**\n\n```", "```py\n**>>> def spam(eggs):**\n**...     return 'spam' * (eggs % 5)**\n**...**\n**>>> output = spam(3)**\n\n```", "```py\n**>>> def spam(eggs):**\n**...     output = 'spam' * (eggs % 5)**\n**...     print('spam(%r): %r' % (eggs, output))**\n**...     return output**\n**...**\n**>>> output = spam(3)**\n**spam(3): 'spamspamspam'**\n\n```", "```py\n**>>> def debug(function):**\n**...     @functools.wraps(function)**\n**...     def _debug(*args, **kwargs):**\n**...         output = function(*args, **kwargs)**\n**...         print('%s(%r, %r): %r' % (function.__name__, args, kwargs, output))**\n**...         return output**\n**...     return _debug**\n**...**\n**>>>**\n**>>> @debug**\n**... def spam(eggs):**\n**...     return 'spam' * (eggs % 5)**\n**...**\n**>>> output = spam(3)**\n**spam((3,), {}): 'spamspamspam'**\n\n```", "```py\nimport some_module\n\n# Regular call\nsome_module.some_function()\n\n# Wrap the function\ndebug_some_function = debug(some_module.some_function)\n\n# Call the debug version\ndebug_some_function()\n\n# Monkey patch the original module\nsome_module.some_function = debug_some_function\n\n# Now this calls the debug version of the function\nsome_module.some_function()\n```", "```py\n**>>> import functools**\n\n**>>> def memoize(function):**\n**...     function.cache = dict()**\n**...**\n**...     @functools.wraps(function)**\n**...     def _memoize(*args):**\n**...         if args not in function.cache:**\n**...             function.cache[args] = function(*args)**\n**...         return function.cache[args]**\n**...     return _memoize**\n\n**>>> @memoize**\n**... def fibonacci(n):**\n**...     if n < 2:**\n**...         return n**\n**...     else:**\n**...         return fibonacci(n - 1) + fibonacci(n - 2)**\n\n**>>> for i in range(1, 7):**\n**...     print('fibonacci %d: %d' % (i, fibonacci(i)))**\n**fibonacci 1: 1**\n**fibonacci 2: 1**\n**fibonacci 3: 2**\n**fibonacci 4: 3**\n**fibonacci 5: 5**\n**fibonacci 6: 8**\n\n**>>> fibonacci.__wrapped__.cache**\n**{(5,): 5, (0,): 0, (6,): 8, (1,): 1, (2,): 1, (3,): 2, (4,): 3}**\n\n```", "```py\n**>>> import functools**\n\n**# Create a simple call counting decorator**\n**>>> def counter(function):**\n**...     function.calls = 0**\n**...     @functools.wraps(function)**\n**...     def _counter(*args, **kwargs):**\n**...         function.calls += 1**\n**...         return function(*args, **kwargs)**\n**...     return _counter**\n\n**# Create a LRU cache with size 3** \n**>>> @functools.lru_cache(maxsize=3)**\n**... @counter**\n**... def fibonacci(n):**\n**...     if n < 2:**\n**...         return n**\n**...     else:**\n**...         return fibonacci(n - 1) + fibonacci(n - 2)**\n\n**>>> fibonacci(100)**\n**354224848179261915075**\n\n**# The LRU cache offers some useful statistics**\n**>>> fibonacci.cache_info()**\n**CacheInfo(hits=98, misses=101, maxsize=3, currsize=3)**\n\n**# The result from our counter function which is now wrapped both by**\n**# our counter and the cache**\n**>>> fibonacci.__wrapped__.__wrapped__.calls**\n**101**\n\n```", "```py\n**>>> import functools**\n\n**>>> def add(extra_n=1):**\n**...     'Add extra_n to the input of the decorated function'**\n**...**\n**...     # The inner function, notice that this is the actual**\n**...     # decorator**\n**...     def _add(function):**\n**...         # The actual function that will be called**\n**...         @functools.wraps(function)**\n**...         def __add(n):**\n**...             return function(n + extra_n)**\n**...**\n**...         return __add**\n**...**\n**...     return _add**\n\n**>>> @add(extra_n=2)**\n**... def eggs(n):**\n**...     return 'eggs' * n**\n\n**>>> eggs(2)**\n**'eggseggseggseggs'**\n\n```", "```py\nadd(extra_n=2)(eggs)(2)\n```", "```py\nadd(eggs)(2)\n```", "```py\n**>>> import functools**\n\n**>>> def add(*args, **kwargs):**\n**...     'Add n to the input of the decorated function'**\n**...**\n**...     # The default kwargs, we don't store this in kwargs**\n**...     # because we want to make sure that args and kwargs**\n**...     # can't both be filled**\n**...     default_kwargs = dict(n=1)**\n**...**\n**...     # The inner function, notice that this is actually a**\n**...     # decorator itself**\n**...     def _add(function):**\n**...         # The actual function that will be called**\n**...         @functools.wraps(function)**\n**...         def __add(n):**\n**...             default_kwargs.update(kwargs)**\n**...             return function(n + default_kwargs['n'])**\n**...**\n**...         return __add**\n**...**\n**...     if len(args) == 1 and callable(args[0]) and not kwargs:**\n**...         # Decorator call without arguments, just call it**\n**...         # ourselves**\n**...         return _add(args[0])**\n**...     elif not args and kwargs:**\n**...         # Decorator call with arguments, this time it will**\n**...         # automatically be executed with function as the**\n**...         # first argument**\n**...         default_kwargs.update(kwargs)**\n**...         return _add**\n**...     else:**\n**...         raise RuntimeError('This decorator only supports '**\n**...                            'keyword arguments')**\n\n**>>> @add**\n**... def spam(n):**\n**...     return 'spam' * n**\n\n**>>> @add(n=3)**\n**... def eggs(n):**\n**...     return 'eggs' * n**\n\n**>>> spam(3)**\n**'spamspamspamspam'**\n\n**>>> eggs(2)**\n**'eggseggseggseggseggs'**\n\n**>>> @add(3)**\n**... def bacon(n):**\n**...     return 'bacon' * n**\n**Traceback (most recent call last):\u2029  ...**\n**RuntimeError: This decorator only supports keyword arguments**\n\n```", "```py\n**>>> import functools**\n\n**>>> class Debug(object):**\n**...**\n**...     def __init__(self, function):**\n**...         self.function = function**\n**...         # functools.wraps for classes**\n**...         functools.update_wrapper(self, function)**\n**...**\n**...     def __call__(self, *args, **kwargs):**\n**...         output = self.function(*args, **kwargs)**\n**...         print('%s(%r, %r): %r' % (**\n**...             self.function.__name__, args, kwargs, output))**\n**...         return output**\n\n**>>> @Debug**\n**... def spam(eggs):**\n**...     return 'spam' * (eggs % 5)**\n**...**\n**>>> output = spam(3)**\n**spam((3,), {}): 'spamspamspam'**\n\n```", "```py\n>>> import functools\n\n>>> def plus_one(function):\n...     @functools.wraps(function)\n...     def _plus_one(self, n):\n...         return function(self, n + 1)\n...     return _plus_one\n\n>>> class Spam(object):\n...     @plus_one\n...     def get_eggs(self, n=2):\n...         return n * 'eggs'\n\n>>> spam = Spam()\n>>> spam.get_eggs(3)\n'eggseggseggseggs'\n```", "```py\n**>>> import pprint**\n\n**>>> class Spam(object):**\n**...**\n**...     def some_instancemethod(self, *args, **kwargs):**\n**...         print('self: %r' % self)**\n**...         print('args: %s' % pprint.pformat(args))**\n**...         print('kwargs: %s' % pprint.pformat(kwargs))**\n**...**\n**...     @classmethod**\n**...     def some_classmethod(cls, *args, **kwargs):**\n**...         print('cls: %r' % cls)**\n**...         print('args: %s' % pprint.pformat(args))**\n**...         print('kwargs: %s' % pprint.pformat(kwargs))**\n**...**\n**...     @staticmethod**\n**...     def some_staticmethod(*args, **kwargs):**\n**...         print('args: %s' % pprint.pformat(args))**\n**...         print('kwargs: %s' % pprint.pformat(kwargs))**\n\n**# Create an instance so we can compare the difference between**\n**# executions with and without instances easily**\n**>>> spam = Spam()**\n\n**# With an instance (note the lowercase spam)**\n**>>> spam.some_instancemethod(1, 2, a=3, b=4)**\n**self: <...Spam object at 0x...>**\n**args: (1, 2)**\n**kwargs: {'a': 3, 'b': 4}**\n\n**# Without an instance (note the capitalized Spam)**\n**>>> Spam.some_instancemethod()**\n**Traceback (most recent call last):**\n\n **...**\n**TypeError: some_instancemethod() missing 1 required positional argument: 'self'**\n\n**# But what if we add parameters? Be very careful with these!**\n**# Our first argument is now used as an argument, this can give**\n**# very strange and unexpected errors**\n**>>> Spam.some_instancemethod(1, 2, a=3, b=4)**\n**self: 1**\n**args: (2,)**\n**kwargs: {'a': 3, 'b': 4}**\n\n**# Classmethods are expectedly identical**\n**>>> spam.some_classmethod(1, 2, a=3, b=4)**\n**cls: <class '...Spam'>**\n**args: (1, 2)**\n**kwargs: {'a': 3, 'b': 4}**\n\n**>>> Spam.some_classmethod()**\n**cls: <class '...Spam'>**\n**args: ()**\n**kwargs: {}**\n\n**>>> Spam.some_classmethod(1, 2, a=3, b=4)**\n**cls: <class '...Spam'>**\n**args: (1, 2)**\n**kwargs: {'a': 3, 'b': 4}**\n\n**# Staticmethods are also identical**\n**>>> spam.some_staticmethod(1, 2, a=3, b=4)**\n**args: (1, 2)**\n**kwargs: {'a': 3, 'b': 4}**\n\n**>>> Spam.some_staticmethod()**\n**args: ()**\n**kwargs: {}**\n\n**>>> Spam.some_staticmethod(1, 2, a=3, b=4)**\n**args: (1, 2)**\n**kwargs: {'a': 3, 'b': 4}**\n\n```", "```py\n**>>> class MoreSpam(object):**\n**...**\n**...     def __init__(self, more=1):**\n**...         self.more = more**\n**...**\n**...     def __get__(self, instance, cls):**\n**...         return self.more + instance.spam**\n**...**\n**...     def __set__(self, instance, value):**\n**...         instance.spam = value - self.more**\n\n**>>> class Spam(object):**\n**...**\n**...     more_spam = MoreSpam(5)**\n**...**\n**...     def __init__(self, spam):**\n**...         self.spam = spam**\n\n**>>> spam = Spam(1)**\n**>>> spam.spam**\n**1**\n**>>> spam.more_spam**\n**6**\n\n**>>> spam.more_spam = 10**\n**>>> spam.spam**\n**5**\n\n```", "```py\nimport functools\n\nclass ClassMethod(object):\n\n    def __init__(self, method):\n        self.method = method\n\n    def __get__(self, instance, cls):\n        @functools.wraps(self.method)\n        def method(*args, **kwargs):\n            return self.method(cls, *args, **kwargs)\n        return method\n\nclass StaticMethod(object):\n\n    def __init__(self, method):\n        self.method = method\n\n    def __get__(self, instance, cls):\n        return self.method\n```", "```py\n**>>> class Spam(object):**\n**...**\n**...     def get_eggs(self):**\n**...         print('getting eggs')**\n**...         return self._eggs**\n**...**\n**...     def set_eggs(self, eggs):**\n**...         print('setting eggs to %s' % eggs)**\n**...         self._eggs = eggs**\n**...**\n**...     def delete_eggs(self):**\n**...         print('deleting eggs')**\n**...         del self._eggs**\n**...**\n**...     eggs = property(get_eggs, set_eggs, delete_eggs)**\n**...**\n**...     @property**\n**...     def spam(self):**\n**...         print('getting spam')**\n**...         return self._spam**\n**...**\n**...     @spam.setter**\n**...     def spam(self, spam):**\n**...         print('setting spam to %s' % spam)**\n**...         self._spam = spam**\n**...**\n**...     @spam.deleter**\n**...     def spam(self):**\n**...         print('deleting spam')**\n**...         del self._spam**\n\n**>>> spam = Spam()**\n**>>> spam.eggs = 123**\n**setting eggs to 123**\n**>>> spam.eggs**\n**getting eggs**\n**123**\n**>>> del spam.eggs**\n**deleting eggs**\n\n```", "```py\nclass Property(object):\n    def __init__(self, fget=None, fset=None, fdel=None,\n                 doc=None):\n        self.fget = fget\n        self.fset = fset\n        self.fdel = fdel\n        # If no specific documentation is available, copy it\n        # from the getter\n        if fget and not doc:\n            doc = fget.__doc__\n        self.__doc__ = doc\n\n    def __get__(self, instance, cls):\n        if instance is None:\n            # Redirect class (not instance) properties to\n            # self\n            return self\n        elif self.fget:\n            return self.fget(instance)\n        else:\n            raise AttributeError('unreadable attribute')\n\n    def __set__(self, instance, value):\n        if self.fset:\n            self.fset(instance, value)\n        else:\n            raise AttributeError(\"can't set attribute\")\n\n    def __delete__(self, instance):\n        if self.fdel:\n            self.fdel(instance)\n        else:\n            raise AttributeError(\"can't delete attribute\")\n\n    def getter(self, fget):\n        return type(self)(fget, self.fset, self.fdel)\n\n    def setter(self, fset):\n        return type(self)(self.fget, fset, self.fdel)\n\n    def deleter(self, fdel):\n        return type(self)(self.fget, self.fset, fdel)\n```", "```py\n**>>> class Spam(object):**\n**...     def __init__(self):**\n**...         self.registry = {}**\n**...**\n**...     def __getattr__(self, key):**\n**...         print('Getting %r' % key)**\n**...         return self.registry.get(key, 'Undefined')**\n**...**\n**...     def __setattr__(self, key, value):**\n**...         if key == 'registry':**\n**...             object.__setattr__(self, key, value)**\n**...         else:**\n**...             print('Setting %r to %r' % (key, value))**\n**...             self.registry[key] = value**\n**...**\n**...     def __delattr__(self, key):**\n**...         print('Deleting %r' % key)**\n**...         del self.registry[key]**\n\n**>>> spam = Spam()**\n\n**>>> spam.a**\n**Getting 'a'**\n**'Undefined'**\n\n**>>> spam.a = 1**\n**Setting 'a' to 1**\n\n**>>> spam.a**\n**Getting 'a'**\n**1**\n\n**>>> del spam.a**\n**Deleting 'a'**\n\n```", "```py\n**>>> import functools**\n\n**>>> def singleton(cls):**\n**...     instances = dict()**\n**...     @functools.wraps(cls)**\n**...     def _singleton(*args, **kwargs):**\n**...         if cls not in instances:**\n**...             instances[cls] = cls(*args, **kwargs)**\n**...         return instances[cls]**\n**...     return _singleton**\n\n**>>> @singleton**\n**... class Spam(object):**\n**...     def __init__(self):**\n**...         print('Executing init')**\n\n**>>> a = Spam()**\n**Executing init**\n**>>> b = Spam()**\n\n**>>> a is b**\n**True**\n\n**>>> a.x = 123**\n**>>> b.x**\n**123**\n\n```", "```py\n**>>> import functools**\n\n**>>> class Value(object):**\n**...     def __init__(self, value):**\n**...         self.value = value**\n**...**\n**...     def __repr__(self):**\n**...         return '<%s[%d]>' % (self.__class__, self.value)**\n\n**>>> class Spam(Value):**\n**...     def __gt__(self, other):**\n**...         return self.value > other.value**\n**...**\n**...     def __ge__(self, other):**\n**...         return self.value >= other.value**\n**...**\n**...     def __lt__(self, other):**\n**...         return self.value < other.value**\n**...**\n**...     def __le__(self, other):**\n**...         return self.value <= other.value**\n**...**\n**...     def __eq__(self, other):**\n**...         return self.value == other.value**\n\n**>>> @functools.total_ordering**\n**... class Egg(Value):**\n**...     def __lt__(self, other):**\n**...         return self.value < other.value**\n**...**\n**...     def __eq__(self, other):**\n**...         return self.value == other.value**\n\n**>>> numbers = [4, 2, 3, 4]**\n**>>> spams = [Spam(n) for n in numbers]**\n**>>> eggs = [Egg(n) for n in numbers]**\n\n**>>> spams**\n**[<<class 'H05.Spam'>[4]>, <<class 'H05.Spam'>[2]>,**\n**<<class 'H05.Spam'>[3]>, <<class 'H05.Spam'>[4]>]**\n\n**>>> eggs**\n**[<<class 'H05.Egg'>[4]>, <<class 'H05.Egg'>[2]>,**\n**<<class 'H05.Egg'>[3]>, <<class 'H05.Egg'>[4]>]**\n\n**>>> sorted(spams)**\n**[<<class 'H05.Spam'>[2]>, <<class 'H05.Spam'>[3]>,**\n**<<class 'H05.Spam'>[4]>, <<class 'H05.Spam'>[4]>]**\n\n**>>> sorted(eggs)**\n**[<<class 'H05.Egg'>[2]>, <<class 'H05.Egg'>[3]>,**\n**<<class 'H05.Egg'>[4]>, <<class 'H05.Egg'>[4]>]**\n\n**# Sorting using key is of course still possible and in this case**\n**# perhaps just as easy:**\n**>>> values = [Value(n) for n in numbers]**\n**>>> values**\n**[<<class 'H05.Value'>[4]>, <<class 'H05.Value'>[2]>,**\n**<<class 'H05.Value'>[3]>, <<class 'H05.Value'>[4]>]**\n\n**>>> sorted(values, key=lambda v: v.value)**\n**[<<class 'H05.Value'>[2]>, <<class 'H05.Value'>[3]>,**\n**<<class 'H05.Value'>[4]>, <<class 'H05.Value'>[4]>]**\n\n```", "```py\n**>>> def sort_by_attribute(attr, keyfunc=getattr):**\n**...     def _sort_by_attribute(cls):**\n**...         def __gt__(self, other):**\n**...             return getattr(self, attr) > getattr(other, attr)**\n**...**\n**...         def __ge__(self, other):**\n**...             return getattr(self, attr) >= getattr(other, attr)**\n**...**\n**...         def __lt__(self, other):**\n**...             return getattr(self, attr) < getattr(other, attr)**\n**...**\n**...         def __le__(self, other):**\n**...             return getattr(self, attr) <= getattr(other, attr)**\n**...**\n**...         def __eq__(self, other):**\n**...             return getattr(self, attr) <= getattr(other, attr)**\n**...**\n**...         cls.__gt__ = __gt__**\n**...         cls.__ge__ = __ge__**\n**...         cls.__lt__ = __lt__**\n**...         cls.__le__ = __le__**\n**...         cls.__eq__ = __eq__**\n**...**\n**...         return cls**\n**...     return _sort_by_attribute**\n\n**>>> class Value(object):**\n**...     def __init__(self, value):**\n**...         self.value = value**\n**...**\n**...     def __repr__(self):**\n**...         return '<%s[%d]>' % (self.__class__, self.value)**\n\n**>>> @sort_by_attribute('value')**\n**... class Spam(Value):**\n**...     pass**\n\n**>>> numbers = [4, 2, 3, 4]**\n**>>> spams = [Spam(n) for n in numbers]**\n**>>> sorted(spams)**\n**[<<class '...Spam'>[2]>, <<class '...Spam'>[3]>,**\n**<<class '...Spam'>[4]>, <<class '...Spam'>[4]>]**\n\n```", "```py\nint some_integer = 123;\n```", "```py\nsome_integer = 123\n```", "```py\n'spam' + 5\n```", "```py\n**>>> import functools**\n\n**>>> @functools.singledispatch**\n**... def printer(value):**\n**...     print('other: %r' % value)**\n\n**>>> @printer.register(str)**\n**... def str_printer(value):**\n**...     print(value)**\n\n**>>> @printer.register(int)**\n**... def int_printer(value):**\n**...     printer('int: %d' % value)**\n\n**>>> @printer.register(dict)**\n**... def dict_printer(value):**\n**...     printer('dict:')**\n**...     for k, v in sorted(value.items()):**\n**...         printer('    key: %r, value: %r' % (k, v))**\n\n**>>> printer('spam')**\n**spam**\n\n**>>> printer([1, 2, 3])**\n**other: [1, 2, 3]**\n\n**>>> printer(123)**\n**int: 123**\n\n**>>> printer({'a': 1, 'b': 2})**\n**dict:**\n **key: 'a', value: 1**\n **key: 'b', value: 2**\n\n```", "```py\n**>>> import json**\n**>>> import functools**\n\n**>>> @functools.singledispatch**\n**... def write_as_json(file, data):**\n**...     json.dump(data, file)**\n\n**>>> @write_as_json.register(str)**\n**... @write_as_json.register(bytes)**\n**... def write_as_json_filename(file, data):**\n**...     with open(file, 'w') as fh:**\n**...         write_as_json(fh, data)**\n\n**>>> data = dict(a=1, b=2, c=3)**\n**>>> write_as_json('test1.json', data)**\n**>>> write_as_json(b'test2.json', 'w')**\n**>>> with open('test3.json', 'w') as fh:**\n**...     write_as_json(fh, data)**\n\n```", "```py\n**>>> write_as_json.registry.keys()**\n**dict_keys([<class 'bytes'>, <class 'object'>, <class 'str'>])**\n\n```", "```py\nwith open(filename) as fh:\n    pass\n```", "```py\n**>>> import contextlib**\n\n**>>> @contextlib.contextmanager**\n**... def open_context_manager(filename, mode='r'):**\n**...     fh = open(filename, mode)**\n**...     yield fh**\n**...     fh.close()**\n\n**>>> with open_context_manager('test.txt', 'w') as fh:**\n**...     print('Our test is complete!', file=fh)**\n\n```", "```py\n**>>> import contextlib**\n\n**>>> with contextlib.closing(open('test.txt', 'a')) as fh:**\n**...     print('Yet another test', file=fh)**\n\n```", "```py\n**>>> @contextlib.contextmanager**\n**... def debug(name):**\n**...     print('Debugging %r:' % name)**\n**...     yield**\n**...     print('End of debugging %r' % name)**\n\n**>>> @debug('spam')**\n**... def spam():**\n**...     print('This is the inside of our spam function')**\n\n**>>> spam()**\n**Debugging 'spam':**\n**This is the inside of our spam function**\n**End of debugging 'spam'**\n\n```", "```py\ndef spam(eggs: int):\n    pass\n```", "```py\n**>>> import inspect**\n**>>> import functools**\n\n**>>> def to_int(name, minimum=None, maximum=None):**\n**...     def _to_int(function):**\n**...         # Use the method signature to map *args to named**\n**...         # arguments**\n**...         signature = inspect.signature(function)**\n**...**\n**...         # Unfortunately functools.wraps doesn't copy the**\n**...         # signature (yet) so we do it manually.**\n**...         # For more info: http://bugs.python.org/issue23764**\n**...         @functools.wraps(function, ['__signature__'])**\n**...         @functools.wraps(function)**\n**...         def __to_int(*args, **kwargs):**\n**...             # Bind all arguments to the names so we get a single**\n**...             # mapping of all arguments**\n**...             bound = signature.bind(*args, **kwargs)**\n**...**\n**...             # Make sure the value is (convertible to) an integer**\n**...             default = signature.parameters[name].default**\n**...             value = int(bound.arguments.get(name, default))**\n**...**\n**...             # Make sure it's within the allowed range**\n**...             if minimum is not None:**\n**...                 assert value >= minimum, (**\n**...                     '%s should be at least %r, got: %r' %**\n**...                     (name, minimum, value))**\n**...**\n**...             if maximum is not None:**\n**...                 assert value <= maximum, (**\n**...                     '%s should be at most %r, got: %r' %**\n**...                     (name, maximum, value))**\n**...**\n**...             return function(*args, **kwargs)**\n**...         return __to_int**\n**...     return _to_int**\n\n**>>> @to_int('a', minimum=10)**\n**... @to_int('b', maximum=10)**\n**... @to_int('c')**\n**... def spam(a, b, c=10):**\n**...     print('a', a)**\n**...     print('b', b)**\n**...     print('c', c)**\n\n**>>> spam(10, b=0)**\n**a 10**\n**b 0**\n**c 10**\n\n**>>> spam(a=20, b=10)**\n**a 20**\n**b 10**\n**c 10**\n\n**>>> spam(1, 2, 3)**\n**Traceback (most recent call last):**\n **...**\n**AssertionError: a should be at least 10, got: 1**\n\n**>>> spam()**\n**Traceback (most recent call last):**\n **...**\n**TypeError: 'a' parameter lacking default value**\n\n**>>> spam('spam', {})**\n**Traceback (most recent call last):**\n **...**\n**ValueError: invalid literal for int() with base 10: 'spam'**\n\n```", "```py\n**>>> import functools**\n\n**>>> def to_int(name, minimum=None, maximum=None):**\n**...     def _to_int(function):**\n**...         @functools.wraps(function)**\n**...         def __to_int(**kwargs):**\n**...             value = int(kwargs.get(name))**\n**...**\n**...             # Make sure it's within the allowed range**\n**...             if minimum is not None:**\n**...                 assert value >= minimum, (**\n**...                     '%s should be at least %r, got: %r' %**\n**...                     (name, minimum, value))**\n**...**\n**...             if maximum is not None:**\n**...                 assert value <= maximum, (**\n**...                     '%s should be at most %r, got: %r' %**\n**...                     (name, maximum, value))**\n**...**\n**...             return function(**kwargs)**\n**...         return __to_int**\n**...     return _to_int**\n\n**>>> @to_int('a', minimum=10)**\n**... @to_int('b', maximum=10)**\n**... def spam(a, b):**\n**...     print('a', a)**\n**...     print('b', b)**\n\n**>>> spam(a=20, b=10)**\n**a 20**\n**b 10**\n\n**>>> spam(a=1, b=10)**\n**Traceback (most recent call last):**\n **...**\n**AssertionError: a should be at least 10, got: 1**\n\n```", "```py\nimport warnings\nimport functools\n\ndef ignore_warning(warning, count=None):\n    def _ignore_warning(function):\n        @functools.wraps(function)\n        def __ignore_warning(*args, **kwargs):\n            # Execute the code while recording all warnings\n            with warnings.catch_warnings(record=True) as ws:\n                # Catch all warnings of this type\n                warnings.simplefilter('always', warning)\n                # Execute the function\n                result = function(*args, **kwargs)\n\n            # Now that all code was executed and the warnings\n            # collected, re-send all warnings that are beyond our\n            # expected number of warnings\n            if count is not None:\n                for w in ws[count:]:\n                    warnings.showwarning(\n                        message=w.message,\n                        category=w.category,\n                        filename=w.filename,\n                        lineno=w.lineno,\n                        file=w.file,\n                        line=w.line,\n                    )\n\n            return result\n        return __ignore_warning\n    return _ignore_warning\n\n@ignore_warning(DeprecationWarning, count=1)\ndef spam():\n    warnings.warn('deprecation 1', DeprecationWarning)\n    warnings.warn('deprecation 2', DeprecationWarning)\n```"]