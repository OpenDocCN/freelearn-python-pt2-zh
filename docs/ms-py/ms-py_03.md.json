["```py\nn = 1000\na = list(range(n))\nb = dict.fromkeys(range(n))\nfor i in range(100):\n    i in a  # takes n=1000 steps\n    i in b  # takes 1 step\n```", "```py\ndef o_one(items):\n    return 1  # 1 operation so O(1)\n\ndef o_n(items):\n    total = 0\n    # Walks through all items once so O(n)\n    for item in items:\n        total += item\n    return total\n\ndef o_n_squared(items):\n    total = 0\n    # Walks through all items n*n times so O(n**2)\n    for a in items:\n        for b in items:\n            total += a * b\n    return total\n\nn = 10\nitems = range(n)\no_one(items)  # 1 operation\no_n(items)  # n = 10 operations\no_n_squared(items)  # n*n = 10*10 = 100 operations\n```", "```py\n**>>> def remove(items, value):**\n**...     new_items = []**\n**...     found = False**\n**...     for item in items:**\n**...         # Skip the first item which is equal to value**\n**...         if not found and item == value:**\n**...             found = True**\n**...             continue**\n**...         new_items.append(item)**\n**...**\n**...     if not found:**\n**...         raise ValueError('list.remove(x): x not in list')**\n**...**\n**...     return new_items**\n\n**>>> def insert(items, index, value):**\n**...     new_items = []**\n**...     for i, item in enumerate(items):**\n**...         if i == index:**\n**...             new_items.append(value)**\n**...         new_items.append(item)**\n**...     return new_items**\n\n**>>> items = list(range(10))**\n**>>> items**\n**[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]**\n\n**>>> items = remove(items, 5)**\n**>>> items**\n**[0, 1, 2, 3, 4, 6, 7, 8, 9]**\n\n**>>> items = insert(items, 2, 5)**\n**>>> items**\n**[0, 1, 5, 2, 3, 4, 6, 7, 8, 9]**\n\n```", "```py\n**>>> primes = set((1, 2, 3, 5, 7))**\n\n**# Classic solution**\n**>>> items = list(range(10))**\n**>>> for prime in primes:**\n**...     items.remove(prime)**\n**>>> items**\n**[0, 4, 6, 8, 9]**\n\n**# List comprehension**\n**>>> items = list(range(10))**\n**>>> [item for item in items if item not in primes]**\n**[0, 4, 6, 8, 9]**\n\n**# Filter**\n**>>> items = list(range(10))**\n**>>> list(filter(lambda item: item not in primes, items))**\n**[0, 4, 6, 8, 9]**\n\n```", "```py\n**>>> def in_(items, value):**\n**...     for item in items:**\n**...         if item == value:**\n**...             return True**\n**...     return False**\n\n**>>> def min_(items):**\n**...     current_min = items[0]**\n**...     for item in items[1:]:**\n**...         if current_min > item:**\n**...             current_min = item**\n**...     return current_min**\n\n**>>> def max_(items):**\n**...     current_max = items[0]**\n**...     for item in items[1:]:**\n**...         if current_max < item:**\n**...             current_max = item**\n**...     return current_max**\n\n**>>> items = range(5)**\n**>>> in_(items, 3)**\n**True**\n**>>> min_(items)**\n**0**\n**>>> max_(items)**\n**4**\n\n```", "```py\n**>>> def most_significant(value):**\n**...     while value >= 10:**\n**...         value //= 10**\n**...     return value**\n\n**>>> most_significant(12345)**\n**1**\n**>>> most_significant(99)**\n**9**\n**>>> most_significant(0)**\n**0**\n\n```", "```py\n**>>> def add(collection, key, value):**\n**...     index = most_significant(key)**\n**...     collection[index].append((key, value))**\n\n**>>> def contains(collection, key):**\n**...     index = most_significant(key)**\n**...     for k, v in collection[index]:**\n**...         if k == key:**\n**...             return True**\n**...     return False**\n\n**# Create the collection of 10 lists**\n**>>> collection = [[], [], [], [], [], [], [], [], [], []]**\n\n**# Add some items, using key/value pairs**\n**>>> add(collection, 123, 'a')**\n**>>> add(collection, 456, 'b')**\n**>>> add(collection, 789, 'c')**\n**>>> add(collection, 101, 'c')**\n\n**# Look at the collection**\n**>>> collection**\n**[[], [(123, 'a'), (101, 'c')], [], [],**\n **[(456, 'b')], [], [], [(789, 'c')], [], []]**\n\n**# Check if the contains works correctly**\n**>>> contains(collection, 123)**\n**True**\n**>>> contains(collection, 1)**\n**False**\n\n```", "```py\n**# All output in the table below is generated using this function**\n**>>> def print_set(expression, set_):**\n**...     'Print set as a string sorted by letters'**\n**...     print(expression, ''.join(sorted(set_)))**\n\n**>>> spam = set('spam')**\n**>>> print_set('spam:', spam)**\n**spam: amps**\n\n**>>> eggs = set('eggs')**\n**>>> print_set('eggs:', spam)**\n**eggs: amps**\n\n```", "```py\n**The set function takes a sequence as argument so the double ( is**\n**required.**\n**>>> current_users = set((**\n**...     'a',**\n**...     'b',**\n**...     'd',**\n**... ))**\n\n**>>> new_users = set((**\n**...     'b',**\n**...     'c',**\n**...     'd',**\n**...     'e',**\n**... ))**\n\n**>>> to_insert = new_users - current_users**\n**>>> sorted(to_insert)**\n**['c', 'e']**\n**>>> to_delete = current_users - new_users**\n**>>> sorted(to_delete)**\n**['a']**\n**>>> unchanged = new_users & current_users**\n**>>> sorted(unchanged)**\n**['b', 'd']**\n\n```", "```py\n**>>> spam = 1, 2, 3**\n**>>> eggs = 4, 5, 6**\n\n**>>> data = dict()**\n**>>> data[spam] = 'spam'**\n**>>> data[eggs] = 'eggs'**\n\n**>>> import pprint  # Using pprint for consistent and sorted output**\n**>>> pprint.pprint(data)**\n**{(1, 2, 3): 'spam', (4, 5, 6): 'eggs'}**\n\n```", "```py\n**>>> spam = 1, 'abc', (2, 3, (4, 5)), 'def'**\n**>>> eggs = 4, (spam, 5), 6**\n\n**>>> data = dict()**\n**>>> data[spam] = 'spam'**\n**>>> data[eggs] = 'eggs'**\n**>>> import pprint  # Using pprint for consistent and sorted output**\n**>>> pprint.pprint(data)**\n**{(1, 'abc', (2, 3, (4, 5)), 'def'): 'spam',**\n **(4, ((1, 'abc', (2, 3, (4, 5)), 'def'), 5), 6): 'eggs'}**\n\n```", "```py\n**# Assign using tuples on both sides**\n**>>> a, b, c = 1, 2, 3**\n**>>> a**\n**1**\n\n**# Assign a tuple to a single variable**\n**>>> spam = a, (b, c)**\n**>>> spam**\n**(1, (2, 3))**\n\n**# Unpack a tuple to two variables**\n**>>> a, b = spam**\n**>>> a**\n**1**\n**>>> b**\n**(2, 3)**\n\n```", "```py\n**# Unpack with variable length objects which actually assigns as a**\n**list, not a tuple**\n**>>> spam, *eggs = 1, 2, 3, 4**\n**>>> spam**\n**1**\n**>>> eggs**\n**[2, 3, 4]**\n\n**# Which can be unpacked as well of course**\n**>>> a, b, c = eggs**\n**>>> c**\n**4**\n\n**# This works for ranges as well**\n**>>> spam, *eggs = range(10)**\n**>>> spam**\n**0**\n**>>> eggs**\n**[1, 2, 3, 4, 5, 6, 7, 8, 9]**\n\n**# Which works both ways**\n**>>> a**\n**2**\n**>>> a, b, *c = a, *eggs**\n**>>> a, b**\n**(2, 1)**\n**>>> c**\n**[2, 3, 4, 5, 6, 7, 8, 9]**\n\n```", "```py\n**>>> def eggs(*args):**\n**...     print('args:', args)**\n\n**>>> eggs(1, 2, 3)**\n**args: (1, 2, 3)**\n\n```", "```py\n**>>> def spam_eggs():**\n**...     return 'spam', 'eggs'**\n\n**>>> spam, eggs = spam_eggs()**\n**>>> print('spam: %s, eggs: %s' % (spam, eggs))**\n**spam: spam, eggs: eggs**\n\n```", "```py\nimport builtins\n\nbuiltin_vars = vars(builtins)\nif key in locals():\n    value = locals()[key]\nelif key in globals():\n    value = globals()[key]\nelif key in builtin_vars:\n    value = builtin_vars[key]\nelse:\n    raise NameError('name %r is not defined' % key)\n```", "```py\nimport builtins\n\nmappings = globals(), locals(), vars(builtins)\nfor mapping in mappings:\n    if key in mapping:\n        value = mapping[key]\n        break\nelse:\n    raise NameError('name %r is not defined' % key)\n```", "```py\nimport builtins\nimport collections\n\nmappings = collections.ChainMap(globals(), locals(), vars(builtins))\nvalue = mappings[key]\n```", "```py\nimport argparse\nimport collections\n\ndefaults = {\n    'spam': 'default spam value',\n    'eggs': 'default eggs value',\n}\n\nparser = argparse.ArgumentParser()\nparser.add_argument('--spam')\nparser.add_argument('--eggs')\n\nargs = vars(parser.parse_args())\n# We need to check for empty/default values so we can't simply use vars(args)\nfiltered_args = {k: v for k, v in args.items() if v}\n\ncombined = collections.ChainMap(filtered_args, defaults)\n\nprint(combined ['spam'])\n```", "```py\nprint(combined.maps[1]['spam'])\n\nfor map_ in combined.maps:\n    print(map_.get('spam'))\n```", "```py\n**>>> import collections**\n\n**>>> counter = collections.Counter('eggs')**\n**>>> for k in 'eggs':**\n**...     print('Count for %s: %d' % (k, counter[k]))**\n**Count for e: 1**\n**Count for g: 2**\n**Count for g: 2**\n**Count for s: 1**\n\n```", "```py\n**>>> import math**\n**>>> import collections**\n\n**>>> counter = collections.Counter()**\n**>>> for i in range(0, 100000):**\n**...    counter[math.sqrt(i) // 25] += 1**\n\n**>>> for key, count in counter.most_common(5):**\n**...     print('%s: %d' % (key, count))**\n**11.0: 14375**\n**10.0: 13125**\n**9.0: 11875**\n**8.0: 10625**\n**12.0: 10000**\n\n```", "```py\n**>>> import collections**\n\n**>>> def print_counter(expression, counter):**\n**...     sorted_characters = sorted(counter.elements())**\n**...     print(expression, ''.join(sorted_characters))**\n\n**>>> eggs = collections.Counter('eggs')**\n**>>> spam = collections.Counter('spam')**\n**>>> print_counter('eggs:', eggs)**\n**eggs: eggs**\n**>>> print_counter('spam:', spam)**\n**spam: amps**\n**>>> print_counter('eggs & spam:', eggs & spam)**\n**eggs & spam: s**\n**>>> print_counter('spam & eggs:', spam & eggs)**\n**spam & eggs: s**\n**>>> print_counter('eggs - spam:', eggs - spam)**\n**eggs - spam: egg**\n**>>> print_counter('spam - eggs:', spam - eggs)**\n**spam - eggs: amp**\n**>>> print_counter('eggs + spam:', eggs + spam)**\n**eggs + spam: aeggmpss**\n**>>> print_counter('spam + eggs:', spam + eggs)**\n**spam + eggs: aeggmpss**\n**>>> print_counter('eggs | spam:', eggs | spam)**\n**eggs | spam: aeggmps**\n**>>> print_counter('spam | eggs:', spam | eggs)**\n**spam | eggs: aeggmps**\n\n```", "```py\n**>>> import collections**\n\n**>>> queue = collections.deque()**\n**>>> queue.append(1)**\n**>>> queue.append(2)**\n**>>> queue**\n**deque([1, 2])**\n**>>> queue.popleft()**\n**1**\n**>>> queue.popleft()**\n**2**\n**>>> queue.popleft()**\n**Traceback (most recent call last):**\n **...**\n**IndexError: pop from an empty deque**\n\n```", "```py\n**>>> import collections**\n\n**>>> queue = collections.deque()**\n**>>> queue.append(1)**\n**>>> queue.append(2)**\n**>>> queue**\n**deque([1, 2])**\n**>>> queue.pop()**\n**2**\n**>>> queue.pop()**\n**1**\n**>>> queue.pop()**\n**Traceback (most recent call last):**\n **...**\n**IndexError: pop from an empty deque**\n\n```", "```py\n**>>> import collections**\n\n**>>> circular = collections.deque(maxlen=2)**\n**>>> for i in range(5):**\n**...     circular.append(i)**\n**...     circular**\n**deque([0], maxlen=2)**\n**deque([0, 1], maxlen=2)**\n**deque([1, 2], maxlen=2)**\n**deque([2, 3], maxlen=2)**\n**deque([3, 4], maxlen=2)**\n**>>> circular**\n**deque([3, 4], maxlen=2)**\n\n```", "```py\nnodes = [\n    ('a', 'b'),\n    ('a', 'c'),\n    ('b', 'a'),\n    ('b', 'd'),\n    ('c', 'a'),\n    ('d', 'a'),\n    ('d', 'b'),\n    ('d', 'c'),\n]\n```", "```py\n**>>> graph = dict()**\n**>>> for from_, to in nodes:**\n**...     if from_ not in graph:**\n**...         graph[from_] = []**\n**...     graph[from_].append(to)**\n\n**>>> import pprint**\n**>>> pprint.pprint(graph)**\n**{'a': ['b', 'c'],**\n **'b': ['a', 'd'],**\n **'c': ['a'],**\n **'d': ['a', 'b', 'c']}**\n\n```", "```py\n**>>> import collections**\n\n**>>> graph = collections.defaultdict(list)**\n**>>> for from_, to in nodes:**\n**...     graph[from_].append(to)**\n\n**>>> import pprint**\n**>>> pprint.pprint(graph)**\n**defaultdict(<class 'list'>,**\n **{'a': ['b', 'c'],**\n **'b': ['a', 'd'],**\n **'c': ['a'],**\n **'d': ['a', 'b', 'c']})**\n\n```", "```py\n**>>> counter = collections.defaultdict(int)**\n**>>> counter['spam'] += 5**\n**>>> counter**\n**defaultdict(<class 'int'>, {'spam': 5})**\n\n```", "```py\nimport collections\ndef tree(): return collections.defaultdict(tree)\n```", "```py\n**>>> import json**\n**>>> import collections**\n\n**>>> def tree():**\n**...     return collections.defaultdict(tree)**\n\n**>>> colours = tree()**\n**>>> colours['other']['black'] = 0x000000**\n**>>> colours['other']['white'] = 0xFFFFFF**\n**>>> colours['primary']['red'] = 0xFF0000**\n**>>> colours['primary']['green'] = 0x00FF00**\n**>>> colours['primary']['blue'] = 0x0000FF**\n**>>> colours['secondary']['yellow'] = 0xFFFF00**\n**>>> colours['secondary']['aqua'] = 0x00FFFF**\n**>>> colours['secondary']['fuchsia'] = 0xFF00FF**\n\n**>>> print(json.dumps(colours, sort_keys=True, indent=4))**\n**{**\n **\"other\": {**\n **\"black\": 0,**\n **\"white\": 16777215**\n **},**\n **\"primary\": {**\n **\"blue\": 255,**\n **\"green\": 65280,**\n **\"red\": 16711680**\n **},**\n **\"secondary\": {**\n **\"aqua\": 65535,**\n **\"fuchsia\": 16711935,**\n **\"yellow\": 16776960**\n **}**\n**}**\n\n```", "```py\n**>>> import collections**\n\n**>>> Point = collections.namedtuple('Point', ['x', 'y', 'z'])**\n**>>> point_a = Point(1, 2, 3)**\n**>>> point_a**\n**Point(x=1, y=2, z=3)**\n\n**>>> point_b = Point(x=4, z=5, y=6)**\n**>>> point_b**\n**Point(x=4, y=6, z=5)**\n\n```", "```py\n**>>> x, y, z = point_a**\n**>>> print('X: %d, Y: %d, Z: %d' % (x, y, z))**\n**X: 1, Y: 2, Z: 3**\n**>>> print('X: %d, Y: %d, Z: %d' % point_b)**\n**X: 4, Y: 6, Z: 5**\n**>>> print('X: %d' % point_a.x)**\n\n```", "```py\n**>>> import enum**\n\n**>>> class Color(enum.Enum):**\n**...     red = 1**\n**...     green = 2**\n**...     blue = 3**\n\n**>>> Color.red**\n**<Color.red: 1>**\n**>>> Color['red']**\n**<Color.red: 1>**\n**>>> Color(1)**\n**<Color.red: 1>**\n**>>> Color.red.name**\n**'red'**\n**>>> Color.red.value**\n**1**\n**>>> isinstance(Color.red, Color)**\n**True**\n**>>> Color.red is Color['red']**\n**True**\n**>>> Color.red is Color(1)**\n**True**\n\n```", "```py\n**>>> for color in Color:**\n**...     color**\n**<Color.red: 1>**\n**<Color.green: 2>**\n**<Color.blue: 3>**\n\n**>>> colors = dict()**\n**>>> colors[Color.green] = 0x00FF00**\n**>>> colors**\n**{<Color.green: 2>: 65280}**\n\n```", "```py\n**>>> import enum**\n\n**>>> class Spam(enum.Enum):**\n**...     EGGS = 'eggs'**\n\n**>>> Spam.EGGS == 'eggs'**\n**False**\n\n```", "```py\n**>>> import enum**\n\n**>>> class Spam(str, enum.Enum):**\n**...     EGGS = 'eggs'**\n\n**>>> Spam.EGGS == 'eggs'**\n**True**\n\n```", "```py\n**>>> import collections**\n\n**>>> spam = collections.OrderedDict()**\n**>>> spam['b'] = 2**\n**>>> spam['c'] = 3**\n**>>> spam['a'] = 1**\n**>>> spam**\n**OrderedDict([('b', 2), ('c', 3), ('a', 1)])**\n\n**>>> for key, value in spam.items():**\n**...     key, value**\n**('b', 2)**\n**('c', 3)**\n**('a', 1)**\n\n**>>> eggs = collections.OrderedDict(sorted(spam.items()))**\n**>>> eggs**\n**OrderedDict([('a', 1), ('b', 2), ('c', 3)])**\n\n```", "```py\n**>>> import heapq**\n\n**>>> heap = [1, 3, 5, 7, 2, 4, 3]**\n**>>> heapq.heapify(heap)**\n**>>> heap**\n**[1, 2, 3, 7, 3, 4, 5]**\n\n**>>> while heap:**\n**...     heapq.heappop(heap), heap**\n**(1, [2, 3, 3, 7, 5, 4])**\n**(2, [3, 3, 4, 7, 5])**\n**(3, [3, 5, 4, 7])**\n**(3, [4, 5, 7])**\n**(4, [5, 7])**\n**(5, [7])**\n**(7, [])**\n\n```", "```py\n   1\n 2   3\n7 3 4 5\n```", "```py\n**>>> import bisect**\n\n**Using the regular sort:**\n**>>> sorted_list = []**\n**>>> sorted_list.append(5)  # O(1)**\n**>>> sorted_list.append(3)  # O(1)**\n**>>> sorted_list.append(1)  # O(1)**\n**>>> sorted_list.append(2)  # O(1)**\n**>>> sorted_list.sort()  # O(n * log(n)) = O(4 * log(4)) = O(8)**\n**>>> sorted_list**\n**[1, 2, 3, 5]**\n\n**Using bisect:**\n**>>> sorted_list = []**\n**>>> bisect.insort(sorted_list, 5)  # O(n) = O(1)**\n**>>> bisect.insort(sorted_list, 3)  # O(n) = O(2)**\n**>>> bisect.insort(sorted_list, 1)  # O(n) = O(3)**\n**>>> bisect.insort(sorted_list, 2)  # O(n) = O(4)**\n**>>> sorted_list**\n**[1, 2, 3, 5]**\n\n```", "```py\n**>>> import bisect**\n\n**>>> sorted_list = [1, 2, 3, 5]**\n**>>> def contains(sorted_list, value):**\n**...     i = bisect.bisect_left(sorted_list, value)**\n**...     return i < len(sorted_list) and sorted_list[i] == value**\n\n**>>> contains(sorted_list, 2)**\n**True**\n**>>> contains(sorted_list, 4)**\n**False**\n**>>> contains(sorted_list, 6)**\n**False**\n\n```", "```py\nsorted_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\nStep 1: 4 > 7                       ^\nStep 2: 4 > 3           ^\nStep 3: 4 > 5                 ^\nStep 4: 4 > 5              ^\n```"]