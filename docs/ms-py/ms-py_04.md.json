["```py\n**>>> squares = [x ** 2 for x in range(10)]**\n**>>> squares**\n**[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]**\n\n```", "```py\n**>>> uneven_squares = [x ** 2 for x in range(10) if x % 2]**\n**>>> uneven_squares**\n**[1, 9, 25, 49, 81]**\n\n```", "```py\n**>>> uneven_squares = []**\n**>>> for x in range(10):**\n**...     if x % 2:**\n**...         uneven_squares.append(x ** 2)**\n\n**>>> uneven_squares**\n**[1, 9, 25, 49, 81]**\n\n```", "```py\n**>>> import random**\n**>>> [random.random() for _ in range(10) if random.random() >= 0.5]**\n**[0.5211948104577864, 0.650010512129705, 0.021427316545174158]**\n\n```", "```py\n**>>> import random**\n**>>> numbers = [random.random() for _ in range(10)]**\n**>>> [x for x in numbers if x >= 0.5]**\n**[0.715510247827078, 0.8426277505519564, 0.5071133900377911]**\n\n```", "```py\n**>>> import random**\n**>>> [x for x in [random.random() for _ in range(10)] if x >= 0.5]**\n\n```", "```py\n**>>> import random**\n**>>> [x for _ in range(10) for x in [random.random()] if x >= 0.5]**\n\n```", "```py\n**>>> [(x, y) for x in range(3) for y in range(3, 5)]**\n**[(0, 3), (0, 4), (1, 3), (1, 4), (2, 3), (2, 4)]**\n\n```", "```py\n**>>> results = []**\n**>>> for x in range(3):**\n**...     for y in range(3, 5):**\n**...         results.append((x, y))**\n**...**\n**>>> results**\n**[(0, 3), (0, 4), (1, 3), (1, 4), (2, 3), (2, 4)]**\n\n```", "```py\n**>>> matrix = [**\n**...     [1, 2, 3, 4],**\n**...     [5, 6, 7, 8],**\n**...     [9, 10, 11, 12],**\n**... ]**\n\n**>>> reshaped_matrix = [**\n**...     [**\n**...         [y for x in matrix for y in x][i * len(matrix) + j]**\n**...         for j in range(len(matrix))**\n**...     ]**\n**...     for i in range(len(matrix[0]))**\n**... ]**\n\n**>>> import pprint**\n**>>> pprint.pprint(reshaped_matrix, width=40)**\n**[[1, 2, 3],**\n **[4, 5, 6],**\n **[7, 8, 9],**\n **[10, 11, 12]]**\n\n```", "```py\n**>>> {x: x ** 2 for x in range(10)}**\n**{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}**\n\n**>>> {x: x ** 2 for x in range(10) if x % 2}**\n**{1: 1, 3: 9, 9: 81, 5: 25, 7: 49}**\n\n```", "```py\n**>>> {x ** 2: [y for y in range(x)] for x in range(5)}**\n**{0: [], 1: [0], 4: [0, 1], 16: [0, 1, 2, 3], 9: [0, 1, 2]}**\n\n```", "```py\n**>>> [x*y for x in range(3) for y in range(3)]**\n**[0, 0, 0, 0, 1, 2, 0, 2, 4]**\n\n**>>> {x*y for x in range(3) for y in range(3)}**\n**{0, 1, 2, 4}**\n\n```", "```py\n**>>> class Spam(object):**\n**...     def __init__(self, value):**\n**...         self.value = value**\n**...**\n**...     def __repr__(self):**\n**...         return '<%s: %s>' % (self.__class__.__name__, self.value)**\n**...**\n**>>> spams = [Spam(5), Spam(2), Spam(4), Spam(1)]**\n**>>> sorted_spams = sorted(spams, key=lambda spam: spam.value)**\n**>>> spams**\n**[<Spam: 5>, <Spam: 2>, <Spam: 4>, <Spam: 1>]**\n**>>> sorted_spams**\n**[<Spam: 1>, <Spam: 2>, <Spam: 4>, <Spam: 5>]**\n\n```", "```py\n**>>> def key_function(spam):**\n**...     return spam.value**\n\n**>>> spams = [Spam(5), Spam(2), Spam(4), Spam(1)]**\n**>>> sorted_spams = sorted(spams, key=lambda spam: spam.value)**\n\n```", "```py\n**>>> def key(spam): return spam.value**\n\n**>>> key = lambda spam: spam.value**\n\n```", "```py\n**Y = lambda f: lambda *args: f(Y(f))(*args)**\n\n```", "```py\ndef Y(f):\n    def y(*args):\n        y_function = f(Y(f))\n        return y_function(*args)\n    return y\n```", "```py\n**>>> Y = lambda f: lambda *args: f(Y(f))(*args)**\n\n**>>> def factorial(combinator):**\n**...     def _factorial(n):**\n**...         if n:**\n**...             return n * combinator(n - 1)**\n**...         else:**\n**...             return 1**\n**...     return _factorial**\n**>>> Y(factorial)(5)**\n**120**\n\n```", "```py\n**>>> Y = lambda f: lambda *args: f(Y(f))(*args)**\n\n**>>> Y(lambda c: lambda n: n and n * c(n - 1) or 1)(5)**\n**120**\n\n```", "```py\n**>>> Y = lambda f: lambda *args: f(Y(f))(*args)**\n\n**>>> Y(lambda c: lambda n: n * c(n - 1) if n else 1)(5)**\n**120**\n\n```", "```py\n**>>> quicksort = Y(lambda f:**\n**...     lambda x: (**\n**...         f([item for item in x if item < x[0]])**\n**...         + [y for y in x if x[0] == y]**\n**...         + f([item for item in x if item > x[0]])**\n**...     ) if x else [])**\n\n**>>> quicksort([1, 3, 5, 4, 1, 3, 2])**\n**[1, 1, 2, 3, 3, 4, 5]**\n\n```", "```py\n**>>> import heapq**\n**>>> heap = []**\n**>>> heapq.heappush(heap, 1)**\n**>>> heapq.heappush(heap, 3)**\n**>>> heapq.heappush(heap, 5)**\n**>>> heapq.heappush(heap, 2)**\n**>>> heapq.heappush(heap, 4)**\n**>>> heapq.nsmallest(3, heap)**\n**[1, 2, 3]**\n\n```", "```py\n**>>> import functools**\n**>>> import heapq**\n**>>> heap = []**\n**>>> push = functools.partial(heapq.heappush, heap)**\n**>>> smallest = functools.partial(heapq.nsmallest, iterable=heap)**\n\n**>>> push(1)**\n**>>> push(3)**\n**>>> push(5)**\n**>>> push(2)**\n**>>> push(4)**\n**>>> smallest(3)**\n**[1, 2, 3]**\n\n```", "```py\n**>>> import operator**\n**>>> import functools**\n**>>> functools.reduce(operator.mul, range(1, 6))**\n**120**\n\n```", "```py\n**>>> import operator**\n**>>> f = operator.mul**\n**>>> f(f(f(f(1, 2), 3), 4), 5)**\n**120**\n\n```", "```py\n**>>> iterable = range(1, 6)**\n**>>> import operator**\n\n**# The initial values:**\n**>>> a, b, *iterable = iterable**\n**>>> a, b, iterable**\n**(1, 2, [3, 4, 5])**\n\n**# First run**\n**>>> a = operator.mul(a, b)**\n**>>> b, *iterable = iterable**\n**>>> a, b, iterable**\n**(2, 3, [4, 5])**\n\n**# Second run**\n**>>> a = operator.mul(a, b)**\n**>>> b, *iterable = iterable**\n**>>> a, b, iterable**\n**(6, 4, [5])**\n\n**# Third run**\n**>>> a = operator.mul(a, b)**\n**>>> b, *iterable = iterable**\n**>>> a, b, iterable**\n**(24, 5, [])**\n\n**# Fourth and last run**\n**>>> a = operator.mul (a, b)**\n**>>> a**\n**120**\n\n```", "```py\n**>>> import operator**\n**>>> import collections**\n**>>> iterable = collections.deque(range(1, 6))**\n\n**>>> value = iterable.popleft()**\n**>>> while iterable:**\n**...     value = operator.mul(value, iterable.popleft())**\n\n**>>> value**\n**120**\n\n```", "```py\n**>>> import json**\n**>>> import functools**\n**>>> import collections**\n\n**>>> def tree():**\n**...     return collections.defaultdict(tree)**\n\n**# Build the tree:**\n**>>> taxonomy = tree()**\n**>>> reptilia = taxonomy['Chordata']['Vertebrata']['Reptilia']**\n**>>> reptilia['Squamata']['Serpentes']['Pythonidae'] = [**\n**...     'Liasis', 'Morelia', 'Python']**\n\n**# The actual contents of the tree**\n**>>> print(json.dumps(taxonomy, indent=4))**\n**{**\n **\"Chordata\": {**\n **\"Vertebrata\": {**\n **\"Reptilia\": {**\n **\"Squamata\": {**\n **\"Serpentes\": {**\n **\"Pythonidae\": [**\n **\"Liasis\",**\n **\"Morelia\",**\n **\"Python\"**\n **]**\n **}**\n **}**\n **}**\n **}**\n **}**\n**}**\n\n**# The path we wish to get**\n**>>> path = 'Chordata.Vertebrata.Reptilia.Squamata.Serpentes'**\n\n**# Split the path for easier access**\n**>>> path = path.split('.')**\n\n**# Now fetch the path using reduce to recursively fetch the items**\n**>>> family = functools.reduce(lambda a, b: a[b], path, taxonomy)**\n**>>> family.items()**\n**dict_items([('Pythonidae', ['Liasis', 'Morelia', 'Python'])])**\n\n**# The path we wish to get**\n**>>> path = 'Chordata.Vertebrata.Reptilia.Squamata'.split('.')**\n\n**>>> suborder = functools.reduce(lambda a, b: a[b], path, taxonomy)**\n**>>> suborder.keys()**\n**dict_keys(['Serpentes'])**\n\n```", "```py\nfold_left = functools.reduce(\n    lambda x, y: function(x, y),\n    iterable,\n    initializer,\n)\n```", "```py\nfold_right = functools.reduce(\n    lambda x, y: function(y, x),\n    reversed(iterable),\n    initializer,\n)\n```", "```py\n**>>> import operator**\n**>>> import itertools**\n\n**# Sales per month**\n**>>> months = [10, 8, 5, 7, 12, 10, 5, 8, 15, 3, 4, 2]**\n**>>> list(itertools.accumulate(months, operator.add))**\n**[10, 18, 23, 30, 42, 52, 57, 65, 80, 83, 87, 89]**\n\n```", "```py\n**>>> import itertools**\n**>>> a = range(3)**\n**>>> b = range(5)**\n**>>> list(itertools.chain(a, b))**\n**[0, 1, 2, 0, 1, 2, 3, 4]**\n\n```", "```py\n**>>> import itertools**\n**>>> list(itertools.combinations(range(3), 2))**\n**[(0, 1), (0, 2), (1, 2)]**\n\n```", "```py\n**>>> import itertools**\n**>>> list(itertools.combinations_with_replacement(range(3), 2))**\n**[(0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2)]**\n\n```", "```py\n**>>> import itertools**\n\n**>>> def powerset(iterable):**\n**...     return itertools.chain.from_iterable(**\n**...         itertools.combinations(iterable, i)**\n**...         for i in range(len(iterable) + 1))**\n**>>> list(powerset(range(3)))**\n**[(), (0,), (1,), (2,), (0, 1), (0, 2), (1, 2), (0, 1, 2)]**\n\n```", "```py\n**>>> import itertools**\n**>>> list(itertools.permutations(range(3), 2))**\n**[(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]**\n\n```", "```py\n**>>> import itertools**\n**>>> list(itertools.compress(range(1000), [0, 1, 1, 1, 0, 1]))**\n**[1, 2, 3, 5]**\n\n```", "```py\n**>>> import itertools**\n**>>> list(itertools.dropwhile(lambda x: x <= 3, [1, 3, 5, 4, 2]))**\n**[5, 4, 2]**\n\n```", "```py\n**>>> import itertools**\n**>>> list(itertools.takewhile(lambda x: x <= 3, [1, 3, 5, 4, 2]))**\n**[1, 3]**\n\n```", "```py\n**>>> import itertools**\n\n**# Except for being infinite, the standard version returns the same**\n**# results as the range function does.**\n**>>> for a, b in zip(range(3), itertools.count()):**\n**...     a, b**\n**(0, 0)**\n**(1, 1)**\n**(2, 2)**\n\n**# With a different starting point the results are still the same**\n**>>> for a, b in zip(range(5, 8), itertools.count(5)):**\n**...     a, b**\n**(5, 5)**\n**(6, 6)**\n**(7, 7)**\n\n**# And a different step works the same as well**\n**>>> for a, b in zip(range(5, 10, 2), itertools.count(5, 2)):**\n**...     a, b**\n**(5, 5)**\n**(7, 7)**\n**(9, 9)**\n\n**# Unless you try to use floating point numbers**\n**>>> range(5, 10, 0.5)**\n**Traceback (most recent call last):**\n **...**\n**TypeError: 'float' object cannot be interpreted as an integer**\n\n**# Which does work for count**\n**>>> for a, b in zip(range(5, 10), itertools.count(5, 0.5)):**\n**...     a, b**\n**(5, 5)**\n**(6, 5.5)**\n**(7, 6.0)**\n**(8, 6.5)**\n**(9, 7.0)**\n\n```", "```py\n**>>> import itertools**\n**>>> items = [('a', 1), ('a', 2), ('b', 2), ('b', 0), ('c', 3)]**\n\n**>>> for group, items in itertools.groupby(items, lambda x: x[0]):**\n**...     print('%s: %s' % (group, [v for k, v in items]))**\n**a: [1, 2]**\n**b: [2, 0]**\n**c: [3]**\n\n```", "```py\n**>>> import itertools**\n**>>> items = [('a', 1), ('b', 0), ('b', 2), ('a', 2), ('c', 3)]**\n**>>> groups = dict()**\n\n**>>> for group, items in itertools.groupby(items, lambda x: x[0]):**\n**...     groups[group] = items**\n**...     print('%s: %s' % (group, [v for k, v in items]))**\n**a: [1]**\n**b: [0, 2]**\n**a: [2]**\n**c: [3]**\n\n**>>> for group, items in sorted(groups.items()):**\n**...     print('%s: %s' % (group, [v for k, v in items]))**\n**a: []**\n**b: []**\n**c: []**\n\n```", "```py\n**>>> import itertools**\n**>>> list(itertools.islice(itertools.count(), 2, 7))**\n**[2, 3, 4, 5, 6]**\n\n```", "```py\n**itertools.count()[:10]**\n\n```", "```py\n**itertools.islice(itertools.count(), 10)**\n\n```"]