["```py\n**xcode-select --install**\n\n```", "```py\n**# /usr/bin/ruby -e \"$(curl -fsSL \\**\n **https://raw.githubusercontent.com/Homebrew/install/master/install)\"**\n\n```", "```py\n**# brew doctor**\n\n```", "```py\n**# brew install python3**\n**# python3 \u2013version**\n**Python 3.5.1**\n**which python3**\n**/usr/local/bin/python3**\n\n```", "```py\n**# sudo yum install yum-utils**\n**# sudo yum-builddep python3**\n\n```", "```py\n**# sudo apt-get build-dep python3.5**\n\n```", "```py\n**>>> import ctypes**\n**>>> ctypes.cdll**\n**<ctypes.LibraryLoader object at 0x...>**\n**>>> libc = ctypes.cdll.msvcrt**\n**>>> libc**\n**<CDLL 'msvcrt', handle ... at ...>**\n**>>> libc.printf**\n**<_FuncPtr object at 0x...>**\n\n```", "```py\n**>>> import ctypes**\n**>>> ctypes.cdll**\n**<ctypes.LibraryLoader object at 0x...>**\n**>>> libc = ctypes.cdll.LoadLibrary('libc.so.6')**\n**>>> libc**\n**<CDLL 'libc.so.6', handle ... at ...>**\n**>>> libc.printf**\n**<_FuncPtr object at 0x...>**\n\n```", "```py\n**>>> import ctypes**\n**>>> libc = ctypes.cdll.LoadLibrary('libc.dylib')**\n**>>> libc**\n**<CDLL 'libc.dylib', handle ... at 0x...>**\n**>>> libc.printf**\n**<_FuncPtr object at 0x...>**\n\n```", "```py\n**>>> from ctypes import util**\n**>>> from ctypes import cdll**\n**>>> libc = cdll.LoadLibrary(util.find_library('libc'))**\n**>>> libc**\n**<CDLL '/usr/lib/libc.dylib', handle ... at 0x...>**\n\n```", "```py\n**>>> spam = ctypes.create_string_buffer(b'spam')**\n**>>> ctypes.sizeof(spam)**\n**5**\n**>>> spam.raw**\n**b'spam\\x00'**\n**>>> spam.value**\n**b'spam'**\n**>>> libc.printf(spam)**\n**4**\n**spam>>>**\n\n```", "```py\n**>>> libc.printf(123)**\n**segmentation fault (core dumped)  python3**\n\n```", "```py\n**>>> format_string = ctypes.create_string_buffer(b'Number: %d\\n')**\n**>>> libc.printf(format_string, 123)**\n**Number: 123**\n**12**\n**>>> x = ctypes.c_int(123)**\n**>>> libc.printf(format_string, x)**\n**Number: 123**\n**12**\n\n```", "```py\n**>>> format_string = ctypes.create_string_buffer(b'Number: %.3f\\n')**\n**>>> libc.printf(format_string, 123.45)**\n**Traceback (most recent call last):**\n **File \"<stdin>\", line 1, in <module>**\n**ctypes.ArgumentError: argument 2: <class 'TypeError'>: Don't know how to convert parameter 2**\n**>>> x = ctypes.c_double(123.45)**\n**>>> libc.printf(format_string, x)**\n**Number: 123.450**\n**16**\n\n```", "```py\n**>>> x = ctypes.c_double(123.45)**\n**>>> x.value**\n**123.45**\n**>>> x.value = 456**\n**>>> x**\n**c_double(456.0)**\n\n```", "```py\n**>>> class Spam(ctypes.Structure):**\n**...     _fields_ = [**\n**...         ('spam', ctypes.c_int),**\n**...         ('eggs', ctypes.c_double),**\n**...     ]**\n**...>>> spam = Spam(123, 456.789)**\n**>>> spam.spam**\n**123**\n**>>> spam.eggs**\n**456.789**\n\n```", "```py\n**>>> TenNumbers = 10 * ctypes.c_double**\n**>>> numbers = TenNumbers()**\n**>>> numbers[0]**\n**0.0**\n\n```", "```py\n**>>> Spams = 5 * Spam**\n**>>> spams = Spams()**\n**>>> spams[0].eggs = 123.456**\n**>>> spams**\n**<__main__.Spam_Array_5 object at 0x...>**\n**>>> spams[0]**\n**<__main__.Spam object at 0x...>**\n**>>> spams[0].eggs**\n**123.456**\n**>>> spams[0].spam**\n**0**\n\n```", "```py\n**>>> TenNumbers = 10 * ctypes.c_double**\n**>>> numbers = TenNumbers()**\n**>>> ctypes.resize(numbers, 11 * ctypes.sizeof(ctypes.c_double))**\n**>>> ctypes.resize(numbers, 10 * ctypes.sizeof(ctypes.c_double))**\n**>>> ctypes.resize(numbers, 9 * ctypes.sizeof(ctypes.c_double))**\n**Traceback (most recent call last):**\n **File \"<stdin>\", line 1, in <module>**\n**ValueError: minimum size is 80**\n**>>> numbers[:5] = range(5)**\n**>>> numbers[:]**\n**[0.0, 1.0, 2.0, 3.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0]**\n\n```", "```py\n**>>> class Point(ctypes.Structure):**\n**...     _fields_ = ('x', ctypes.c_int), ('y', ctypes.c_int)**\n**...**\n**>>> class Vertex(ctypes.Structure):**\n**...     _fields_ = ('a', Point), ('b', Point), ('c', Point)**\n**...**\n**>>> v = Vertex()**\n**>>> v.a = Point(0, 1)**\n**>>> v.b = Point(2, 3)**\n**>>> v.c = Point(4, 5)**\n**>>> v.a.x, v.a.y, v.b.x, v.b.y, v.c.x, v.c.y**\n**(0, 1, 2, 3, 4, 5)**\n**>>> v.a, v.b, v.c = v.b, v.c, v.a**\n**>>> v.a.x, v.a.y, v.b.x, v.b.y, v.c.x, v.c.y**\n**(2, 3, 4, 5, 2, 3)**\n**>>> v.a.x = 123**\n**>>> v.a.x, v.a.y, v.b.x, v.b.y, v.c.x, v.c.y**\n**(123, 3, 4, 5, 2, 3)**\n\n```", "```py\n**>>> import cffi**\n**>>> ffi = cffi.FFI()**\n**>>> ffi.cdef('int printf(const char* format, ...);')**\n**>>> libc = ffi.dlopen(None)**\n**>>> arg = ffi.new('char[]', b'spam')**\n**>>> libc.printf(arg)**\n**4**\n**spam>>>**\n\n```", "```py\n**>>> from ctypes import util**\n**>>> import cffi**\n**>>> libc = ffi.dlopen(util.find_library('libc'))**\n**>>> ffi.printf**\n**Traceback (most recent call last):**\n **File \"<stdin>\", line 1, in <module>**\n**AttributeError: 'FFI' object has no attribute 'printf'**\n\n```", "```py\n**>>> import cffi**\n**>>> ffi = cffi.FFI()**\n**>>> ffi.cdef('''**\n**... typedef struct {**\n**...     int x;**\n**...     int y;**\n**... } point;**\n**...**\n**... typedef struct {**\n**...     point a;**\n**...     point b;**\n**...     point c;**\n**... } vertex;**\n**... ''')**\n**>>> vertices = ffi.new('vertex[]', 5)**\n**>>> v = vertices[0]**\n**>>> v.a.x = 1**\n**>>> v.a.y = 2**\n**>>> v.b.x = 3**\n**>>> v.b.y = 4**\n**>>> v.c.x = 5**\n**>>> v.c.y = 6**\n**>>> v.a.x, v.a.y, v.b.x, v.b.y, v.c.x, v.c.y**\n**(1, 2, 3, 4, 5, 6)**\n**v.a, v.b, v.c = v.b, v.c, v.a**\n**v.a.x, v.a.y, v.b.x, v.b.y, v.c.x, v.c.y**\n**>>> v.a, v.b, v.c = v.b, v.c, v.a**\n**>>> v.a.x, v.a.y, v.b.x, v.b.y, v.c.x, v.c.y**\n**(3, 4, 5, 6, 3, 4)**\n\n```", "```py\n**>>> import cffi**\n**>>> ffi = cffi.FFI()**\n**>>> x = ffi.new('int[10]')**\n**>>> y = ffi.new('int[]', 10)**\n**>>> x[0:10] = range(10)**\n**>>> y[0:10] = range(10, 0, -1)**\n**>>> list(x)**\n**[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]**\n**>>> list(y)**\n**[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]**\n\n```", "```py\nimport setuptools\n\nspam = setuptools.Extension('spam', sources=['spam.c'])\n\nsetuptools.setup(\n    name='Spam',\n    version='1.0',\n    ext_modules=[spam],\n)\n```", "```py\ndef sum_of_squares(n):\n    sum = 0\n\n    for i in range(n):\n        if i * i < n:\n            sum += i * i\n        else:\n            break\n\n    return sum\n```", "```py\nlong sum_of_squares(long n){\n    long sum = 0;\n\n    /* The actual summing code */\n    for(int i=0; i<n; i++){\n        if((i * i) < n){\n            sum += i * i;\n        }else{\n            break;\n        }\n    }\n\n    return sum;\n}\n```", "```py\n#include <Python.h>\n\nstatic PyObject* spam_sum_of_squares(PyObject *self, PyObject\n        *args){\n    /* Declare the variables */\n    int n;\n    int sum = 0;\n\n    /* Parse the arguments */\n    if(!PyArg_ParseTuple(args, \"i\", &n)){\n        return NULL;\n    }\n\n    /* The actual summing code */\n    for(int i=0; i<n; i++){\n        if((i * i) < n){\n            sum += i * i;\n        }else{\n            break;\n        }\n    }\n\n    /* Return the number but convert it to a Python object first\n     */\n    return PyLong_FromLong(sum);\n}\n\nstatic PyMethodDef spam_methods[] = {\n    /* Register the function */\n    {\"sum_of_squares\", spam_sum_of_squares, METH_VARARGS,\n     \"Sum the perfect squares below n\"},\n    /* Indicate the end of the list */\n    {NULL, NULL, 0, NULL},\n};\n\nstatic struct PyModuleDef spam_module = {\n    PyModuleDef_HEAD_INIT,\n    \"spam\", /* Module name */\n    NULL, /* Module documentation */\n    -1, /* Module state, -1 means global. This parameter is\n           for sub-interpreters */\n    spam_methods,\n};\n\n/* Initialize the module */\nPyMODINIT_FUNC PyInit_spam(void){\n    return PyModule_Create(&spam_module);\n}\n```", "```py\n**# python setup.py build install**\n**running build**\n**running build_ext**\n**running install**\n**running install_lib**\n**running install_egg_info**\n**Removing lib/python3.5/site-packages/Spam-1.0-py3.5.egg-info**\n**Writing lib/python3.5/site-packages/Spam-1.0-py3.5.egg-info**\n\n```", "```py\nimport sys\nimport spam\nimport timeit\n\ndef sum_of_squares(n):\n    sum = 0\n\n    for i in range(n):\n        if i * i < n:\n            sum += i * i\n        else:\n            break\n\n    return sum\n\nif __name__ == '__main__':\n    c = int(sys.argv[1])\n    n = int(sys.argv[2])\n    print('%d executions with n: %d' % (c, n))\n    print('C sum of squares: %d took %.3f seconds' % (\n        spam.sum_of_squares(n),\n        timeit.timeit('spam.sum_of_squares(n)', number=c,\n                      globals=globals()),\n    ))\n    print('Python sum of squares: %d took %.3f seconds' % (\n        sum_of_squares(n),\n        timeit.timeit('sum_of_squares(n)', number=c,\n                      globals=globals()),\n    ))\n```", "```py\n**# python3 test_spam.py 10000 1000000**\n**10000 executions with n: 1000000**\n**C sum of squares: 332833500 took 0.008 seconds**\n**Python sum of squares: 332833500 took 1.778 seconds**\n\n```", "```py\n**# python3 test_spam.py 1000 10000000**\n**1000 executions with n: 10000000**\n**C sum of squares: 1953214233 took 0.002 seconds**\n**Python sum of squares: 10543148825 took 0.558 seconds**\n\n```", "```py\nstatic PyObject* spam_sum_of_squares(PyObject *self, PyObject *args){\n    /* Declare the variables */\n    unsigned long long int n;\n    unsigned long long int sum = 0;\n\n    /* Parse the arguments */\n    if(!PyArg_ParseTuple(args, \"K\", &n)){\n        return NULL;\n    }\n\n    /* The actual summing code */\n    for(unsigned long long int i=0; i<n; i++){\n        if((i * i) < n){\n            sum += i * i;\n        }else{\n            break;\n        }\n    }\n\n    /* Return the number but convert it to a Python object first */\n    return PyLong_FromUnsignedLongLong(sum);\n}\n```", "```py\n**# python3 test_spam.py 1000 100000001000 executions with n: 10000000**\n**C sum of squares: 10543148825 took 0.002 seconds**\n**Python sum of squares: 10543148825 took 0.635 seconds**\n\n```", "```py\n**# python3 test_spam.py 1 100000000000000 ~/Dropbox/Mastering Python/code/h14**\n**1 executions with n: 100000000000000**\n**C sum of squares: 1291890006563070912 took 0.006 seconds**\n**Python sum of squares: 333333283333335000000 took 2.081 seconds**\n\n```", "```py\nstatic unsigned long long int get_number_from_object(int* overflow, PyObject* some_very_large_number){\n    return PyLong_AsLongLongAndOverflow(sum, overflow);\n}\n```", "```py\n**static PyObject* spam_sum_of_squares(PyObject *self, PyObject**\n ***args)**\n\n```", "```py\nif(!PyArg_ParseTuple(args, \"i\", &n)){\n    return NULL;\n}\n```", "```py\nPyObject* callback;\nint n;\n\n/* Parse the arguments */\nif(!PyArg_ParseTuple(args, \"Oi\", &callback, &n)){\n    return NULL;\n}\n```", "```py\nstatic PyObject* function(\n        PyObject *self,\n        PyObject *args,\n        PyObject *kwargs){\n    /* Declare the variables */\n    int sum = 0;\n\n    PyObject* callback;\n    int n;\n\n    static char* keywords[] = {\"callback\", \"n\", NULL};\n\n    /* Parse the arguments */\n    if(!PyArg_ParseTupleAndKeywords(args, kwargs, \"Oi\", keywords,\n                &callback, &n)){\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\nstatic PyMethodDef methods[] = {\n    /* Register the function with kwargs */\n    {\"function\", function, METH_VARARGS | METH_KEYWORDS,\n     \"Some kwargs function\"},\n    /* Indicate the end of the list */\n    {NULL, NULL, 0, NULL},\n};\n```", "```py\n**# python3 -c '1/0'**\n**Traceback (most recent call last):**\n **File \"<string>\", line 1, in <module>**\n**ZeroDivisionError: division by zero**\n\n```", "```py\nstatic PyObject* spam_eggs(PyObject *self, PyObject *args){\n    PyErr_SetString(PyExc_RuntimeError, \"Too many eggs!\");\n    return NULL;\n}\n\nstatic PyMethodDef spam_methods[] = {\n    /* Register the function */\n    {\"eggs\", spam_eggs, METH_VARARGS,\n     \"Count the eggs\"},\n    /* Indicate the end of the list */\n    {NULL, NULL, 0, NULL},\n};\n```", "```py\n**# python3 setup.py clean build install**\n**...**\n**# python3 -c 'import spam; spam.eggs()'**\n**Traceback (most recent call last):**\n **File \"<string>\", line 1, in <module>**\n**RuntimeError: Too many eggs!**\n\n```", "```py\nstatic PyObject* spam_sum(PyObject* self, PyObject* args){\n    /* Declare all variables, note that the values for sum and\n     * callback are defaults in the case these arguments are not\n     * specified */\n    long long int sum = 0;\n    int overflow = 0;\n    PyObject* iterator;\n    PyObject* iterable;\n    PyObject* callback = NULL;\n    PyObject* value;\n    PyObject* item;\n\n    /* Now we parse a PyObject* followed by, optionally\n     * (the | character), a PyObject* and a long long int */\n    if(!PyArg_ParseTuple(args, \"O|OL\", &iterable, &callback,\n                &sum)){\n        return NULL;\n    }\n\n    /* See if we can create an iterator from the iterable. This is\n     * effectively the same as doing iter(iterable) in Python */\n    iterator = PyObject_GetIter(iterable);\n    if(iterator == NULL){\n        PyErr_SetString(PyExc_TypeError,\n                \"Argument is not iterable\");\n        return NULL;\n    }\n\n    /* Check if the callback exists or wasn't specified. If it was\n     * specified check whether it's callable or not */\n    if(callback != NULL && !PyCallable_Check(callback)){\n        PyErr_SetString(PyExc_TypeError,\n                \"Callback is not callable\");\n        return NULL;\n    }\n\n    /* Loop through all items of the iterable */\n    while((item = PyIter_Next(iterator))){\n        /* If we have a callback available, call it. Otherwise\n         * just return the item as the value */\n        if(callback == NULL){\n            value = item;\n        }else{\n            value = PyObject_CallFunction(callback, \"O\", item);\n        }\n\n        /* Add the value to sum and check for overflows */\n        sum += PyLong_AsLongLongAndOverflow(value, &overflow);\n        if(overflow > 0){\n            PyErr_SetString(PyExc_RuntimeError,\n                    \"Integer overflow\");\n            return NULL;\n        }else if(overflow < 0){\n            PyErr_SetString(PyExc_RuntimeError,\n                    \"Integer underflow\");\n            return NULL;\n        }\n\n        /* If we were indeed using the callback, decrease the\n         * reference count to the value because it is a separate\n         * object now */\n        if(callback != NULL){\n            Py_DECREF(value);\n        }\n        Py_DECREF(item);\n    }\n    Py_DECREF(iterator);\n\n    return PyLong_FromLongLong(sum);\n}\n```", "```py\n**>>> import spam**\n**>>> x = range(10)**\n**>>> spam.sum(x)**\n**45**\n**>>> spam.sum(x, lambda y: y + 5)**\n**95**\n**>>> spam.sum(x, lambda y: y + 5, 5)**\n**100**\n\n```", "```py\n**>>> import spam**\n**>>> n = (2 ** 63) - 1**\n**>>> x = n,**\n**>>> spam.sum(x)**\n**9223372036854775807**\n**>>> x = n, n**\n**>>> spam.sum(x)**\n**-2**\n\n```"]