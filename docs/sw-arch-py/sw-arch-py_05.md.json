["```py\n# thumbnail_converter.py\nfrom PIL import Image\nimport urllib.request\n\ndef thumbnail_image(url, size=(64, 64), format='.png'):\n    \"\"\" Save thumbnail of an image URL \"\"\"\n\n    im = Image.open(urllib.request.urlopen(url))\n    # filename is last part of the URL minus extension + '.format'\n    pieces = url.split('/')\n    filename = ''.join((pieces[-2],'_',pieces[-1].split('.')[0],'_thumb',format))\n    im.thumbnail(size, Image.ANTIALIAS)\n    im.save(filename)  \n    print('Saved',filename)\n```", "```py\n**img_urls = ['https://dummyimage.com/256x256/000/fff.jpg',**\n **'https://dummyimage.com/320x240/fff/00.jpg',**\n **'https://dummyimage.com/640x480/ccc/aaa.jpg',**\n **'https://dummyimage.com/128x128/ddd/eee.jpg',**\n **'https://dummyimage.com/720x720/111/222.jpg']**\nfor url in img_urls:\n    thumbnail_image(urls)\n```", "```py\nimport threading\n\nfor url in img_urls:\n    t=threading.Thread(target=thumbnail_image,args=(url,))\n    t.start()\n```", "```py\n# thumbnail_pc.py\nimport threading\nimport time\nimport string\nimport random\nimport urllib.request\nfrom PIL import Image\nfrom queue import Queue\n```", "```py\nclass ThumbnailURL_Generator(threading.Thread):\n    \"\"\" Worker class that generates image URLs \"\"\"\n\n    def __init__(self, queue, sleep_time=1,):\n        self.sleep_time = sleep_time\n        self.queue = queue\n        # A flag for stopping\n        self.flag = True\n        # choice of sizes\n        self._sizes = (240,320,360,480,600,720)\n        # URL scheme\n        self.url_template = 'https://dummyimage.com/%s/%s/%s.jpg'\n        threading.Thread.__init__(self, name='producer')\n\n    def __str__(self):\n        return 'Producer'\n\n    def get_size(self):\n        return '%dx%d' % (random.choice(self._sizes),\n                          random.choice(self._sizes))\n\n    def get_color(self):\n        return ''.join(random.sample(string.hexdigits[:-6], 3))\n\n    def run(self):\n        \"\"\" Main thread function \"\"\"\n\n        while self.flag:\n            # generate image URLs of random sizes and fg/bg colors\n            url = self.url_template % (self.get_size(),\n                                       self.get_color(),\n                                       self.get_color())\n            # Add to queue\n            print(self,'Put',url)\n            self.queue.put(url)\n            time.sleep(self.sleep_time)\n\n    def stop(self):\n        \"\"\" Stop the thread \"\"\"\n\n        self.flag = False\n```", "```py\nclass ThumbnailURL_Consumer(threading.Thread):\n    \"\"\" Worker class that consumes URLs and generates thumbnails \"\"\"\n\n    def __init__(self, queue):\n        self.queue = queue\n        self.flag = True\n        threading.Thread.__init__(self, name='consumer')     \n\n    def __str__(self):\n        return 'Consumer'\n\n    def thumbnail_image(self, url, size=(64,64), format='.png'):\n        \"\"\" Save image thumbnails, given a URL \"\"\"\n\n        im=Image.open(urllib.request.urlopen(url))\n        # filename is last part of URL minus extension + '.format'\n        filename = url.split('/')[-1].split('.')[0] + '_thumb' + format\n        im.thumbnail(size, Image.ANTIALIAS)\n        im.save(filename)\n        print(self,'Saved',filename)    \n\n    def run(self):\n        \"\"\" Main thread function \"\"\"\n\n        while self.flag:\n            url = self.queue.get()\n            print(self,'Got',url)\n            self.thumbnail_image(url)\n\n    def stop(self):\n        \"\"\" Stop the thread \"\"\"\n\n        self.flag = False            \n```", "```py\n    q = Queue(maxsize=200)\n    producers, consumers = [], []\n\n    for i in range(2):\n        t = ThumbnailURL_Generator(q)\n        producers.append(t)\n        t.start()\n\n    for i in range(2):\n        t = ThumbnailURL_Consumer(q)\n        consumers.append(t)\n        t.start()\n```", "```py\ntry:\n  lock.acquire()\n  # Do some modification on a shared, mutable resource\n  mutable_object.modify()\nfinally:\n  lock.release()\n```", "```py\nwith lock:\n  mutable_object.modify()\n```", "```py\nclass ThumbnailImageSaver(object):\n    \"\"\" Class which saves URLs to thumbnail images and keeps a counter \"\"\"\n\n    def __init__(self, limit=10):\n        self.limit = limit\n        self.lock = threading.Lock()\n        self.counter = {}\n\n    def thumbnail_image(self, url, size=(64,64), format='.png'):\n        \"\"\" Save image thumbnails, given a URL \"\"\"\n\n        im=Image.open(urllib.request.urlopen(url))\n        # filename is last two parts of URL minus extension + '.format'\n        pieces = url.split('/')\n        filename = ''.join((pieces[-2],'_',pieces[-1].split('.')[0],'_thumb',format))\n        im.thumbnail(size, Image.ANTIALIAS)\n        im.save(filename)\n        print('Saved',filename)\n        self.counter[filename] = 1      \n        return True\n\n    def save(self, url):\n        \"\"\" Save a URL as thumbnail \"\"\"\n\n        with self.lock:\n            if len(self.counter)>=self.limit:\n                return False\n            self.thumbnail_image(url)\n            print('Count=>',len(self.counter))\n            return True\n```", "```py\nclass ThumbnailURL_Consumer(threading.Thread):\n    \"\"\" Worker class that consumes URLs and generates thumbnails \"\"\"\n\n    def __init__(self, queue, saver):\n        self.queue = queue\n        self.flag = True\n        self.saver = saver\n        # Internal id\n        self._id = uuid.uuid4().hex\n        threading.Thread.__init__(self, name='Consumer-'+ self._id)     \n\n    def __str__(self):\n        return 'Consumer-' + self._id\n\n    def run(self):\n        \"\"\" Main thread function \"\"\"\n\n        while self.flag:\n            url = self.queue.get()\n            print(self,'Got',url)\n            if not self.saver.save(url):\n               # Limit reached, break out\n               print(self, 'Set limit reached, quitting')\n               break\n\n    def stop(self):\n        \"\"\" Stop the thread \"\"\"\n\n        self.flag = False\n```", "```py\nq = Queue(maxsize=2000)\n# Create an instance of the saver object\nsaver = ThumbnailImageSaver(limit=100)\n\n    producers, consumers = [], []\n    for i in range(3):\n        t = ThumbnailURL_Generator(q)\n        producers.append(t)\n        t.start()\n\n    for i in range(5):\n        t = ThumbnailURL_Consumer(q, saver)     \n        consumers.append(t)\n        t.start()\n\n    for t in consumers:\n        t.join()\n        print('Joined', t, flush=True)\n\n    # To make sure producers don't block on a full queue\n    while not q.empty():\n        item=q.get()\n\n    for t in producers:\n        t.stop()\n        print('Stopped',t, flush=True)\n\n    print('Total number of PNG images',len(glob.glob('*.png')))\n```", "```py\nclass ThumbnailImageSemaSaver(object):\n    \"\"\" Class which keeps an exact counter of saved images\n    and restricts the total count using a semaphore \"\"\"\n\n    def __init__(self, limit = 10):\n        self.limit = limit\n        self.counter = threading.BoundedSemaphore(value=limit)\n        self.count = 0\n\n    def acquire(self):\n        # Acquire counter, if limit is exhausted, it\n        # returns False\n        return self.counter.acquire(blocking=False)\n\n    def release(self):\n        # Release counter, incrementing count\n        return self.counter.release()\n\n    def thumbnail_image(self, url, size=(64,64), format='.png'):\n        \"\"\" Save image thumbnails, given a URL \"\"\"\n\n        im=Image.open(urllib.request.urlopen(url))\n        # filename is last two parts of URL minus extension + '.format'\n        pieces = url.split('/')\n        filename = ''.join((pieces[-2],'_',pieces[-1].split('.')[0],format))        \n        try:\n            im.thumbnail(size, Image.ANTIALIAS)\n            im.save(filename)\n            print('Saved',filename)\n            self.count += 1\n        except Exception as e:\n            print('Error saving URL',url,e)\n            # Image can't be counted, increment semaphore\n            self.release()\n\n        return True\n\n    def save(self, url):\n        \"\"\" Save a URL as thumbnail \"\"\"\n\n        if self.acquire():\n            self.thumbnail_image(url)\n            return True\n        else:\n            print('Semaphore limit reached, returning False')\n            return False\n```", "```py\nsaver = ThumbnailImageSaver(limit=100)\n```", "```py\n   saver = ThumbnailImageSemaSaver(limit=100)\n```", "```py\ncond = threading.Condition()\n# In thread #1\nwith cond:\n    while not some_condition_is_satisfied():\n        # this thread is now blocked\n        cond.wait()\n```", "```py\n# In thread #2\nwith cond:\n    # Condition is satisfied\n    if some_condition_is_satisfied():\n        # Notify all threads waiting on the condition\n        cond.notify_all()\n```", "```py\nclass ThumbnailURLController(threading.Thread):\n    \"\"\" A rate limiting controller thread for URLs using conditions \"\"\"\n\n    def __init__(self, rate_limit=0, nthreads=0):\n        # Configured rate limit\n        self.rate_limit = rate_limit\n        # Number of producer threads\n        self.nthreads = nthreads\n        self.count = 0\n        self.start_t = time.time()\n        self.flag = True\n        self.cond = threading.Condition()\n        threading.Thread.__init__(self)\n\n    def increment(self):\n        # Increment count of URLs\n        self.count += 1\n\n    def calc_rate(self):\n        rate = 60.0*self.count/(time.time() - self.start_t)\n        return rate\n\n    def run(self):\n        while self.flag:\n            rate = self.calc_rate()\n            if rate<=self.rate_limit:\n                with self.cond:\n                    # print('Notifying all...')\n                    self.cond.notify_all()\n\n    def stop(self):\n        self.flag = False\n\n    def throttle(self, thread):\n        \"\"\" Throttle threads to manage rate \"\"\"\n        # Current total rate\n        rate = self.calc_rate()\n        print('Current Rate',rate)\n        # If rate > limit, add more sleep time to thread\n        diff = abs(rate - self.rate_limit)\n        sleep_diff = diff/(self.nthreads*60.0)\n\n        if rate>self.rate_limit:\n            # Adjust threads sleep_time\n            thread.sleep_time += sleep_diff\n            # Hold this thread till rate settles down with a 5% error\n            with self.cond:\n                print('Controller, rate is high, sleep more by',rate,sleep_diff)                \n                while self.calc_rate() > self.rate_limit:\n                    self.cond.wait()\n        elif rate<self.rate_limit:\n            print('Controller, rate is low, sleep less by',rate,sleep_diff)                         \n            # Decrease sleep time\n            sleep_time = thread.sleep_time\n            sleep_time -= sleep_diff\n            # If this goes off < zero, make it zero\n            thread.sleep_time = max(0, sleep_time)\n```", "```py\nclass ThumbnailURL_Generator(threading.Thread):\n    \"\"\" Worker class that generates image URLs and supports throttling via an external controller \"\"\"\n\n    def __init__(self, queue, controller=None, sleep_time=1):\n        self.sleep_time = sleep_time\n        self.queue = queue\n        # A flag for stopping\n        self.flag = True\n        # sizes\n        self._sizes = (240,320,360,480,600,720)\n        # URL scheme\n        self.url_template = 'https://dummyimage.com/%s/%s/%s.jpg'\n        # Rate controller\n        self.controller = controller\n        # Internal id\n        self._id = uuid.uuid4().hex\n        threading.Thread.__init__(self, name='Producer-'+ self._id)\n\n    def __str__(self):\n        return 'Producer-'+self._id\n\n    def get_size(self):\n        return '%dx%d' % (random.choice(self._sizes),\n                          random.choice(self._sizes))\n\n    def get_color(self):\n        return ''.join(random.sample(string.hexdigits[:-6], 3))\n\n    def run(self):\n        \"\"\" Main thread function \"\"\"\n\n        while self.flag:\n            # generate image URLs of random sizes and fg/bg colors\n            url = self.url_template % (self.get_size(),\n                                       self.get_color(),\n                                       self.get_color())\n            # Add to queue\n            print(self,'Put',url)\n            self.queue.put(url)\n            self.controller.increment()\n            # Throttle after putting a few images\n            if self.controller.count>5:\n                self.controller.throttle(self)\n\n            time.sleep(self.sleep_time)\n\n    def stop(self):\n        \"\"\" Stop the thread \"\"\"\n\n        self.flag = False\n```", "```py\n    q = Queue(maxsize=2000)\n    # The controller needs to be configured with exact number of \n    # producers\n    controller = ThumbnailURLController(rate_limit=50, nthreads=3)\n    saver = ThumbnailImageSemaSaver(limit=200)\n\n    controller.start()\n\n    producers, consumers = [], []\n    for i in range(3):\n        t = ThumbnailURL_Generator(q, controller)\n        producers.append(t)\n        t.start()\n\n    for i in range(5):\n        t = ThumbnailURL_Consumer(q, saver)     \n        consumers.append(t)\n        t.start()\n\n    for t in consumers:\n        t.join()\n        print('Joined', t, flush=True)\n\n    # To make sure producers dont block on a full queue\n    while not q.empty():\n        item=q.get()\n    controller.stop()\n\n    for t in producers:\n        t.stop()\n        print('Stopped',t, flush=True)\n\n    print('Total number of PNG images',len(glob.glob('*.png')))\n```", "```py\ndef is_prime(n):\n    \"\"\" Check for input number primality \"\"\"\n\n    for i in range(3, int(n**0.5+1), 2):\n        if n % i == 0:\n            print(n,'is not prime')\n            return False\n\n    print(n,'is prime')     \n    return True\n```", "```py\n# prime_thread.py\nimport threading\n\nclass PrimeChecker(threading.Thread):\n    \"\"\" Thread class for primality checking \"\"\"\n\n    def __init__(self, queue):\n        self.queue = queue\n        self.flag = True\n        threading.Thread.__init__(self)     \n\n    def run(self):\n\n        while self.flag:\n            try:\n                n = self.queue.get(timeout=1)\n                is_prime(n)\n            except Empty:\n                break\n```", "```py\n    numbers = [1297337, 1116281, 104395303, 472882027, 533000389,     \n               817504243, 982451653, 112272535095293, 115280095190773,    \n               1099726899285419]*100\n\n    q = Queue(1000)\n\n    for n in numbers:\n        q.put(n)\n\n    threads = []\n    for i in range(4):\n        t = PrimeChecker(q)\n        threads.append(t)\n        t.start()\n\n    for t in threads:\n        t.join()\n```", "```py\n    numbers = [1297337, 1116281, 104395303, 472882027, 533000389,   \n               817504243, 982451653, 112272535095293, 115280095190773,  \n               1099726899285419]*100\n    pool = multiprocessing.Pool(4)\n    pool.map(is_prime, numbers)\n```", "```py\n**>>> sys.getsizeof([100000]*1000)*100000/(1024.0*1024.0)**\n**769.04296875**\n\n```", "```py\n# sort_in_memory.py\nimport sys\n\nall_lists = []\n\nfor i in range(int(sys.argv[1])):\n    num_list = map(int, open('numbers/numbers_%d.txt' % i).readlines())\n    all_lists += num_list\n\nprint('Length of list',len(all_lists))\nprint('Sorting...')\nall_lists.sort()\nopen('sorted_nums.txt','w').writelines('\\n'.join(map(str, all_lists)) + '\\n')\nprint('Sorted')\n```", "```py\n    # sort_counter.py\n    import sys\n    import collections\n\n    MAXINT = 100000\n\n    def sort():\n        \"\"\" Sort files on disk by using a counter \"\"\"\n\n    counter = collections.defaultdict(int)\n    for i in range(int(sys.argv[1])):\n    filename = 'numbers/numbers_%d.txt' % i\n    for n in open(filename):\n    counter[n] += 1\n    print('Sorting...')\n\n    with open('sorted_nums.txt','w') as fp:\n    for i in range(1, MAXINT+1):\n        count = counter.get(str(i) + '\\n', 0)\n    if count>0:\n    fp.write((str(i)+'\\n')*count)\n\n    print('Sorted')\n    ```", "```py\n**$ echo 3 > /proc/sys/vm/drop_caches**\n\n```", "```py\n# sort_counter_mp.py\nimport sys\nimport time\nimport collections\nfrom multiprocessing import Pool\n\nMAXINT = 100000\n\ndef sorter(filenames):\n    \"\"\" Sorter process sorting files using a counter \"\"\"\n\n    counter = collections.defaultdict(int)\n\n    for filename in filenames:\nfor i in open(filename):\ncounter[i] += 1\n\nreturn counter\n\ndef batch_files(pool_size, limit):\n\"\"\" Create batches of files to process by a multiprocessing Pool \"\"\"\nbatch_size = limit // pool_size\n\nfilenames = []\n\nfor i in range(pool_size):\nbatch = []\nfor j in range(i*batch_size, (i+1)*batch_size):\nfilename = 'numbers/numbers_%d.txt' % j\nbatch.append(filename)\n\nfilenames.append(batch)\n\nreturn filenames\n\ndef sort_files(pool_size, filenames):\n\"\"\" Sort files by batches using a multiprocessing Pool \"\"\"\n\nwith Pool(pool_size) as pool:\ncounters = pool.map(sorter, filenames)\nwith open('sorted_nums.txt','w') as fp:\nfor i in range(1, MAXINT+1):\ncount = sum([x.get(str(i)+'\\n',0) for x in counters])\nif count>0:\nfp.write((str(i)+'\\n')*count)\nprint('Sorted')\nif __name__ == \"__main__\":\nlimit = int(sys.argv[1])\npool_size = 4\nfilenames = batch_files(pool_size, limit)\nsort_files(pool_size,\n```", "```py\n# generator_tasks.py\nimport random\nimport time\nimport collections\nimport threading\n\ndef number_generator(n):\n    \"\"\" A co-routine that generates numbers in range 1..n \"\"\"\n\n    for i in range(1, n+1):\n        yield i\n\ndef square_mapper(numbers):\n    \"\"\" A co-routine task for converting numbers to squares \"\"\"\n\n    for n in numbers:\n        yield n*n\n\ndef prime_filter(numbers):\n    \"\"\" A co-routine which yields prime numbers \"\"\"\n\n    primes = []\n    for n in numbers:\n        if n % 2 == 0: continue\n        flag = True\n        for i in range(3, int(n**0.5+1), 2):\n            if n % i == 0:\n                flag = False\n                break\n\n        if flag:\n            yield n\n\ndef scheduler(tasks, runs=10000):\n    \"\"\" Basic task scheduler for co-routines \"\"\"\n\n    results = collections.defaultdict(list)\n\n    for i in range(runs):\n        for t in tasks:\n            print('Switching to task',t.__name__)\n            try:\n                result = t.__next__()\n                print('Result=>',result)\n                results[t.__name__].append(result)\n            except StopIteration:\n                break\n\n    return results\n```", "```py\n    import sys\n\n    tasks = []\n    start = time.clock()\n\n    limit = int(sys.argv[1])\n\n    # Append sqare_mapper tasks to list of tasks \n    tasks.append(square_mapper(number_generator(limit)))\n    # Append prime_filter tasks to list of tasks\n    tasks.append(prime_filter(number_generator(limit))) \n\n    results = scheduler(tasks, runs=limit)\n    print('Last prime=>',results['prime_filter'][-1])\n    end = time.clock()\n    print('Time taken=>',end-start)\n```", "```py\n# asyncio_tasks.py\nimport asyncio\n\ndef number_generator(m, n):\n    \"\"\" A number generator co-routine in range(m...n+1) \"\"\"\n    yield from range(m, n+1)\n\nasync prime_filter(m, n):\n    \"\"\" Prime number co-routine \"\"\"\n\n    primes = []\n    for i in number_generator(m, n):\n        if i % 2 == 0: continue\n        flag = True\n\n        for j in range(3, int(i**0.5+1), 2):\n            if i % j == 0:\n                flag = False\n                break\n\n        if flag:\nprint('Prime=>',i)\nprimes.append(i)\n\n# At this point the co-routine suspends execution\n# so that another co-routine can be scheduled\nawait asyncio.sleep(1.0)\nreturn tuple(primes)\n\nasync def square_mapper(m, n):\n\"\"\" Square mapper co-routine \"\"\"\nsquares = []\n\nfor i in number_generator(m, n):\nprint('Square=>',i*i) \nsquares.append(i*i)\n# At this point the co-routine suspends execution\n# so that another co-routine can be scheduled\nawait asyncio.sleep(1.0)\nreturn squares\n\ndef print_result(future):\nprint('Result=>',future.result())\n```", "```py\nloop = asyncio.get_event_loop()\nfuture = asyncio.gather(prime_filter(10, 50), square_mapper(10, 50))\nfuture.add_done_callback(print_result)\nloop.run_until_complete(future)\n\nloop.close()\n```", "```py\n# async_http.py\nimport asyncio\nimport aiohttp\nimport async_timeout\n\n@asyncio.coroutine\ndef fetch_page(session, url, timeout=60):\n\"\"\" Asynchronous URL fetcher \"\"\"\n\nwith async_timeout.timeout(timeout):\nresponse = session.get(url)\nreturn response\n```", "```py\nloop = asyncio.get_event_loop()\nurls = ('http://www.google.com',\n        'http://www.yahoo.com',\n        'http://www.facebook.com',\n        'http://www.reddit.com',\n        'http://www.twitter.com')\n\nsession = aiohttp.ClientSession(loop=loop)\ntasks = map(lambda x: fetch_page(session, x), urls)\n# Wait for tasks\ndone, pending = loop.run_until_complete(asyncio.wait(tasks, timeout=120))\nloop.close()\n\nfor future in done:\n    response = future.result()\n    print(response)\n    response.close()\n    session.close()\n\nloop.close()\n```", "```py\nasync def parse_response(futures):\n\"\"\" Parse responses of fetch \"\"\"\nfor future in futures:\nresponse = future.result()\ndata = await response.text()\n        print('Response for URL',response.url,'=>', response.status, len(data))\n        response.close()\n```", "```py\nsession = aiohttp.ClientSession(loop=loop)\n# Wait for futures\ntasks = map(lambda x: fetch_page(session, x), urls)\ndone, pending = loop.run_until_complete(asyncio.wait(tasks, timeout=300))\n\n# One more processing step to parse responses of futures\nloop.run_until_complete(parse_response(done))\n\nsession.close()\nloop.close()\n```", "```py\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport functools\nimport operator\n\ndef factorial(n):\n    return functools.reduce(operator.mul, [i for i in range(1, n+1)])\n\nwith ThreadPoolExecutor(max_workers=2) as executor:\n    future_map = {executor.submit(factorial, n): n for n in range(10, 21)}\n    for future in as_completed(future_map):\n        num = future_map[future]\n        print('Factorial of',num,'is',future.result())\n```", "```py\nimport os\nimport sys\nimport mimetypes\nfrom concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed\n```", "```py\ndef thumbnail_image(filename, size=(64,64), format='.png'):\n    \"\"\" Convert image thumbnails, given a filename \"\"\"\n\n    try:\n        im=Image.open(filename)         \n        im.thumbnail(size, Image.ANTIALIAS)\n\n        basename = os.path.basename(filename)\n        thumb_filename = os.path.join('thumbs',\n            basename.rsplit('.')[0] + '_thumb.png')\n        im.save(thumb_filename)\n        print('Saved',thumb_filename)\n        return True\n\n    except Exception as e:\n        print('Error converting file',filename)\n        return False\n```", "```py\ndef directory_walker(start_dir):\n    \"\"\" Walk a directory and generate list of valid images \"\"\"\n\n    for root,dirs,files in os.walk(os.path.expanduser(start_dir)):\n        for f in files:\n            filename = os.path.join(root,f)\n            # Only process if its a type of image\n            file_type = mimetypes.guess_type(filename.lower())[0]\n            if file_type != None and file_type.startswith('image/'):\n                yield filename\n```", "```py\n    root_dir = os.path.expanduser('~/Pictures/')\n    if '--process' in sys.argv:\n        executor = ProcessPoolExecutor(max_workers=10)\n    else:\n        executor = ThreadPoolExecutor(max_workers=10)\n\n    with executor:\n        future_map = {executor.submit(thumbnail_image, filename): filename for filename in directory_walker(root_dir)}\n        for future in as_completed(future_map):\n            num = future_map[future]\n            status = future.result()\n            if status:\n                print('Thumbnail of',future_map[future],'saved')\n```", "```py\n>>> [i ** 0.5 for i in range(1, 11)]\n[1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 2.23606797749979, 2.449489742783178, 2.6457513110645907, 2.8284271247461903, 3.0, 3.1622776601683795]\n```", "```py\n>>> import math\n>>> from joblib import Parallel, delayed\n    [1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 2.23606797749979, 2.449489742783178, 2.6457513110645907, 2.8284271247461903, 3.0, 3.1622776601683795]\n```", "```py\n# prime_joblib.py\nfrom joblib import Parallel, delayed\n\ndef is_prime(n):\n    \"\"\" Check for input number primality \"\"\"\n\n    for i in range(3, int(n**0.5+1), 2):\n        if n % i == 0:\n            print(n,'is not prime')\n            return False\n\n    print(n,'is prime')     \n    return True\n\nif __name__ == \"__main__\":\n    numbers = [1297337, 1116281, 104395303, 472882027, 533000389, 817504243, 982451653, 112272535095293, 115280095190773, 1099726899285419]*100\n    Parallel(n_jobs=10)(delayed(is_prime)(i) for i in numbers)\n```", "```py\nint parallel(int argc, char **argv)\n{\n    int array[100000];\n\n    #pragma omp parallel for\n    for (int i = 0; i < 100000; i++) {\narray[i] = i * i;\n\t}\n\nreturn 0;\n}\n```", "```py\n# mandelbrot.py\nimport sys\nimport argparse\nfrom PIL import Image\n\ndef mandelbrot_calc_row(y, w, h, image, max_iteration = 1000):\n    \"\"\" Calculate one row of the Mandelbrot set with size wxh \"\"\"\n\n    y0 = y * (2/float(h)) - 1 # rescale to -1 to 1\n\n    for x in range(w):\n        x0 = x * (3.5/float(w)) - 2.5 # rescale to -2.5 to 1\n\n        i, z = 0, 0 + 0j\n        c = complex(x0, y0)\n        while abs(z) < 2 and i < max_iteration:\n            z = z**2 + c\n            i += 1\n\n        # Color scheme is that of Julia sets\n        color = (i % 8 * 32, i % 16 * 16, i % 32 * 8)\n        image.putpixel((x, y), color)\n\ndef mandelbrot_calc_set(w, h, max_iteration=10000, output='mandelbrot.png'):\n    \"\"\" Calculate a mandelbrot set given the width, height and\n    maximum number of iterations \"\"\"\n\n    image = Image.new(\"RGB\", (w, h))\n\n    for y in range(h):\n        mandelbrot_calc_row(y, w, h, image, max_iteration)\n\n    image.save(output, \"PNG\")\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(prog='mandelbrot', description='Mandelbrot fractal generator')\n    parser.add_argument('-W','--width',help='Width of the image',type=int, default=640)\n    parser.add_argument('-H','--height',help='Height of the image',type=int, default=480) \n    parser.add_argument('-n','--niter',help='Number of iterations',type=int, default=1000)\n    parser.add_argument('-o','--output',help='Name of output image file',default='mandelbrot.png')\n\n    args = parser.parse_args()\n    print('Creating Mandelbrot set with size %(width)sx%(height)s, #iterations=%(niter)s' % args.__dict__)\n    mandelbrot_calc_set(args.width, args.height, max_iteration=args.niter, output=args.output)  \n```", "```py\n# mandelbrot_mp.py\nimport sys\nfrom PIL import Image\nimport pymp\nimport argparse\n\ndef mandelbrot_calc_row(y, w, h, image_rows, max_iteration = 1000):\n    \"\"\" Calculate one row of the mandelbrot set with size wxh \"\"\"\n\n    y0 = y * (2/float(h)) - 1 # rescale to -1 to 1\n\n    for x in range(w):\n        x0 = x * (3.5/float(w)) - 2.5 # rescale to -2.5 to 1\n\n        i, z = 0, 0 + 0j\n        c = complex(x0, y0)\n        while abs(z) < 2 and i < max_iteration:\n            z = z**2 + c\n            i += 1\n\n        color = (i % 8 * 32, i % 16 * 16, i % 32 * 8)\n        image_rows[y*w + x] = color\n\ndef mandelbrot_calc_set(w, h, max_iteration=10000, output='mandelbrot_mp.png'):\n    \"\"\" Calculate a mandelbrot set given the width, height and\n    maximum number of iterations \"\"\"\n\n    image = Image.new(\"RGB\", (w, h))\n    image_rows = pymp.shared.dict()\n\n    with pymp.Parallel(4) as p:\n        for y in p.range(0, h):\n            mandelbrot_calc_row(y, w, h, image_rows, max_iteration)\n\n    for i in range(w*h):\n        x,y = i % w, i // w\n        image.putpixel((x,y), image_rows[i])\n\n    image.save(output, \"PNG\")\n    print('Saved to',output)\n```", "```py\n# mandelbrot_tasks.py\nfrom celery import Celery\n\napp = Celery('tasks', broker='pyamqp://guest@localhost//',\n             backend='redis://localhost')\n\n@app.task\ndef mandelbrot_calc_row(y, w, h, max_iteration = 1000):\n    \"\"\" Calculate one row of the mandelbrot set with size w x h \"\"\"\n\n    y0 = y * (2/float(h)) - 1 # rescale to -1 to 1\n\n    image_rows = {}\n    for x in range(w):\n        x0 = x * (3.5/float(w)) - 2.5 # rescale to -2.5 to 1\n\n        i, z = 0, 0 + 0j\n        c = complex(x0, y0)\n        while abs(z) < 2 and i < max_iteration:\n            z = z**2 + c\n            i += 1\n\n        color = (i % 8 * 32, i % 16 * 16, i % 32 * 8)\n        image_rows[y*w + x] = color\n\n    return image_rows\n```", "```py\n# celery_mandelbrot.py\nimport argparse\nfrom celery import group\nfrom PIL import Image\nfrom mandelbrot_tasks import mandelbrot_calc_row\n\ndef mandelbrot_main(w, h, max_iterations=1000, \noutput='mandelbrot_celery.png'):\n    \"\"\" Main function for mandelbrot program with celery \"\"\"\n\n    # Create a job \u2013 a group of tasks\n    job = group([mandelbrot_calc_row.s(y, w, h, max_iterations) for y in range(h)])\n    # Call it asynchronously\n    result = job.apply_async()\n\n    image = Image.new('RGB', (w, h))\n\n    for image_rows in result.join():\n        for k,v in image_rows.items():\n            k = int(k)\n            v = tuple(map(int, v))\n            x,y = k % args.width, k // args.width\n            image.putpixel((x,y), v)\n\n    image.save(output, 'PNG')\n    print('Saved to',output)\n```", "```py\ndef simple_app(environ, start_response):\n    \"\"\"Simplest possible application object\"\"\"\n\n    status = '200 OK'\n    response_headers = [('Content-type', 'text/plain')]\n    start_response(status, response_headers)\n    return ['Hello world!\\n']\n```", "```py\n[uwsgi]\n\n# the base directory (full path)\nchdir           = /home/user/my-django-app/\n# Django's wsgi file\nmodule          = app.wsgi\n# the virtualenv (full path)\nhome            = /home/user/django-virtualenv/\n# process-related settings\nmaster          = true\n# maximum number of worker processes\nprocesses       = 10\n# the socket \nsocket          = /home/user/my-django-app/myapp.sock\n# clear environment on exit\nvacuum          = true\n```"]