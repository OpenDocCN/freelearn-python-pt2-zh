["```py\n**>>>import this**\n\n```", "```py\nfor idx in range(len(seq)):\n    item = seq[idx]\n    print(idx, '=>', item)\n```", "```py\nfor idx, item in enumerate(seq):\n    print(idx, '=>', item)\n```", "```py\n    # This loop performs a network fetch of the URL, retrying upto 3\n    # times in case of errors. In case the URL cant be fetched, \n    # an error is returned.\n\n    # Initialize all state\n    count, ntries, result, error = 0, 3, None, None\n    while count < ntries:\n        try:\n            # NOTE: We are using an explicit   timeout of 30s here\n            result = requests.get(url, timeout=30)\n        except Exception as error:\n            print('Caught exception', error, 'trying again after a while')\n          # increment count\n          count += 1\n          # sleep 1 second every time\n          time.sleep(1)\n\n      if result == None:\n        print(\"Error, could not fetch URL\",url)\n        # Return a tuple of (<return code>, <lasterror>)\n        return (2, error)\n\n          # Return data of URL\n        return result.content\n    ```", "```py\n    def fetch_url(url, ntries=3, timeout=30):\n             \" Fetch a given url and return its contents \"\n\n            # This loop performs a network fetch of the URL, retrying \n            # upto\n            # 3 times in case of errors. In case the URL cant be \n            # fetched,       \n            # an error is returned.\n\n            # Initialize all state\n            count, result, error = 0, None, None\n            while count < ntries:\n                try:\n                    result = requests.get(url, timeout=timeout)\n                except Exception as error:\n                    print('Caught exception', error, 'trying again after a while')\n                    # increment count\n                    count += 1\n                    # sleep 1 second every time\n                    time.sleep(1)\n\n            if result == None:\n                print(\"Error, could not fetch URL\",url)\n                # Return a tuple of (<return code>, <lasterror>)\n                return (2, error)\n\n            # Return data of URL\n            return result.content\n    ```", "```py\n    def fetch_url(url, ntries=3, timeout=30):\n            \"\"\" Fetch a given url and return its contents. \n\n            @params\n                url - The URL to be fetched.\n                ntries - The maximum number of retries.\n                timeout - Timout per call in seconds.\n\n            @returns\n                On success - Contents of URL.\n                On failure - (error_code, last_error)\n            \"\"\"\n\n            # This loop performs a network fetch of the URL, \n            # retrying upto      \n            # 'ntries' times in case of errors. In case the URL \n            # cant be\n            # fetched, an error is returned.\n\n            # Initialize all state\n            count, result, error = 0, None, None\n            while count < ntries:\n                try:\n                    result = requests.get(url, timeout=timeout)\n                except Exception as error:\n                    print('Caught exception', error, 'trying again after a while')\n                    # increment count\n                    count += 1\n                    # sleep 1 second every time\n                    time.sleep(1)\n\n            if result == None:\n                print(\"Error, could not fetch URL\",url)\n                # Return a tuple of (<return code>, <lasterror>)\n                return (2, error)\n\n            # Return data of the URL\n            return result.content\n    ```", "```py\n    class UrlFetcher(object):\n             \"\"\" Implements the steps of fetching a URL.\n\n            Main methods:\n                fetch - Fetches the URL.\n                get - Return the URLs data.\n            \"\"\"\n\n            def __init__(self, url, timeout=30, ntries=3, headers={}):\n                \"\"\" Initializer. \n                @params\n                    url - URL to fetch.\n                    timeout - Timeout per connection (seconds).\n                    ntries - Max number of retries.\n                    headers - Optional request headers.\n                \"\"\"\n                self.url = url\n                self.timeout = timeout\n                self.ntries = retries\n                self.headers = headers\n                # Enapsulated result object\n                self.result = result \n\n            def fetch(self):\n                \"\"\" Fetch the URL and save the result \"\"\"\n\n                # This loop performs a network fetch of the URL, \n                # retrying \n                # upto 'ntries' times in case of errors. \n\n                count, result, error = 0, None, None\n                while count < self.ntries:\n                    try:\n                        result = requests.get(self.url,\n                                              timeout=self.timeout,\n                                              headers = self.headers)\n                    except Exception as error:\n                        print('Caught exception', error, 'trying again after a while')\n                        # increment count\n                        count += 1\n                        # sleep 1 second every time\n                        time.sleep(1)\n\n                if result != None:\n                    # Save result\n                    self.result = result\n\n            def get(self):\n                \"\"\" Return the data for the URL \"\"\"\n\n                if self.result != None:\n                    return self.result.content\n    ```", "```py\n    \"\"\"\n        urlhelper - Utility classes and functions to work with URLs.\n\n        Members:\n\n            # UrlFetcher - A class which encapsulates action of \n            # fetching\n            content of a URL.\n            # get_web_url - Converts URLs so they can be used on the \n            # web.\n            # get_domain - Returns the domain (site) of the URL.\n    \"\"\"\n\n    import urllib\n\n    def get_domain(url):\n        \"\"\" Return the domain name (site) for the URL\"\"\"\n\n        urlp = urllib.parse.urlparse(url)\n        return urlp.netloc\n\n    def get_web_url(url, default='http'):\n        \"\"\" Make a URL useful for fetch requests\n        -  Prefix network scheme in front of it if not present already\n        \"\"\" \n\n        urlp = urllib.parse.urlparse(url)\n        if urlp.scheme == '' and urlp.netloc == '':\n                  # No scheme, prefix default\n          return default + '://' + url\n\n        return url\n\n    class UrlFetcher(object):\n         \"\"\" Implements the steps of fetching a URL.\n\n        Main methods:\n            fetch - Fetches the URL.\n            get - Return the URLs data.\n        \"\"\"\n\n        def __init__(self, url, timeout=30, ntries=3, headers={}):\n            \"\"\" Initializer. \n            @params\n                url - URL to fetch.\n                timeout - Timeout per connection (seconds).\n                ntries - Max number of retries.\n                headers - Optional request headers.\n            \"\"\"\n            self.url = url\n            self.timeout = timeout\n            self.ntries = retries\n            self.headers = headers\n            # Enapsulated result object\n            self.result = result \n\n        def fetch(self):\n            \"\"\" Fetch the URL and save the result \"\"\"\n\n            # This loop performs a network fetch of the URL, retrying \n            # upto 'ntries' times in case of errors. \n\n            count, result, error = 0, None, None\n            while count < self.ntries:\n                try:\n                    result = requests.get(self.url,\n                                          timeout=self.timeout,\n                                          headers = self.headers)\n                except Exception as error:\n                    print('Caught exception', error, 'trying again after a while')\n                    # increment count\n                    count += 1\n                    # sleep 1 second every time\n                    time.sleep(1)\n\n            if result != None:\n                # Save result\n                self.result = result\n\n        def get(self):\n            \"\"\" Return the data for the URL \"\"\"\n\n            if self.result != None:\n                return self.result.content\n    ```", "```py\n    def rms(varray=[]):\n        \"\"\" RMS velocity \"\"\"\n\n        squares = map(lambda x: x*x, varray)\n        return pow(sum(squares), 0.5) \n\n    def rms(varray=[]):\n        \"\"\" Root mean squared velocity. Returns\n        square root of sum of squares of velocities \"\"\"\n\n        squares = map(lambda x: x*x, varray)\n        return pow(sum(squares), 0.5)\n    ```", "```py\n    # This code calculates the sum of squares of velocities \n    squares = map(lambda x: x*x, varray)\n    ```", "```py\n    squares = map(lambda x: x*x, varray)\n    # The above code calculates the sum of squares of velocities \n    ```", "```py\n    # Not good !\n    squares = map(lambda x: x*x, varray)   # Calculate squares of velocities\n    ```", "```py\n    # The following code iterates through odd numbers\n    for num in nums:\n        # Skip if number is odd\n        if num % 2 == 0: continue\n    ```", "```py\n\"\" Module A (a.py) \u2013 Implement functions that operate on series of numbers \"\"\"\n\ndef squares(narray):\n    \"\"\" Return array of squares of numbers \"\"\"\n    return pow_n(array, 2)\n\ndef cubes(narray):\n    \"\"\" Return array of cubes of numbers \"\"\"\n    return pow_n(narray, 3)\n\ndef pow_n(narray, n):\n    \"\"\" Return array of numbers raised to arbitrary power n each \"\"\"\n    return [pow(x, n) for x in narray]\n\ndef frequency(string, word):\n    \"\"\" Find the frequency of occurrences of word in string\n    as percentage \"\"\"\n\n    word_l = word.lower()\n    string_l = string.lower()\n\n    # Words in string\n    words = string_l.split()\n    count = w.count(word_l)\n\n    # Return frequency as percentage\n    return 100.0*count/len(words)\n```", "```py\n\"\"\" Module B (b.py) \u2013 Implement functions provide some statistical methods \"\"\"\n\nimport a\n\ndef rms(narray):\n    \"\"\" Return root mean square of array of numbers\"\"\"\n\n    return pow(sum(a.squares(narray)), 0.5)\n\ndef mean(array):\n    \"\"\" Return mean of an array of numbers \"\"\"\n\n    return 1.0*sum(array)/len(array)\n\ndef variance(array):\n    \"\"\" Return variance of an array of numbers \"\"\"\n\n    # Square of variation from mean\n    avg = mean(array)\n    array_d = [(x \u2013 avg) for x in array]\n    variance = sum(a.squares(array_d))\n    return variance\n\ndef standard_deviation(array):\n    \"\"\" Return standard deviation of an array of numbers \"\"\"\n\n    # S.D is square root of variance\n    return pow(variance(array), 0.5)\n```", "```py\n\"\"\" Module A (a.py) \u2013 Implement functions that operate on series of numbers \"\"\"\n\ndef squares(narray):\n    \"\"\" Return array of squares of numbers \"\"\"\n    return pow_n(array, 2)\n\ndef cubes(narray):\n    \"\"\" Return array of cubes of numbers \"\"\"\n    return pow_n(narray, 3)\n\ndef pow_n(narray, n):\n    \"\"\" Return array of numbers raised to arbitrary power n each \"\"\"\n    return [pow(x, n) for x in narray]\n```", "```py\n\"\"\" Module A (a.py) \u2013 Provides string processing functions \"\"\"\nimport b\n\ndef ntimes(string, char):\n    \"\"\" Return number of times character 'char'\n    occurs in string \"\"\"\n\n    return string.count(char)\n\ndef common_words(text1, text2):\n    \"\"\" Return common words across text1 and text2\"\"\"\n\n    # A text is a collection of strings split using newlines\n    strings1 = text1.split(\"\\n\")\n    strings2 = text2.split(\"\\n\")\n\n    common = []\n    for string1 in strings1:\n        for string2 in strings2:\n            common += b.common(string1, string2)\n\n    # Drop duplicates\n    return list(set(common))\n```", "```py\n\"\"\" Module B (b.py) \u2013 Provides text processing functions to user \"\"\"\n\nimport a\n\ndef common(string1, string2):\n    \"\"\" Return common words across strings1 1 & 2 \"\"\"\n\n    s1 = set(string1.lower().split())\n    s2 = set(string2.lower().split())\n    return s1.intersection(s2)    \n\ndef common_words(text1, text2):\n    \"\"\" Return common words across two input files \"\"\"\n\n    lines1 = open(filename1).read()\n    lines2 = open(filename2).read()\n\n    return a.common_words(lines1, lines2)\n```", "```py\n    \"\"\" Module A (a.py) \u2013 Provides string processing functions \"\"\"\n\n    def ntimes(string, char):\n        \"\"\" Return number of times character 'char'\n        occurs in string \"\"\"\n\n        return string.count(char)\n\n    def common(string1, string2):\n        \"\"\" Return common words across strings1 1 & 2 \"\"\"\n\n        s1 = set(string1.lower().split())\n        s2 = set(string2.lower().split())\n        return s1.intersection(s2)  \n\n    def common_words(text1, text2):\n        \"\"\" Return common words across text1 and text2\"\"\"\n\n        # A text is a collection of strings split using newlines\n        strings1 = text1.split(\"\\n\")\n        strings2 = text2.split(\"\\n\")\n\n        common_w = []\n        for string1 in strings1:\n            for string2 in strings2:\n                common_w += common(string1, string2)\n\n        return list(set(common_w))\n```", "```py\n  \"\"\" Module B (b.py) \u2013 Provides text processing functions to user \"\"\"\n\n  import a\n\n  def common_words(filename1, filename2):\n    \"\"\" Return common words across two input files \"\"\"\n\n    lines1 = open(filename1).read()\n    lines2 = open(filename2).read()\n\n    return a.common_words(lines1, lines2)\n```", "```py\n\"\"\" Module textrank - Rank text files in order of degree of a specific word frequency. \"\"\"\n\nimport operator\n\nclass TextRank(object):\n    \"\"\" Accept text files as inputs and rank them in\n    terms of how much a word occurs in them \"\"\"\n\n    def __init__(self, word, *filenames):\n        self.word = word.strip().lower()\n        self.filenames = filenames\n\n    def rank(self):\n        \"\"\" Rank the files. A tuple is returned with\n        (filename, #occur) in decreasing order of\n        occurences \"\"\"\n\n        occurs = []\n\n        for fpath in self.filenames:\n            data = open(fpath).read()\n            words = map(lambda x: x.lower().strip(), data.split())\n            # Filter empty words\n            count = words.count(self.word)\n            occurs.append((fpath, count))\n\n        # Return in sorted order\n        return sorted(occurs, key=operator.itemgetter(1), reverse=True)\n```", "```py\n    \"\"\" Module urlrank - Rank URLs in order of degree of a specific word frequency \"\"\"\n    import operator\nimport operator\nimport requests\n\nclass UrlRank(object):\n    \"\"\" Accept URLs as inputs and rank them in\n    terms of how much a word occurs in them \"\"\"\n\n    def __init__(self, word, *urls):\n        self.word = word.strip().lower()\n        self.urls = urls\n\n    def rank(self):\n        \"\"\" Rank the URLs. A tuple is returned with\n        (url, #occur) in decreasing order of\n        occurences \"\"\"\n\n        occurs = []\n\n        for url in self.urls:\n            data = requests.get(url).content\n            words = map(lambda x: x.lower().strip(), data.split())\n            # Filter empty words\n            count = words.count(self.word)\n            occurs.append((url, count))\n\n        # Return in sorted order\n        return sorted(occurs, key=operator.itemgetter(1), reverse=True)\n```", "```py\n\"\"\" Module rankbase - Logic for ranking text using degree of word frequency \"\"\"\n\nimport operator\n\nclass RankBase(object):\n    \"\"\" Accept text data as inputs and rank them in\n    terms of how much a word occurs in them \"\"\"\n\n    def __init__(self, word):\n        self.word = word.strip().lower()\n\n    def rank(self, *texts):\n        \"\"\" Rank input data. A tuple is returned with\n        (idx, #occur) in decreasing order of\n        occurences \"\"\"\n\n        occurs = {}\n\n        for idx,text in enumerate(texts):\n            # print text\n            words = map(lambda x: x.lower().strip(), text.split())\n            count = words.count(self.word)\n            occurs[idx] = count\n\n        # Return dictionary\n        return occurs\n\n    def sort(self, occurs):\n        \"\"\" Return the ranking data in sorted order \"\"\"\n\n        return sorted(occurs, key=operator.itemgetter(1), reverse=True)\n```", "```py\n\"\"\" Module textrank - Rank text files in order of degree of a specific word frequency. \"\"\"\n\nimport operator\nfrom rankbase import RankBase\n\nclass TextRank(object):\n    \"\"\" Accept text files as inputs and rank them in\n    terms of how much a word occurs in them \"\"\"\n\n    def __init__(self, word, *filenames):\n        self.word = word.strip().lower()\n        self.filenames = filenames\n\n    def rank(self):\n        \"\"\" Rank the files. A tuple is returned with\n        (filename, #occur) in decreasing order of\n        occurences \"\"\"\n\n        texts = map(lambda x: open(x).read(), self.filenames)\n        occurs = super(TextRank, self).rank(*texts)\n        # Convert to filename list\n        occurs = [(self.filenames[x],y) for x,y in occurs.items()]\n\n        return self.sort(occurs)\n```", "```py\n\"\"\" Module urlrank - Rank URLs in order of degree of a specific word frequency \"\"\"\n\nimport requests\nfrom rankbase import RankBase\n\nclass UrlRank(RankBase):\n    \"\"\" Accept URLs as inputs and rank them in\n    terms of how much a word occurs in them \"\"\"\n\ndef __init__(self, word, *urls):\n    self.word = word.strip().lower()\n    self.urls = urls\n\ndef rank(self):\n    \"\"\" Rank the URLs. A tuple is returned with\n    (url, #occur) in decreasing order of\n    occurences\"\"\"\n\n    texts = map(lambda x: requests.get(x).content, self.urls)\n    # Rank using a call to parent class's 'rank' method\n    occurs = super(UrlRank, self).rank(*texts)\n    # Convert to URLs list\n    occurs = [(self.urls[x],y) for x,y in occurs.items()]\n\n    return self.sort(occurs)\n```", "```py\n\"\"\" Module power.py \"\"\"\n\ndef power(x, y):\n    \"\"\" Return power of x to y \"\"\"\n    return x^y\n```", "```py\n\"\"\" Module factorial.py \"\"\"\n\ndef factorial(n):\n    \"\"\" Return factorial of n \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n*factorial(n-1)\n```", "```py\n     1  \"\"\"\n     2  Module metrictest.py\n     3  \n     4  Metric example - Module which is used as a testbed for static checkers.\n     5  This is a mix of different functions and classes doing different things.\n     6  \n     7  \"\"\"\n     8  import random\n     9  \n    10  def fn(x, y):\n    11      \"\"\" A function which performs a sum \"\"\"\n    12      return x + y\n    13  \n    14  def find_optimal_route_to_my_office_from_home(start_time,\n    15                                      expected_time,\n    16                                      favorite_route='SBS1K',\n    17                                      favorite_option='bus'):\n    18  \n    19      # If I am very late, always drive.\n    20      d = (expected_time \u2013 start_time).total_seconds()/60.0\n    21  \n    22      if d<=30:\n    23          return 'car'\n    24  \n    25      # If d>30 but <45, first drive then take metro\n    26      if d>30 and d<45:\n    27          return ('car', 'metro')\n    28  \n    29      # If d>45 there are a combination of options\n    30      if d>45:\n    31          if d<60:\n    32              # First volvo,then connecting bus\n    33              return ('bus:335E','bus:connector')\n    34          elif d>80:\n    35              # Might as well go by normal bus\n    36              return random.choice(('bus:330','bus:331',':'.join((favorite_option,\n    37                           favorite_route))))\n    38          elif d>90:\n    39              # Relax and choose favorite route\n    40              return ':'.join((favorite_option,\n    41                               favorite_route))\n    42  \n    43      \n    44  class C(object):\n    45      \"\"\" A class which does almost nothing \"\"\"\n    46  \n    47      def __init__(self, x,y):\n    48          self.x = x\n    49          self.y = y\n    50          \n    51      def f(self):\n    52          pass\n    53  \n    54      def g(self, x, y):\n    55  \n    56          if self.x>x:\n    57              return self.x+self.y\n    58          elif x>self.x:\n    59              return x+ self.y\n    60  \n    61  class D(C):\n    62      \"\"\" D class \"\"\"\n    63  \n    64      def __init__(self, x):\n    65          self.x = x\n    66  \n    67      def f(self, x,y):\n    68          if x>y:\n    69              return x-y\n    70          else:\n    71              return x+y\n    72  \n    73      def g(self, y):\n    74  \n    75          if self.x>y:\n    76              return self.x+y\n    77          else:\n    78              return y-self.x\n```", "```py\n**$ pylint \u2013reports=n metrictest.py**\n\n```", "```py\n**$  flake8 --statistics --count metrictest.py**\n\n```", "```py\n     1  \"\"\"\n     2  Module metrictest.py\n     3  \n     4  Metric example - Module which is used as a testbed for static checkers.\n     5  This is a mix of different functions and classes doing different things.\n     6  \n     7  \"\"\"\n     8  import sys\n     9  \n    10  def fn(x, y):\n    11      \"\"\" A function which performs a sum \"\"\"\n    12      return x + y\n    13  \n    14  def find_optimal_route_to_my_office_from_home(start_time,\n    15                                      expected_time,\n    16                                      favorite_route='SBS1K',\n    17                                      favorite_option='bus'):\n    18  \n    19      # If I am very late, always drive.\n    20      d = (expected_time \u2013 start_time).total_seconds()/60.0\n    21  \n    22      if d<=30:\n    23          return 'car'\n    24  \n    25      # If d>30 but <45, first drive then take metro\n    26      if d>30 and d<45:\n    27          return ('car', 'metro')\n    28  \n    29      # If d>45 there are a combination of options\n    30      if d>45:\n    31          if d<60:\n    32              # First volvo,then connecting bus\n    33              return ('bus:335E','bus:connector')\n    34          elif d>80:\n    35              # Might as well go by normal bus\n    36              return random.choice(('bus:330','bus:331',':'.join((favorite_option,\n    37                           favorite_route))))\n    38          elif d>90:\n    39              # Relax and choose favorite route\n    40              return ':'.join((favorite_option,\n    41                               favorite_route))\n    42  \n    43      \n    44  class C(object):\n    45      \"\"\" A class which does almost nothing \"\"\"\n    46  \n    47      def __init__(self, x,y):\n    48          self.x = x\n    49          self.y = y\n    50          \n    51      def f(self):\n    52          pass\n    53  \n    54      def g(self, x, y):\n    55  \n    56          if self.x>x:\n    57              return self.x+self.y\n    58          elif x>self.x:\n    59              return x+ self.y\n    60  \n    61  class D(C):\n    62      \"\"\" D class \"\"\"\n    63  \n    64      def __init__(self, x):\n    65          self.x = x\n    66  \n    67      def f(self, x,y):\n    68          if x>y:\n    69              return x-y\n    70          else:\n    71              return x+y\n    72  \n    73      def g(self, y):\n    74  \n    75          if self.x>y:\n    76              return self.x+y\n    77          else:\n    78              return y-self.x\n    79  \n    80  def myfunc(a, b):\n    81      if a>b:\n    82          return c\n    83      else:\n    84          return a\n```", "```py\ndef find_optimal_route_to_my_office_from_home(start_time,\n                                              expected_time,\n                                              favorite_route='SBS1K',\n                                              favorite_option='bus'):\n\n        # If I am very late, always drive.\n        d = (expected_time - start_time).total_seconds()/60.0\n\n        if d<=30:\n            return 'car'\n        elif d<45:\n            return ('car', 'metro')\n        elif d<60:\n            # First volvo,then connecting bus\n            return ('bus:335E','bus:connector')\n        elif d>80:\n            # Might as well go by normal bus\n            return random.choice(('bus:330','bus:331',':'.join((favorite_option,\n                                         favorite_route))))\n        # Relax and choose favorite route\n        return ':'.join((favorite_option, favorite_route))\n```", "```py\ndeffind_optimal_route_to_my_office_from_home(start_time,\n    expected_time,\n    favorite_route='SBS1K',\n    favorite_option='bus'):\n\n    # If I am very late, always drive.\n    d = (expected_time \u2013 start_time).total_seconds()/60.0\n    options = { range(0,30): 'car',\n    range(30, 45): ('car','metro'),\n    range(45, 60): ('bus:335E','bus:connector') }\n\nif d<80:\n# Pick the range it falls into\nfor drange in options:\n    if d in drange:\n    return drange[d]\n\n    # Might as well go by normal bus\n    return random.choice(('bus:330','bus:331',':'.join((favorite_option, favorite_route))))\n\n```", "```py\n\"\"\" Module metrictest.py - testing static quality metrics of Python code \"\"\"\n\nimport random\n\ndef sum_fn(xnum, ynum):\n    \"\"\" A function which performs a sum \"\"\"\n\n    return xnum + ynum\n\ndef find_optimal_route(start_time,\n                       expected_time,\n                       favorite_route='SBS1K',\n                       favorite_option='bus'):\n    \"\"\" Find optimal route for me to go from home to office \"\"\"\n\n    # Time difference in minutes - inputs must be datetime instances\n    tdiff = (expected_time - start_time).total_seconds()/60.0\n\n    options = {range(0, 30): 'car',\n               range(30, 45): ('car', 'metro'),\n               range(45, 60): ('bus:335E', 'bus:connector')}\n\n    if tdiff < 80:\n        # Pick the range it falls into\n        for drange in options:\n            if tdiff in drange:\n                return drange[tdiff]\n\n    # Might as well go by normal bus\n    return random.choice(('bus:330', 'bus:331', ':'.join((favorite_option,\n                                    favorite_route))))\n\nclass MiscClassC(object):\n    \"\"\" A miscellaneous class with some utility methods \"\"\"\n\n    def __init__(self, xnum, ynum):\n        self.xnum = xnum\n        self.ynum = ynum\n\n    def compare_and_sum(self, xnum=0, ynum=0):\n        \"\"\" Compare local and argument variables\n        and perform some sums \"\"\"\n\n        if self.xnum > xnum:\n            return self.xnum + self.ynum\n        else:\n            return xnum + self.ynum\n\nclass MiscClassD(MiscClassC):\n    \"\"\" Sub-class of MiscClassC overriding some methods \"\"\"\n\n    def __init__(self, xnum, ynum=0):\n        super(MiscClassD, self).__init__(xnum, ynum)\n\n    def some_func(self, xnum, ynum):\n        \"\"\" A function which does summing \"\"\"\n\n        if xnum > ynum:\n            return xnum - ynum\n        else:\n            return xnum + ynum\n\n    def compare_and_sum(self, xnum=0, ynum=0):\n        \"\"\" Compare local and argument variables\n        and perform some sums \"\"\"\n\n        if self.xnum > ynum:\n            return self.xnum + ynum\n        else: \n            return ynum - self.xnum\n\n```"]