["```py\n>>> a  = [-5, 20, -10, 30, 15]\n```", "```py\nimport itertools\n\n# max_subarray: v1\ndef max_subarray(sequence):\n    \"\"\" Find sub-sequence in sequence having maximum sum \"\"\"\n\n    sums = []\n\n    for i in range(len(sequence)):\n        # Create all sub-sequences in given size\n        for sub_seq in itertools.combinations(sequence, i):\n            # Append sum\n            sums.append(sum(sub_seq))\n\n    return max(sums)\n```", "```py\n**>>>  max_subarray([-5, 20, -10, 30, 15])**\n**65**\n\n```", "```py\ndef max_subarray(sequence):\n    \"\"\" Find sub-sequence in sequence having maximum sum \"\"\"\n\n    sums = []\n    for i in range(len(sequence)):\n        for sub_seq in itertools.combinations(sequence, i):\n            sub_seq_sum = sum(sub_seq)\n            print(sub_seq,'=>',sub_seq_sum)\n            sums.append(sub_seq_sum)\n\n    return max(sums)\n```", "```py\n**>>> max_subarray([-5, 20, -10, 30, 15])**\n**((), '=>', 0)**\n**((-5,), '=>', -5)**\n**((20,), '=>', 20)**\n**((-10,), '=>', -10)**\n**((30,), '=>', 30)**\n**((15,), '=>', 15)**\n**((-5, 20), '=>', 15)**\n**((-5, -10), '=>', -15)**\n**((-5, 30), '=>', 25)**\n**((-5, 15), '=>', 10)**\n**((20, -10), '=>', 10)**\n**((20, 30), '=>', 50)**\n**((20, 15), '=>', 35)**\n**((-10, 30), '=>', 20)**\n**((-10, 15), '=>', 5)**\n**((30, 15), '=>', 45)**\n**((-5, 20, -10), '=>', 5)**\n**((-5, 20, 30), '=>', 45)**\n**((-5, 20, 15), '=>', 30)**\n**((-5, -10, 30), '=>', 15)**\n**((-5, -10, 15), '=>', 0)**\n**((-5, 30, 15), '=>', 40)**\n**((20, -10, 30), '=>', 40)**\n**((20, -10, 15), '=>', 25)**\n**((20, 30, 15), '=>', 65)**\n**((-10, 30, 15), '=>', 35)**\n**((-5, 20, -10, 30), '=>', 35)**\n**((-5, 20, -10, 15), '=>', 20)**\n**((-5, 20, 30, 15), '=>', 60)**\n**((-5, -10, 30, 15), '=>', 30)**\n**((20, -10, 30, 15), '=>', 55)**\n**65**\n\n```", "```py\ndef max_subarray(sequence):\n    \"\"\" Find sub-sequence in sequence having maximum sum \"\"\"\n\n    sums = []\n\n    for i in range(len(sequence)):\n        for j in range(i+1, len(sequence)):\n            sub_seq = sequence[i:j]\n            sub_seq_sum = sum(sub_seq)\n            print(sub_seq,'=>',sub_seq_sum)\n            sums.append(sum(sub_seq))\n\n    return max(sums)\n```", "```py\n>>> max_subarray([-5, 20, -10, 30, 15])\n([-5], '=>', -5)\n([-5, 20], '=>', 15)\n([-5, 20, -10], '=>', 5)\n([-5, 20, -10, 30], '=>', 35)\n([20], '=>', 20)\n([20, -10], '=>', 10)\n([20, -10, 30], '=>', 40)\n([-10], '=>', -10)\n([-10, 30], '=>', 20)\n([30], '=>', 30)\n40\n```", "```py\n    \"sub_seq = sequence[i:j]\"\n```", "```py\n    \"sub_seq = sequence[i:j+1]\"\n```", "```py\ndef max_subarray(sequence):\n    \"\"\" Find sub-sequence in sequence having maximum sum \"\"\"\n\n    sums = []\n\n    for i in range(len(sequence)):\n        for j in range(i+1, len(sequence)):\n            sub_seq = sequence[i:j+1]\n            sub_seq_sum = sum(sub_seq)\n          print(sub_seq,'=>',sub_seq_sum)\n            sums.append(sub_seq_sum)\n\n    return max(sums)\n```", "```py\n>>> max_subarray([-5, 20, -10, 30, 15])\n([-5, 20], '=>', 15)\n([-5, 20, -10], '=>', 5)\n([-5, 20, -10, 30], '=>', 35)\n([-5, 20, -10, 30, 15], '=>', 50)\n([20, -10], '=>', 10)\n([20, -10, 30], '=>', 40)\n([20, -10, 30, 15], '=>', 55)\n([-10, 30], '=>', 20)\n([-10, 30, 15], '=>', 35)\n([30, 15], '=>', 45)\n55\n```", "```py\ndef max_subarray(sequence):\n    \"\"\" Find sub-sequence in sequence having maximum sum \"\"\"\n\n    # Trackers for max sum and max sub-array\n    max_sum, max_sub = 0, []\n\n    for i in range(len(sequence)):\n        for j in range(i+1, len(sequence)):\n            sub_seq = sequence[i:j+1]\n            sum_s = sum(sub_seq)\n            if sum_s > max_sum:\n                # If current sum > max sum so far, replace the values\n                max_sum, max_sub = sum_s, sub_seq\n\n    return max_sum, max_sub\n\n>>>  max_subarray([-5, 20, -10, 30, 15])\n(55, [20, -10, 30, 15])\n```", "```py\nimport time\nfrom contextlib import contextmanager\n\n@contextmanager\ndef timer():\n    \"\"\" Measure real-time execution of a block of code \"\"\"\n\n    try:\n        start = time.time()\n        yield\n    finally:\n        end = (time.time() - start)*1000\n        print 'time taken=> %.2f ms' % end\n```", "```py\nimport random\n\ndef num_array(size):\n    \"\"\" Return a list of numbers in a fixed random range\n    of given size \"\"\"\n\n    nums = []\n    for i in range(size):\n        nums.append(random.randrange(-25, 30))\n    return nums\n```", "```py\n>>> with timer():\n... max_subarray(num_array(100))\n... (121, [7, 10, -17, 3, 21, 26, -2, 5, 14, 2, -19, -18, 23, 12, 8, -12, -23, 28, -16, -19, -3, 14, 16, -25, 26, -16, 4, 12, -23, 26, 22, 12, 23])\ntime taken=> 16.45 ms\n```", "```py\n>>> with timer():\n... max_subarray(num_array(100))\n... (121, [7, 10, -17, 3, 21, 26, -2, 5, 14, 2, -19, -18, 23, 12, 8, -12, -23, 28, -16, -19, -3, 14, 16, -25, 26, -16, 4, 12, -23, 26, 22, 12, 23])\ntime taken=> 16.45 ms\n```", "```py\ndef max_subarray(sequence):\n    \"\"\" Maximum subarray \u2013 optimized version \"\"\"\n\n    max_ending_here = max_so_far = 0\n\n    for x in sequence:\n        max_ending_here = max(0, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n```", "```py\n>>> with timer():\n... max_subarray(num_array(100))\n... 240\ntime taken=> 0.77 ms\n```", "```py\n>>> with timer():\n... max_subarray(num_array(1000))\n... 2272\ntime taken=> 6.05 ms\n```", "```py\n>>> with timer():\n... max_subarray(num_array(10000))\n... 19362\ntime taken=> 43.89 ms\n```", "```py\nimport os\nimport glob\n\ndef grep_word(word, filenames):\n    \"\"\" Open the given files and look for a specific word.\n    Append lines containing word to a list and\n    return it \"\"\"\n\n    lines, words = [], []\n\n    for filename in filenames:\n        print('Processing',filename)\n        lines += open(filename).readlines()\n\n    word = word.lower()\n    for line in lines:\n        if word in line.lower():\n            lines.append(line.strip())\n\n    # Now sort the list according to length of lines\n    return sorted(words, key=len)\n```", "```py\n>>> parse_filename('lines', glob.glob('*.py'))\n(hangs)\n```", "```py\nimport os\nimport glob\n\ndef grep_word(word, filenames):\n    \"\"\" Open the given files and look for a specific word.\n    Append lines containing word to a list and\n    return it \"\"\"\n\n    lines, words = [], []\n\n    for filename in filenames:\n        print('Processing',filename)\n        lines += open(filename).readlines()\n\n    sys.exit('Exiting after first loop')\n\n    word = word.lower()\n    for line in lines:\n        if word in line.lower():\n            lines.append(line.strip())\n\n    # Now sort the list according to length of lines\n    return sorted(words, key=len)\n```", "```py\n>>> grep_word('lines', glob.glob('*.py'))\nExiting after first loop\n```", "```py\ndef grep_word(word, filenames):\n    \"\"\" Open the given files and look for a specific word.\n    Append lines containing word to a list and\n    return it \"\"\"\n\n    lines, words = [], []\n\n    for filename in filenames:\n        print('Processing',filename)\n        lines += open(filename).readlines()\n\n    # Debugging steps\n    # 1\\. sys.exit\n    # sys.exit('Exiting after first loop')\n\n    word = word.lower()\n    for line in lines:\n        if word in line.lower():\n            words.append(line.strip())\n            continue\n\n    # Now sort the list according to length of lines\n    return sorted(words, key=len)\n\n>>> grep_word('lines', glob.glob('*.py'))\n[]\n```", "```py\ndef grep_word(word, filenames):\n    \"\"\" Open the given files and look for a specific word.\n    Append lines containing word to a list and\n    return it \"\"\"\n\n    lines, words = [], []\n\n    for filename in filenames:\n        print('Processing',filename)\n        lines += open(filename).readlines()\n\n    word = word.lower()\n    for line in lines:\n        if word in line.lower():\n            words.append(line.strip())\n\n    # Now sort the list according to length of lines\n    return sorted(words, key=len)\n```", "```py\n>>> grep_word('lines', glob.glob('*.py'))\n['for line in lines:', 'lines, words = [], []', \n  '#lines.append(line.strip())', \n  'lines += open(filename).readlines()',\n  'Append lines containing word to a list and', \n  'and return list of lines containing the word.', \n  '# Now sort the list according to length of lines', \n  \"print('Lines => ', grep_word('lines', glob.glob('*.py')))\"]\n```", "```py\nif 0:# Suspected code block\n     perform_suspect_operation1(args1, args2, ...)\n     perform_suspect_operation2(\u2026)\n```", "```py\nimport external_api\ndef process_data(data):\n    \"\"\" Process data using external API \"\"\"\n\n    # Clean up data\u2014local function\n    data = clean_up(data)\n    # Drop duplicates from data\u2014local function\n    data = drop_duplicates(data)\n\n    # Process line by line JSON\n    for json_elem in data:\n        # Bug ?\n        external_api.process(json_elem)\n```", "```py\ndef process(json_data, skey='suspect_key',svalue='suspect_value'):\n    \"\"\" Fake the external API except for the suspect key & value \"\"\"\n\n    # Assume each JSON element maps to a Python dictionary\n\n    for json_elem in json_data:\n        skip = False\n\n        for key in json_elem:\n            if key == skey:\n                if json_elem[key] == svalue:\n                    # Suspect key,value combination - dont process\n                    # this JSON element\n                    skip = True\n                    break\n\n        # Pass on to the API\n        if not skip:\n            external_api.process(json_elem)\n\ndef process_data(data):\n    \"\"\" Process data using external API \"\"\"\n\n    # Clean up data\u2014local function\n    data = clean_up(data)\n    # Drop duplicates from data\u2014local function\n    data = drop_duplicates(data)\n\n    # Process line by line JSON using local wrapper\n    process(data)\n```", "```py\nimport config\n\nsearch_api = 'http://api.%(site)s/listings/search'\n\ndef get_api_key(site):\n    \"\"\" Return API key for a site \"\"\"\n\n    # Assumes the configuration is available via a config module\n    return config.get_key(site)\n\ndef api_search(address, site='yellowpages.com'):\n    \"\"\" API to search for a given business address\n    on a site and return results \"\"\"\n\n    req_params = {}\n    req_params.update({\n        'key': get_api_key(site),\n        'term': address['name'],\n        'searchloc': '{0}, {1}, {1}'.format(address['street'],\n                                            address['city'],\n                                            address['state'])})\n    return requests.post(search_api % locals(),\n                         params=req_params)\n\ndef parse_listings(addresses, sites):\n    \"\"\" Given a list of addresses, fetch their listings\n    for a given set of sites, process them \"\"\"\n\n    for site in sites:\n        for address in addresses:\n            listing = api_search(address, site)\n            # Process the listing\n            process_listing(listing, site)\n\ndef process_listings(listing, site):\n    \"\"\" Process a listing and analzye it \"\"\"\n\n     # Some heavy computational code\n     # whose details we are not interested.\n```", "```py\nimport hashlib\nimport json\nimport os\n\ndef unique_key(address, site):\n    \"\"\" Return a unique key for the given arguments \"\"\"\n\n    return hashlib.md5(''.join((address['name'],\n                               address['street'],\n                               address['city'],\n                               site)).encode('utf-8')).hexdigest()\n\ndef filecache(func):\n    \"\"\" A file caching decorator \"\"\"\n\n    def wrapper(*args, **kwargs):\n        # Construct a unique cache filename\n        filename = unique_key(args[0], args[1]) + '.data'\n\n        if os.path.isfile(filename):\n            print('=>from file<=')\n            # Return cached data from file\n            return json.load(open(filename))\n\n        # Else compute and write into file\n        result = func(*args, **kwargs)\n        json.dump(result, open(filename,'w'))\n\n        return result\n\n    return wrapper\n\n@filecache\ndef api_search(address, site='yellowpages.com'):\n    \"\"\" API to search for a given business address\n    on a site and return results \"\"\"\n\n    req_params = {}\n    req_params.update({\n        'key': get_api_key(site),\n        'term': address['name'],\n        'searchloc': '{0}, {1}, {1}'.format(address['street'],\n                                            address['city'],\n                                            address['state'])})\n    return requests.post(search_api % locals(),\n                         params=req_params)\n```", "```py\nfrom redis import StrictRedis\n\ndef memoize(func, ttl=86400):\n    \"\"\" A memory caching decorator \"\"\"\n\n    # Local redis as in-memory cache\n    cache = StrictRedis(host='localhost', port=6379)\n\n    def wrapper(*args, **kwargs):\n        # Construct a unique key\n\n        key = unique_key(args[0], args[1])\n        # Check if its in redis\n        cached_data = cache.get(key)\n        if cached_data != None:\n             print('=>from cache<=')\n             return json.loads(cached_data)\n         # Else calculate and store while putting a TTL\n         result = func(*args, **kwargs)\n         cache.set(key, json.dumps(result), ttl)\n\n         return result\n\n    return wrapper\n```", "```py\n@memoize    \ndef api_search(address, site='yellowpages.com'):\n    \"\"\" API to search for a given business address\n    on a site and return results \"\"\"\n\n    req_params = {}\n    req_params.update({\n        'key': get_api_key(site),\n        'term': address['name'],\n        'searchloc': '{0}, {1}, {1}'.format(address['street'],\n                                            address['city'],\n                                            address['state'])})\n    return requests.post(search_api % locals(),\n                         params=req_params)\n```", "```py\n# Only for testing\u2014comment out after that!\n127.0.0.1 api.website.com\n```", "```py\n**$ pip install schematics**\n\n```", "```py\nfrom schematics import Model\nfrom schematics.types import StringType, DecimalType\n\nclass Person(Model):\n    name = StringType()\n    age = DecimalType()\n```", "```py\n**>>> Person.get_mock_object().to_primitive()**\n**{'age': u'12', 'name': u'Y7bnqRt'}**\n**>>> Person.get_mock_object().to_primitive()**\n**{'age': u'1', 'name': u'xyrh40EO3'}**\n\n```", "```py\nfrom schematics.types import IntType\n\nclass AgeType(IntType):\n    \"\"\" An age type for schematics \"\"\"\n\n    def __init__(self, **kwargs):\n        kwargs['default'] = 18\n        IntType.__init__(self, **kwargs)\n\n    def to_primitive(self, value, context=None):\n        return random.randrange(18, 80)\n```", "```py\nimport string\nimport random\n\nclass NameType(StringType):\n    \"\"\" A schematics custom name type \"\"\"\n\n    vowels='aeiou'\n    consonants = ''.join(set(string.ascii_lowercase) - set(vowels))\n\n    def __init__(self, **kwargs):\n        kwargs['default'] = ''\n        StringType.__init__(self, **kwargs)\n\n   def get_name(self):\n        \"\"\" A random name generator which generates\n        names by clever placing of vowels and consontants \"\"\"\n\n        items = ['']*4\n\n        items[0] = random.choice(self.consonants)\n        items[2] = random.choice(self.consonants)\n\n        for i in (1, 3):\n            items[i] = random.choice(self.vowels)            \n\n        return ''.join(items).capitalize()\n\n    def to_primitive(self, value, context=None):\n        return self.get_name()\n```", "```py\nclass Person(Model):\n    name = NameType()\n    age = AgeType()\n```", "```py\n**>>> Person.get_mock_object().to_primitive()**\n**{'age': 36, 'name': 'Qixi'}**\n**>>> Person.get_mock_object().to_primitive()**\n**{'age': 58, 'name': 'Ziru'}**\n**>>> Person.get_mock_object().to_primitive()**\n**{'age': 32, 'name': 'Zanu'}**\n\n```", "```py\nclass GenderType(BaseType):\n    \"\"\"A gender type for schematics \"\"\"\n\n    def __init__(self, **kwargs):\n        kwargs['choices'] = ['male','female']\n        kwargs['default'] = 'male'\n        BaseType.__init__(self, **kwargs)\n\nclass ConditionType(StringType):\n    \"\"\" A gender type for a health condition \"\"\"\n\n    def __init__(self, **kwargs):\n        kwargs['default'] = 'cardiac'\n        StringType.__init__(self, **kwargs)     \n\n    def to_primitive(self, value, context=None):\n        return random.choice(('cardiac',\n                              'respiratory',\n                              'nasal',\n                              'gynec',\n                              'urinal',\n                              'lungs',\n                              'thyroid',\n                              'tumour'))\n\nimport itertools\n\nclass BloodGroupType(StringType):\n    \"\"\" A blood group type for schematics  \"\"\"\n\n    def __init__(self, **kwargs):\n        kwargs['default'] = 'AB+'\n        StringType.__init__(self, **kwargs)\n\n    def to_primitive(self, value, context=None):\n        return ''.join(random.choice(list(itertools.product(['AB','A','O','B'],['+','-']))))    \n```", "```py\nclass Patient(Model):\n    \"\"\" A model class for patients \"\"\"\n\n    name = NameType()\n    age = AgeType()\n    gender = GenderType()\n    condition = ConditionType()\n    doctor = NameType()\n    blood_group = BloodGroupType()\n    insured = BooleanType(default=True)\n    last_visit = DateTimeType(default='2000-01-01T13:30:30')\n```", "```py\n**patients = map(lambda x: Patient.get_mock_object().to_primitive(), range(n))**\n\n```", "```py\n**>>> patients = map(lambda x: Patient.get_mock_object().to_primitive(), range(1000))**\n\n```", "```py\n**>>> import logging**\n**>>> logging.warning('I will be back!')**\n**WARNING:root:I will be back!**\n\n**>>> logging.info('Hello World')**\n**>>>**\n\n```", "```py\n**>>> logging.basicConfig(filename='application.log', level=logging.DEBUG)**\n**>>> logging.info('Hello World')**\n\n```", "```py\n**INFO:root:Hello World**\n\n```", "```py\n**>>> logging.basicConfig(format='%(asctime)s %(message)s')**\n\n```", "```py\n**>>> logging.basicConfig(format='%(asctime)s %(message)s', filename='application.log', level=logging.DEBUG)**\n**>>> logging.info('Hello World!')**\n\n```", "```py\n**INFO:root:Hello World**\n**2016-12-26 19:10:37,236 Hello World!**\n\n```", "```py\n**>>> import logging**\n**>>> logging.basicConfig(level=logging.DEBUG)**\n**>>> x,y=10,20**\n**>>> logging.info('Addition of',x,'and',y,'produces',x+y)**\n**--- Logging error ---**\n**Traceback (most recent call last):**\n **File \"/usr/lib/python3.5/logging/__init__.py\", line 980, in emit**\n **msg = self.format(record)**\n **File \"/usr/lib/python3.5/logging/__init__.py\", line 830, in format**\n **return fmt.format(record)**\n **File \"/usr/lib/python3.5/logging/__init__.py\", line 567, in format**\n **record.message = record.getMessage()**\n **File \"/usr/lib/python3.5/logging/__init__.py\", line 330, in getMessage**\n **msg = msg % self.args**\n**TypeError: not all arguments converted during string formatting**\n**Call stack:**\n **File \"<stdin>\", line 1, in <module>**\n**Message: 'Addition of'**\n**Arguments: (10, 'and', 20, 'produces', 30)**\n\n```", "```py\n**>>> logging.info('Addition of %s and %s produces %s',x,y,x+y)**\n**INFO:root:Addition of 10 and 20 produces 30**\n\n```", "```py\nimport logging\ndef create_logger(app_name, logfilename=None, \n                             level=logging.INFO, console=False):\n\n    \"\"\" Build and return a custom logger. Accepts the application name,\n    log filename, loglevel and console logging toggle \"\"\"\n\n    log=logging.getLogger(app_name)\n    log.setLevel(logging.DEBUG)\n    # Add file handler\n    if logfilename != None:\n        log.addHandler(logging.FileHandler(logfilename))\n\n    if console:\n        log.addHandler(logging.StreamHandler())\n\n    # Add formatter\n    for handle in log.handlers:\n        formatter = logging.Formatter('%(asctime)s : %(levelname)-8s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S')\n\n        handle.setFormatter(formatter)\n\n    return log\n```", "```py\n**>>> log=create_logger('myapp',logfilename='app.log', console=True)**\n**>>> log**\n**<logging.Logger object at 0x7fc09afa55c0>**\n**>>> log.info('Started application')**\n**2016-12-26 19:38:12 : INFO     - Started application**\n**>>> log.info('Initializing objects...')**\n**2016-12-26 19:38:25 : INFO     - Initializing objects\u2026**\n\n```", "```py\n**2016-12-26 19:38:12 : INFO    \u2014Started application**\n**2016-12-26 19:38:25 : INFO    \u2014Initializing objects\u2026**\n\n```", "```py\nimport logging\nimport time\nfrom functools import partial\n\nclass LoggerWrapper(object):\n    \"\"\" A wrapper class for logger objects with\n    calculation of time spent in each step \"\"\"\n\n    def __init__(self, app_name, filename=None, \n                       level=logging.INFO, console=False):\n        self.log = logging.getLogger(app_name)\n        self.log.setLevel(level)\n\n        # Add handlers\n        if console:\n            self.log.addHandler(logging.StreamHandler())\n\n        if filename != None:\n            self.log.addHandler(logging.FileHandler(filename))\n\n        # Set formatting\n        for handle in self.log.handlers:\n\n          formatter = logging.Formatter('%(asctime)s [%(timespent)s]: %(levelname)-8s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S')                                   \n             handle.setFormatter(formatter)\n\n        for name in ('debug','info','warning','error','critical'):\n            # Creating convenient wrappers by using functools\n            func = partial(self._dolog, name)\n            # Set on this class as methods\n            setattr(self, name, func)\n\n        # Mark timestamp\n        self._markt = time.time()\n\n    def _calc_time(self):\n        \"\"\" Calculate time spent so far \"\"\"\n\n        tnow = time.time()\n        tdiff = int(round(tnow - self._markt))\n\n        hr, rem = divmod(tdiff, 3600)\n        mins, sec = divmod(rem, 60)\n        # Reset mark\n        self._markt = tnow\n        return '%.2d:%.2d:%.2d' % (hr, mins, sec)\n\n    def _dolog(self, levelname, msg, *args, **kwargs):\n        \"\"\" Generic method for logging at different levels \"\"\"\n\n        logfunc = getattr(self.log, levelname)\n        return logfunc(msg, *args, extra={'timespent': self._calc_time()})         \n```", "```py\n    # Application code\n    log=LoggerWrapper('myapp', filename='myapp.log',console=True)\n\n    app = Flask(__name__)\n    log.info(\"Starting application...\")\n    log.info(\"Initializing objects.\")\n    init()\n    log.info(\"Initialization complete.\")\n    log.info(\"Loading configuration and data \u2026\")\n    load_objects()\n    log.info('Loading complete. Listening for connections \u2026')\n    mainloop()\n```", "```py\n**2016-12-26 20:08:28 [00:00:00]: INFO    \u2014Starting application...**\n**2016-12-26 20:08:28 [00:00:00]: INFO     - Initializing objects.**\n**2016-12-26 20:08:42 [00:00:14]: INFO     - Initialization complete.**\n**2016-12-26 20:08:42 [00:00:00]: INFO     - Loading configuration and data ...**\n**2016-12-26 20:10:37 [00:01:55]: INFO     - Loading complete. Listening for connections**\n\n```", "```py\nlog.addHandler(logging.handlers.SysLogHandler(address='/dev/log'))\n```", "```py\nimport logging\nimport logging.handlers\n\ndef create_logger(app_name, logfilename=None, level=logging.INFO, \n                             console=False, syslog=False):\n    \"\"\" Build and return a custom logger. Accepts the application name,\n    log filename, loglevel and console logging toggle and syslog toggle \"\"\"\n\n    log=logging.getLogger(app_name)\n    log.setLevel(logging.DEBUG)\n    # Add file handler\n    if logfilename != None:\n        log.addHandler(logging.FileHandler(logfilename))\n\n    if syslog:\n        log.addHandler(logging.handlers.SysLogHandler(address='/dev/log'))\n\n    if console:\n        log.addHandler(logging.StreamHandler())\n\n    # Add formatter\n    for handle in log.handlers:\n        formatter = logging.Formatter('%(asctime)s : %(levelname)-8s - %(message)s',  datefmt='%Y-%m-%d %H:%M:%S')\n        handle.setFormatter(formatter)                             \n\n    return log\n```", "```py\n>>> create_logger('myapp',console=True, syslog=True)\n>>> log.info('Myapp - starting up\u2026')\n```", "```py\n**$ tail -3 /var/log/syslog**\n**Dec 26 20:39:54 ubuntu-pro-book kernel: [36696.308437] psmouse serio1: TouchPad at isa0060/serio1/input0 - driver resynced.**\n**Dec 26 20:44:39 ubuntu-pro-book 2016-12-26 20:44:39 : INFO     - Myapp - starting up...**\n**Dec 26 20:45:01 ubuntu-pro-book CRON[11522]: (root) CMD (command -v debian-sa1 > /dev/null && debian-sa1 1 1)**\n\n```", "```py\n**$ python3 -m pdb script.py**\n\n```", "```py\nimport pdb; pdb.set_trace()\n```", "```py\ndef max_subarray(sequence):\n    \"\"\" Maximum subarray - optimized version \"\"\"\n\n    max_ending_here = max_so_far = 0\n    for x in sequence:\n        # Enter the debugger\n        import pdb; pdb.set_trace()\n        max_ending_here = max(0, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n```", "```py\n**>>> max_subarray([20, -5, -10, 30, 10])**\n**> /home/user/programs/maxsubarray.py(8)max_subarray()**\n**-> max_ending_here = max(0, max_ending_here + x)**\n**-> for x in sequence:**\n**(Pdb) max_so_far**\n**20**\n\n```", "```py\n**> /home/user/programs/maxsubarray.py(7)max_subarray()**\n**-> max_ending_here = max(0, max_ending_here + x)**\n\n```", "```py\n**(Pdb) max_so_far**\n**20**\n\n```", "```py\n**(Pdb) w**\n\n**<stdin>(1)<module>()**\n**> /home/user/programs/maxsubarray.py(7)max_subarray()**\n**-> max_ending_here = max(0, max_ending_here + x)**\n\n```", "```py\n> /home/user/programs/maxsubarray.py(6)max_subarray()\n**-> for x in sequence:**\n**(Pdb) max_so_far**\n**20**\n**(Pdb) c**\n**> /home/user/programs/maxsubarray.py(6)max_subarray()**\n**-> for x in sequence:**\n**(Pdb) max_so_far**\n**20**\n**(Pdb) c**\n**> /home/user/programs/maxsubarray.py(6)max_subarray()**\n**-> for x in sequence:**\n**(Pdb) max_so_far**\n**35**\n**(Pdb) max_ending_here**\n**35**\n\n```", "```py\n**(Pdb) x**\n**30**\n\n```", "```py\n(Pdb) l\n  1     \n  2     def max_subarray(sequence):\n  3         \"\"\" Maximum subarray - optimized version \"\"\"\n  4     \n  5         max_ending_here = max_so_far = 0\n  6  ->     for x in sequence:\n  7             max_ending_here = max(0, max_ending_here + x)\n  8             max_so_far = max(max_so_far, max_ending_here)\n  9             import pdb; pdb.set_trace()\n 10     \n 11         return max_so_far\n```", "```py\n**(Pdb) up**\n**> <stdin>(1)<module>()**\n**(Pdb) up**\n***** Oldest frame**\n**(Pdb) list**\n**[EOF]**\n**(Pdb) d**\n**> /home/user/programs/maxsubarray.py(6)max_subarray()**\n**-> for x in sequence:**\n\n```", "```py\n**(Pdb) r**\n**> /home/user/programs/maxsubarray.py(6)max_subarray()**\n**-> for x in sequence:**\n**(Pdb) r**\n**--Return--**\n**> /home/user/programs/maxsubarray.py(11)max_subarray()->45**\n**-> return max_so_far**\n\n```"]