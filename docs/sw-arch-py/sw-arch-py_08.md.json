["```py\nfrom django.db import models\n\nclass GlossaryTerm(models.Model):\n    \"\"\" Model for describing a glossary word (term) \"\"\"\n\n    term = models.CharField(max_length=1024)\n    meaning = models.CharField(max_length=1024)\n    meaning_html = models.CharField('Meaning with HTML markup',\n                    max_length=4096, null=True, blank=True)\n    example = models.CharField(max_length=4096, null=True, blank=True)\n\n    # can be a ManyToManyField?\n    domains = models.CharField(max_length=128, null=True, blank=True)\n\n    notes = models.CharField(max_length=2048, null=True, blank=True)\n    url = models.CharField('URL', max_length=2048, null=True, blank=True)\n    name = models.ForeignKey('GlossarySource', verbose_name='Source', blank=True)\n\n    def __unicode__(self):\n        return self.term\n\n    class Meta:\n        unique_together = ('term', 'meaning', 'url')\n```", "```py\nfrom django.contrib import admin\n\nadmin.site.register(GlossaryTerm)\nadmin.site.register(GlossarySource)\n```", "```py\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    data = 'some data'\n    return render_template('index.html', **locals())\n```", "```py\n# chatserver.py\n\nimport socket\nimport select\nimport signal\nimport sys\nfrom communication import send, receive\n\nclass ChatServer(object):\n    \"\"\" Simple chat server using select \"\"\"\n\n    def serve(self):\n        inputs = [self.server,sys.stdin]\n        self.outputs = []\n\n        while True:\n\n                inputready,outputready,exceptready = select.select(inputs, self.outputs, [])\n\n            for s in inputready:\n\n                if s == self.server:\n                    # handle the server socket\n                    client, address = self.server.accept()\n\n                    # Read the login name\n                    cname = receive(client).split('NAME: ')[1]\n\n                    # Compute client name and send back\n                    self.clients += 1\n                    send(client, 'CLIENT: ' + str(address[0]))\n                    inputs.append(client)\n\n                    self.clientmap[client] = (address, cname)\n                    self.outputs.append(client)\n\n                elif s == sys.stdin:\n                    # handle standard input \u2013 the server exits \n                    junk = sys.stdin.readline()\n\t\t  break\n                else:\n                    # handle all other sockets\n                    try:\n                        data = receive(s)\n                        if data:\n                            # Send as new client's message...\n                            msg = '\\n#[' + self.get_name(s) + ']>> ' + data\n                            # Send data to all except ourselves\n                            for o in self.outputs:\n                                if o != s:\n                                    send(o, msg)\n                        else:\n                            print('chatserver: %d hung up' % s.fileno())\n                            self.clients -= 1\n                            s.close()\n                            inputs.remove(s)\n                            self.outputs.remove(s)\n\n                    except socket.error as e:\n                        # Remove\n                        inputs.remove(s)\n                        self.outputs.remove(s)\n\n        self.server.close()\n\nif __name__ == \"__main__\":\n    ChatServer().serve()\n```", "```py\n# chatclient.py\nimport socket\nimport select\nimport sys\nfrom communication import send, receive\n\nclass ChatClient(object):\n    \"\"\" A simple command line chat client using select \"\"\"\n\n    def __init__(self, name, host='127.0.0.1', port=3490):\n        self.name = name\n        # Quit flag\n        self.flag = False\n        self.port = int(port)\n        self.host = host\n        # Initial prompt\n        self.prompt='[' + '@'.join((name, socket.gethostname().split('.')[0])) + ']> '\n        # Connect to server at port\n        try:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.sock.connect((host, self.port))\n            print('Connected to chat server@%d' % self.port)\n            # Send my name...\n            send(self.sock,'NAME: ' + self.name) \n            data = receive(self.sock)\n            # Contains client address, set it\n            addr = data.split('CLIENT: ')[1]\n            self.prompt = '[' + '@'.join((self.name, addr)) + ']> '\n        except socket.error as e:\n            print('Could not connect to chat server @%d' % self.port)\n            sys.exit(1)\n\n    def chat(self):\n        \"\"\" Main chat method \"\"\"\n\n        while not self.flag:\n            try:\n                sys.stdout.write(self.prompt)\n                sys.stdout.flush()\n\n                # Wait for input from stdin & socket\n                inputready, outputready,exceptrdy = select.select([0, self.sock], [],[])\n\n                for i in inputready:\n                    if i == 0:\n                        data = sys.stdin.readline().strip()\n                        if data: send(self.sock, data)\n                    elif i == self.sock:\n                        data = receive(self.sock)\n                        if not data:\n                            print('Shutting down.')\n                            self.flag = True\n                            break\n                        else:\n                            sys.stdout.write(data + '\\n')\n                            sys.stdout.flush()\n\n            except KeyboardInterrupt:\n                print('Interrupted.')\n                self.sock.close()\n                break\n\nif __name__ == \"__main__\":\n    if len(sys.argv)<3:\n        sys.exit('Usage: %s chatid host portno' % sys.argv[0])\n\n    client = ChatClient(sys.argv[1],sys.argv[2], int(sys.argv[3]))\n    client.chat()\n```", "```py\n# communication.py\nimport pickle\nimport socket\nimport struct\n\ndef send(channel, *args):\n    \"\"\" Send a message to a channel \"\"\"\n\n    buf = pickle.dumps(args)\n    value = socket.htonl(len(buf))\n    size = struct.pack(\"L\",value)\n    channel.send(size)\n    channel.send(buf)\n\ndef receive(channel):\n    \"\"\" Receive a message from a channel \"\"\"\n\n    size = struct.calcsize(\"L\")\n    size = channel.recv(size)\n    try:\n        size = socket.ntohl(struct.unpack(\"L\", size)[0])\n    except struct.error as e:\n        return ''\n\n    buf = \"\"\n\n    while len(buf) < size:\n        buf = channel.recv(size - len(buf))\n\n    return pickle.loads(buf)[0]\n```", "```py\nwhile True:\n    timeout = time_until_next_timed_event()\n    events = wait_for_events(timeout)\n    events += timed_events_until(now())\n    for event in events:\n        event.process()\n```", "```py\n# twisted_fetch_url.py\nfrom twisted.internet import reactor\nfrom twisted.web.client import getPage\nimport sys\n\ndef save_page(page, filename='content.html'):\n    print type(page)\n    open(filename,'w').write(page)\n    print 'Length of data',len(page)\n    print 'Data saved to',filename\n\ndef handle_error(error):\n    print error\n\ndef finish_processing(value):\n    print \"Shutting down...\"\n    reactor.stop()\n\nif __name__ == \"__main__\":\n    url = sys.argv[1]\n    deferred = getPage(url) \n    deferred.addCallbacks(save_page, handle_error)\n    deferred.addBoth(finish_processing)\n\n    reactor.run()\n```", "```py\n    $ python2 twisted_fetch_url.py http://www.google.com\n    Length of data 13280\n    Data saved to content.html\n    Shutting down...\n    ```", "```py\nfrom twisted.internet import protocol, reactor\n\nclass Chat(protocol.Protocol):\n    \"\"\" Chat protocol \"\"\"\n\n    transports = {}\n    peers = {}\n\n    def connectionMade(self):\n        self._peer = self.transport.getPeer()\n        print 'Connected',self._peer\n\n    def connectionLost(self, reason):\n        self._peer = self.transport.getPeer()\n        # Find out and inform other clients\n        user = self.peers.get((self._peer.host, self._peer.port))\n        if user != None:\n            self.broadcast('(User %s disconnected)\\n' % user, user)\n            print 'User %s disconnected from %s' % (user, self._peer)\n\n    def broadcast(self, msg, user):\n        \"\"\" Broadcast chat message to all connected users except 'user' \"\"\"\n\n        for key in self.transports.keys():\n            if key != user:\n                if msg != \"<handshake>\":\n                    self.transports[key].write('#[' + user + \"]>>> \" + msg)\n                else:\n                    # Inform other clients of connection\n                    self.transports[key].write('(User %s connected from %s)\\n' % (user, self._peer))                \n\n    def dataReceived(self, data):\n        \"\"\" Callback when data is ready to be read from the socket \"\"\"\n\n        user, msg = data.split(\":\")\n        print \"Got data=>\",msg,\"from\",user\n        self.transports[user] = self.transport\n        # Make an entry in the peers dictionary\n        self.peers[(self._peer.host, self._peer.port)] = user\n        self.broadcast(msg, user)\n\nclass ChatFactory(protocol.Factory):\n    \"\"\" Chat protocol factory \"\"\"\n\n    def buildProtocol(self, addr):\n        return Chat()\n\nif __name__ == \"__main__\":\n    reactor.listenTCP(3490, ChatFactory())\n    reactor.run()\n```", "```py\nimport sys\nimport socket\nfrom twisted.internet import stdio, reactor, protocol\n\nclass ChatProtocol(protocol.Protocol):\n    \"\"\" Base protocol for chat \"\"\"\n\n    def __init__(self, client):\n        self.output = None\n        # Client name: E.g: andy\n        self.client = client\n        self.prompt='[' + '@'.join((self.client, socket.gethostname().split('.')[0])) + ']> '             \n\n    def input_prompt(self):\n        \"\"\" The input prefix for client \"\"\"\n        sys.stdout.write(self.prompt)\n        sys.stdout.flush()\n\n    def dataReceived(self, data):\n        self.processData(data)\n\nclass ChatClientProtocol(ChatProtocol):\n    \"\"\" Chat client protocol \"\"\"\n\n    def connectionMade(self):\n        print 'Connection made'\n        self.output.write(self.client + \":<handshake>\")\n\n    def processData(self, data):\n        \"\"\" Process data received \"\"\"\n\n        if not len(data.strip()):\n            return\n\n        self.input_prompt()\n\n        if self.output:\n            # Send data in this form to server\n            self.output.write(self.client + \":\" + data)\n\nclass StdioClientProtocol(ChatProtocol):\n    \"\"\" Protocol which reads data from input and echoes\n    data to standard output \"\"\"\n\n    def connectionMade(self):\n        # Create chat client protocol\n        chat = ChatClientProtocol(client=sys.argv[1])\n        chat.output = self.transport\n\n        # Create stdio wrapper\n        stdio_wrapper = stdio.StandardIO(chat)\n        # Connect to output\n        self.output = stdio_wrapper\n        print \"Connected to server\"\n        self.input_prompt()\n\n    def input_prompt(self):\n        # Since the output is directly connected\n        # to stdout, use that to write.\n        self.output.write(self.prompt)\n\n    def processData(self, data):\n        \"\"\" Process data received \"\"\"\n\n        if self.output:\n            self.output.write('\\n' + data)\n            self.input_prompt()\n\nclass StdioClientFactory(protocol.ClientFactory):\n\n    def buildProtocol(self, addr):\n        return StdioClientProtocol(sys.argv[1])\n\ndef main():\n    reactor.connectTCP(\"localhost\", 3490, StdioClientFactory())\n    reactor.run()\n\nif __name__ == '__main__':\n    main()\n\n```", "```py\n# eventlet_chat.py\n\nimport eventlet\nfrom eventlet.green import socket\n\nparticipants = set()\n\ndef new_chat_channel(conn):\n    \"\"\" New chat channel for a given connection \"\"\"\n\n    data = conn.recv(1024)\n    user = ''\n\n    while data:\n        print(\"Chat:\", data.strip())\n        for p in participants:\n            try:\n                if p is not conn:\n                    data = data.decode('utf-8')\n                    user, msg = data.split(':')\n                    if msg != '<handshake>':\n                        data_s = '\\n#[' + user + ']>>> says ' + msg\n                    else:\n                        data_s = '(User %s connected)\\n' % user\n\n                    p.send(bytearray(data_s, 'utf-8'))\n            except socket.error as e:\n                # ignore broken pipes, they just mean the participant\n                # closed its connection already\n                if e[0] != 32:\n                    raise\n        data = conn.recv(1024)\n\n    participants.remove(conn)\n    print(\"Participant %s left chat.\" % user)\n\nif __name__ == \"__main__\":\n    port = 3490\n    try:\n        print(\"ChatServer starting up on port\", port)\n        server = eventlet.listen(('0.0.0.0', port))\n\n        while True:\n            new_connection, address = server.accept()\n            print(\"Participant joined chat.\")\n            participants.add(new_connection)\n            print(eventlet.spawn(new_chat_channel,\n                                 new_connection))\n\n    except (KeyboardInterrupt, SystemExit):\n        print(\"ChatServer exiting.\")\n```", "```py\n# gevent_chat_server.py\n\nimport gevent\nfrom gevent import monkey\nfrom gevent import socket\nfrom gevent.server import StreamServer\n\nmonkey.patch_all()\n\nparticipants = set()\n\ndef new_chat_channel(conn, address):\n    \"\"\" New chat channel for a given connection \"\"\"\n\n    participants.add(conn)\n    data = conn.recv(1024)\n    user = ''\n\n    while data:\n        print(\"Chat:\", data.strip())\n        for p in participants:\n            try:\n                if p is not conn:\n                    data = data.decode('utf-8')\n                    user, msg = data.split(':')\n                    if msg != '<handshake>':\n                        data_s = '\\n#[' + user + ']>>> says ' + msg\n                    else:\n                        data_s = '(User %s connected)\\n' % user\n\n                    p.send(bytearray(data_s, 'utf-8'))                  \n            except socket.error as e:\n                # ignore broken pipes, they just mean the participant\n                # closed its connection already\n                if e[0] != 32:\n                    raise\n        data = conn.recv(1024)\n\n    participants.remove(conn)\n    print(\"Participant %s left chat.\" % user)\n\nif __name__ == \"__main__\":\n    port = 3490\n    try:\n        print(\"ChatServer starting up on port\", port)\n        server = StreamServer(('0.0.0.0', port), new_chat_channel)\n        server.serve_forever()\n    except (KeyboardInterrupt, SystemExit):\n        print(\"ChatServer exiting.\")\n```", "```py\nGET /restaurants?geohash=tdr1y1g1zgzc\n\n{\n    \"8f95e6ad-17a7-48a9-9f82-07972d2bc660\": {\n        \"name\": \"Tandoor\",\n        \"address\": \"Centenary building, #28, MG Road b-01\"\n        \"hours\": \"12.00 \u2013 23.30\"\n\t},\n  \"4307a4b1-6f35-481b-915b-c57d2d625e93\": {\n        \"name\": \"Karavalli\",\n        \"address\": \"The Gateway Hotel, 66, Ground Floor\"\n        \"hours\": \"12.30 \u2013 01:00\"\n\t},\n   ...\n} \n```", "```py\nGET /restaurants/8f95e6ad-17a7-48a9-9f82-07972d2bc660\n\n{\n\n   \"name\": \"Tandoor\",\n   \"address\": \"Centenary building, #28, MG Road b-01\"\n   \"hours\": \"12.00 \u2013 23.30\",\n   \"rating\": 4.5,\n   \"cuisine\": \"north indian\",\n   \"lunch buffet\": \"no\",\n   \"dinner buffet\": \"no\",\n   \"price\": 800\n\n} \n```", "```py\nPOST  /restaurants/reserve\n```", "```py\n{\n   \"name\": \"Anand B Pillai\",\n   \"phone\": 9880078014,\n   \"time\": \"2017-04-14 20:40:00\",\n   \"seats\": 3,\n   \"id\": \"8f95e6ad-17a7-48a9-9f82-07972d2bc660\"\n} \n\n```", "```py\n{\n   \"status\": \"confirmed\",\n   \"code\": \"WJ7D2B\",\n   \"time\": \"2017-04-14 20:40:00\",\n   \"seats\": 3\n}\n```", "```py\n**$ cat filename | wc -w**\n\n```", "```py\n# pipe_words.py\nfrom multiprocessing import Process, Pipe\nimport sys\n\ndef read(filename, conn):\n    \"\"\" Read data from a file and send it to a pipe \"\"\"\n\n    conn.send(open(filename).read())\n\ndef words(conn):\n    \"\"\" Read data from a connection and print number of words \"\"\"\n\n    data = conn.recv()\n    print('Words',len(data.split()))\n\nif __name__ == \"__main__\":\n    parent, child = Pipe()\n    p1 = Process(target=read, args=(sys.argv[1], child))\n    p1.start()\n    p2 = Process(target=words, args=(parent,))\n    p2.start()\n    p1.join();p2.join()\n```", "```py\n# pipe_words_gen.py\n\n# A simple data processing pipeline using generators\n# to print count of words in files matching a pattern.\nimport os\n\ndef read(filenames):\n    \"\"\" Generator that yields data from filenames as (filename, data) tuple \"\"\"\n\n    for filename in filenames:\n        yield filename, open(filename).read()\n\ndef words(input):\n    \"\"\" Generator that calculates words in its input \"\"\"\n\n    for filename, data in input:\n        yield filename, len(data.split())\n\ndef filter(input, pattern):\n    \"\"\" Filter input stream according to a pattern \"\"\"\n\n    for item in input:\n        if item.endswith(pattern):\n            yield item\n\nif __name__ == \"__main__\":\n    # Source\n    stream1 = filter(os.listdir('.'), '.py')\n    # Piped to next filter\n    stream2 = read(stream1)\n    # Piped to last filter (sink)\n    stream3 = words(stream2)\n\n    for item in stream3:\n        print(item)\n```", "```py\n**$ wc -w *.py**\n\n```", "```py\n# pipe_recent_gen.py\n# Using generators, print details of the most recently modified file\n# matching a pattern.\n\nimport glob\nimport os\nfrom time import sleep\n\ndef watch(pattern):\n    \"\"\" Watch a folder for modified files matching a pattern \"\"\"\n\n    while True:\n        files = glob.glob(pattern)\n        # sort by modified time\n        files = sorted(files, key=os.path.getmtime)\n        recent = files[-1]\n        yield recent        \n        # Sleep a bit\n        sleep(1)\n\ndef get(input):\n    \"\"\" For a given file input, print its meta data \"\"\"\n    for item in input:\n        data = os.popen(\"ls -lh \" + item).read()\n        # Clear screen\n        os.system(\"clear\")\n        yield data\n\nif __name__ == \"__main__\":\n    import sys\n\n    # Source + Filter #1\n    stream1 = watch('*.' + sys.argv[1])\n\n    while True:\n        # Filter #2 + sink\n        stream2 = get(stream1)\n        print(stream2.__next__())\n        sleep(2)\n```"]