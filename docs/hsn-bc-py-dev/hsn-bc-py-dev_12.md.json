["```py\n$ virtualenv -p python3.6 token-venv\n$ source token-venv/bin/activate\n(token-venv) $ pip install eth-abi==1.2.2\n(token-venv) $ pip install eth-typing==1.1.0\n(token-venv) $ pip install py-evm==0.2.0a33\n(token-venv) $ pip install web3==4.7.2\n(token-venv) $ pip install -e git+https://github.com/ethereum/populus#egg=populus\n(token-venv) $ pip install vyper\n(token-venv) $ mkdir token_project\n(token-venv) $ cd token_project\n(token-venv) $ mkdir tests contracts\n(token-venv) $ cp ../token-venv/src/populus/populus/assets/defaults.v9.config.json project.json\n```", "```py\n\"compilation\": {\n    \"backend\": {\n      \"class\": \"populus.compilation.backends.VyperBackend\"\n    },\n    \"contract_source_dirs\": [\n      \"./contracts\"\n    ],\n    \"import_remappings\": []\n},\n```", "```py\n(token-venv) $ cd voting-venv/src/populus\n(token-venv) $ grep -R \"compile(\" populus/compilation/backends/vyper.py\n bytecode = '0x' + compiler.compile(code).hex()\n bytecode_runtime = '0x' + compiler.compile(code, bytecode_runtime=True).hex()\n```", "```py\n(token-venv) $ wget https://patch-diff.githubusercontent.com/raw/ethereum/populus/pull/484.patch\n(token-venv) $ git apply 484.patch\n(token-venv) $ cd ../../../\n```", "```py\n(token-venv) $ populus chain new localblock\n```", "```py\n(token-venv) $ ./chains/localblock/init_chain.sh\n```", "```py\n(voting-venv) $ ./chains/localblock/run_chain.sh\n```", "```py\n    \"localblock\": {\n      \"chain\": {\n        \"class\": \"populus.chain.ExternalChain\"\n      },\n      \"web3\": {\n        \"provider\": {\n          \"class\": \"web3.providers.ipc.IPCProvider\",\n        \"settings\": {\n          \"ipc_path\":\"/tmp/geth.ipc\"\n        }\n       }\n      },\n      \"contracts\": {\n        \"backends\": {\n          \"JSONFile\": {\"$ref\": \"contracts.backends.JSONFile\"},\n          \"ProjectContracts\": {\n            \"$ref\": \"contracts.backends.ProjectContracts\"\n          }\n        }\n      }\n    }\n```", "```py\n$ dpkg -i Mist-linux64-0-11-1.deb\n```", "```py\n$ ethereumwallet --rpc /tmp/geth.ipc\n```", "```py\nbalances: public(map(address, uint256))\n\n@public\ndef __init__():\n    self.balances[msg.sender] = 10000\n\n@public\ndef transfer(_to: address, _amount: uint256) -> bool:\n    assert self.balances[msg.sender] >= _amount\n\n    self.balances[msg.sender] -= _amount\n    self.balances[_to] += _amount\n\n    return True\n```", "```py\nbalances: public(map(address, uint256))\nowner: address\n\n@public\ndef __init__():\n    self.balances[msg.sender] = 10000\n    self.owner = msg.sender\n\n@public\ndef transfer(_to: address, _amount: uint256) -> bool:\n    assert self.balances[msg.sender] >= _amount\n\n    self.balances[msg.sender] -= _amount\n    self.balances[_to] += _amount\n\n    return True\n\n@public\ndef mint(_new_supply: uint256):\n    assert msg.sender == self.owner\n    self.balances[msg.sender] = _new_supply\n```", "```py\nimport pytest\nimport eth_tester\n\ndef test_balance(web3, chain):\n    simple_token, _ = chain.provider.get_or_deploy_contract('SimpleToken')\n\n...\n...\n\n    with pytest.raises(eth_tester.exceptions.TransactionFailed):\n        simple_token.functions.transfer(web3.eth.coinbase, 10).transact({'from': account2})\n```", "```py\nfunction totalSupply() public view returns (uint256)\nfunction balanceOf(address _owner) public view returns (uint256 balance)\nfunction transfer(address _to, uint256 _value) public returns (bool success)\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success)\nfunction approve(address _spender, uint256 _value) public returns (bool success)\nfunction allowance(address _owner, address _spender) public view returns (uint256 remaining)\nevent Transfer(address indexed _from, address indexed _to, uint256 _value)\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value)\n```", "```py\nfunction name() public view returns (string)\nfunction symbol() public view returns (string)\nfunction decimals() public view returns (uint8)\n```", "```py\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\n\n...\n...\n\n@public\n@constant\ndef allowance(_owner: address, _spender: address) -> uint256:\n    return self.allowed[_owner][_spender]\n```", "```py\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\n```", "```py\nname: public(bytes[10])\nsymbol: public(bytes[3])\ntotalSupply: public(uint256)\ndecimals: public(uint256)\nbalances: map(address, uint256)\nallowed: map(address, map(address, uint256))\n```", "```py\n@public\ndef __init__():\n    _initialSupply: uint256 = 1000\n    _decimals: uint256 = 3\n    self.totalSupply = _initialSupply * 10 ** _decimals\n    self.balances[msg.sender] = self.totalSupply\n    self.name = 'Haha Coin'\n    self.symbol = 'HAH'\n    self.decimals = _decimals\n    log.Transfer(ZERO_ADDRESS, msg.sender, self.totalSupply)\n```", "```py\n@public\n@constant\ndef balanceOf(_owner: address) -> uint256:\n    return self.balances[_owner]\n```", "```py\n@public\ndef transfer(_to: address, _amount: uint256) -> bool:\n    assert self.balances[msg.sender] >= _amount\n    self.balances[msg.sender] -= _amount\n    self.balances[_to] += _amount\n    log.Transfer(msg.sender, _to, _amount)\n\n    return True\n```", "```py\n@public\ndef transferFrom(_from: address, _to: address, _value: uint256) -> bool:\n    assert _value <= self.allowed[_from][msg.sender]\n    assert _value <= self.balances[_from]\n\n    self.balances[_from] -= _value\n    self.allowed[_from][msg.sender] -= _value\n    self.balances[_to] += _value\n    log.Transfer(_from, _to, _value)\n\n    return True\n\n@public\ndef approve(_spender: address, _amount: uint256) -> bool:\n    self.allowed[msg.sender][_spender] = _amount\n    log.Approval(msg.sender, _spender, _amount)\n\n    return True\n```", "```py\nself.allowed[msg.sender][_spender] = _amount\n```", "```py\nassert _value <= self.allowed[_from][msg.sender]\n```", "```py\nassert _value <= self.balances[_from]\n```", "```py\n    self.balances[_from] -= _value\n    self.allowed[_from][msg.sender] -= _value\n    self.balances[_to] += _value\n    log.Transfer(_from, _to, _value)\n```", "```py\n@public\n@constant\ndef allowance(_owner: address, _spender: address) -> uint256:\n    return self.allowed[_owner][_spender]\n```", "```py\nimport pytest\nimport eth_tester\n\ndef test_balance(web3, chain):\n    erc20_token, _ = chain.provider.get_or_deploy_contract('ERC20Token')\n\n    token_name = erc20_token.functions.name().call()\n    token_symbol = erc20_token.functions.symbol().call()\n    decimals = erc20_token.functions.decimals().call()\n    total_supply = erc20_token.functions.totalSupply().call()\n    balance = erc20_token.functions.balanceOf(web3.eth.coinbase).call()\n\n...\n...\n\n    assert balance_account1 == 999990\n    assert balance_account2 == 0\n    assert balance_account3 == 10\n    assert allowance == 90\n```", "```py\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\nPayment: event({_buyer: indexed(address), _value: uint256(wei)})\n\nname: public(bytes[10])\nsymbol: public(bytes[3])\ntotalSupply: public(uint256)\ndecimals: public(uint256)\nbalances: map(address, uint256)\nethBalances: public(map(address, uint256(wei)))\nallowed: map(address, map(address, uint256))\n\n...\n...\n\n@public\n@constant\ndef allowance(_owner: address, _spender: address) -> uint256:\n    return self.allowed[_owner][_spender]\n```", "```py\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\nPayment: event({_buyer: indexed(address), _value: uint256(wei)})\n```", "```py\nname: public(bytes[10])\nsymbol: public(bytes[3])\ntotalSupply: public(uint256)\ndecimals: public(uint256)\nbalances: map(address, uint256)\nethBalances: public(map(address, uint256(wei)))\nallowed: map(address, map(address, uint256))\n\nbeneficiary: public(address)\nminFundingGoal: public(uint256(wei))\nmaxFundingGoal: public(uint256(wei))\namountRaised: public(uint256(wei))\ndeadline: public(timestamp)\nprice: public(uint256(wei))\nfundingGoalReached: public(bool)\ncrowdsaleClosed: public(bool)\n```", "```py\n@public\ndef __init__():\n    _initialSupply: uint256 = 100\n    _decimals: uint256 = 2\n    self.totalSupply = _initialSupply * 10 ** _decimals\n    self.name = 'Haha Coin'\n    self.symbol = 'HAH'\n    self.decimals = _decimals\n    self.beneficiary = msg.sender\n    self.balances[msg.sender] = self.totalSupply\n    self.minFundingGoal = as_wei_value(30, \"ether\")\n    self.maxFundingGoal = as_wei_value(50, \"ether\")\n    self.amountRaised = 0\n    self.deadline = block.timestamp + 3600 * 24 * 100 # 100 days\n    self.price = as_wei_value(1, \"ether\") / 100\n    self.fundingGoalReached = False\n    self.crowdsaleClosed = False\n```", "```py\n@public\n@payable\ndef __default__():\n    assert msg.sender != self.beneficiary\n    assert self.crowdsaleClosed == False\n    assert self.amountRaised + msg.value < self.maxFundingGoal\n    assert msg.value >= as_wei_value(0.01, \"ether\")\n    self.ethBalances[msg.sender] += msg.value\n    self.amountRaised += msg.value\n    tokenAmount: uint256 = msg.value / self.price\n    self.balances[msg.sender] += tokenAmount\n    self.balances[self.beneficiary] -= tokenAmount\n    log.Payment(msg.sender, msg.value)\n```", "```py\n@public\ndef checkGoalReached():\n    assert block.timestamp > self.deadline\n    if self.amountRaised >= self.minFundingGoal:\n        self.fundingGoalReached = True\n    self.crowdsaleClosed = True\n```", "```py\n@public\ndef safeWithdrawal():\n    assert self.crowdsaleClosed == True\n    if self.fundingGoalReached == False:\n        if msg.sender != self.beneficiary:\n            if self.ethBalances[msg.sender] > 0:\n                self.ethBalances[msg.sender] = 0\n                self.balances[self.beneficiary] += self.balances[msg.sender]\n                self.balances[msg.sender] = 0\n                send(msg.sender, self.ethBalances[msg.sender])\n    if self.fundingGoalReached == True:\n        if msg.sender == self.beneficiary:\n            if self.balance > 0:\n                send(msg.sender, self.balance)\n```", "```py\nimport pytest\nimport eth_tester\nimport time\n\ndef test_initialization(web3, chain):\n    crowd_sale_token, _ = chain.provider.get_or_deploy_contract('CrowdSaleToken')\n\n...\n...\n\n    assert abs(beforeCrowdsaleEthBalanceAccount2 - afterCrowdsaleEthBalanceAccount2 - web3.toWei('40', 'ether')) < web3.toWei('1', 'gwei')\n    assert abs(afterCrowdsaleEthBalanceAccount1 - beforeCrowdsaleEthBalanceAccount1 - web3.toWei('40', 'ether')) < web3.toWei('1', 'gwei')\n```", "```py\n    # move forward 101 days\n    web3.testing.timeTravel(int(time.time()) + 3600 * 24 * 101)\n    web3.testing.mine(1)\n```", "```py\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\nFreeze: event({_account: indexed(address), _freeze: bool})\n\nname: public(bytes[10])\nsymbol: public(bytes[3])\ntotalSupply: public(uint256)\ndecimals: public(uint256)\nbalances: map(address, uint256)\nallowed: map(address, map(address, uint256))\nfrozenBalances: public(map(address, bool))\nowner: public(address)\n\n...\n...\n\n@public\n@constant\ndef allowance(_owner: address, _spender: address) -> uint256:\n    return self.allowed[_owner][_spender]\n```", "```py\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\nFreeze: event({_account: indexed(address), _freeze: bool})\n```", "```py\nname: public(bytes[10])\nsymbol: public(bytes[3])\ntotalSupply: public(uint256)\ndecimals: public(uint256)\nbalances: map(address, uint256)\nallowed: map(address, map(address, uint256))\nfrozenBalances: public(map(address, bool))\nowner: public(address)\n```", "```py\n@public\ndef __init__():\n    _initialSupply: uint256 = 1000\n    _decimals: uint256 = 3\n    self.totalSupply = _initialSupply * 10 ** _decimals\n    self.balances[msg.sender] = self.totalSupply\n    self.name = 'Haha Coin'\n    self.symbol = 'HAH'\n    self.decimals = _decimals\n    self.owner = msg.sender\n    log.Transfer(ZERO_ADDRESS, msg.sender, self.totalSupply)\n```", "```py\n@public\ndef freezeBalance(_target: address, _freeze: bool) -> bool:\n    assert msg.sender == self.owner\n    self.frozenBalances[_target] = _freeze\n    log.Freeze(_target, _freeze)\n\n    return True\n```", "```py\n@public\ndef mintToken(_mintedAmount: uint256) -> bool:\n    assert msg.sender == self.owner\n    self.totalSupply += _mintedAmount\n    self.balances[msg.sender] += _mintedAmount\n    log.Transfer(ZERO_ADDRESS, msg.sender, _mintedAmount)\n\n    return True\n```", "```py\n@public\ndef burn(_burntAmount: uint256) -> bool:\n    assert msg.sender == self.owner\n    assert self.balances[msg.sender] >= _burntAmount\n    self.totalSupply -= _burntAmount\n    self.balances[msg.sender] -= _burntAmount\n    log.Transfer(msg.sender, ZERO_ADDRESS, _burntAmount)\n\n    return True\n```", "```py\nassert self.frozenBalances[msg.sender] == False\n```", "```py\nimport pytest\nimport eth_tester\nimport time\n\ndef test_initialization(web3, chain):\n    stable_coin, _ = chain.provider.get_or_deploy_contract('StableCoin')\n\n...\n...\n\n    new_total_supply = stable_coin.functions.totalSupply().call()\n    assert new_total_supply == 999900\n```"]