["```py\n$ virtualenv -p python3.6 voting-venv\n$ source voting-venv/bin/activate (voting-venv) $ pip install eth-abi==1.2.2 (voting-venv) $ pip install eth-typing==1.1.0 (voting-venv) $ pip install web3==4.7.2 (voting-venv) $ pip install -e git+https://github.com/ethereum/populus#egg=populus (voting-venv) $ pip install vyper\n(voting-venv) $ mkdir voting_project\n(voting-venv) $ cd voting_project\n(voting-venv) $ mkdir tests contracts\n(voting-venv) $ cp ../voting-venv/src/populus/populus/assets/defaults.v9.config.json project.json\n```", "```py\n\"compilation\": {\n    \"backend\": {\n      \"class\": \"populus.compilation.backends.VyperBackend\"\n    },\n    \"contract_source_dirs\": [\n      \"./contracts\"\n    ],\n    \"import_remappings\": []\n},\n```", "```py\n(voting-venv) $ cd voting-venv/src/populus\n(voting-venv) $ grep -R \"compile(\" populus/compilation/backends/vyper.py\n            bytecode = '0x' + compiler.compile(code).hex()\n            bytecode_runtime = '0x' + compiler.compile(code, bytecode_runtime=True).hex()\n```", "```py\n(voting-venv) $ wget https://patch-diff.githubusercontent.com/raw/ethereum/populus/pull/484.patch\n(voting-venv) $ git apply 484.patch\n```", "```py\nstruct Proposal:\n    name: bytes32\n    vote_count: int128\n\nVoting: event ({_from: indexed(address), _proposal: int128})\n\nproposals: public(map(int128, Proposal))\n\nproposals_count: public(int128)\nvoters_voted: public(map(address, int128))\n\n...\n...\n\n@public\n@constant\ndef winner_name() -> bytes32:\n    return self.proposals[self.winning_proposal()].name\n\n```", "```py\nstruct Proposal:\n    name: bytes32\n    vote_count: int128\n```", "```py\nVoting: event ({_from: indexed(address), _proposal: int128})\n```", "```py\nproposals: public(map(int128, Proposal))\n```", "```py\nproposals_count: public(int128)\n```", "```py\nvoters_voted: public(int128[address])\n```", "```py\n@public\ndef __init__(_proposalNames: bytes32[2]):\n    for i in range(2):\n        self.proposals[i] = Proposal({\n            name: _proposalNames[i],\n            vote_count: 0\n        })\n        self.proposals_count += 1\n```", "```py\n@public\ndef vote(proposal: int128):\n    assert self.voters_voted[msg.sender] == 0\n    assert proposal < self.proposals_count\n\n    self.voters_voted[msg.sender] = 1\n    self.proposals[proposal].vote_count += 1\n\n    log.Voting(msg.sender, proposal)\n```", "```py\n@private\n@constant\ndef winning_proposal() -> int128:\n    winning_vote_count: int128 = 0\n    winning_proposal: int128 = 0\n    for i in range(2):\n        if self.proposals[i].vote_count > winning_vote_count:\n            winning_vote_count = self.proposals[i].vote_count\n            winning_proposal = i\n    return winning_proposal\n```", "```py\n@public\n@constant\ndef winner_name() -> bytes32:\n    return self.proposals[self.winning_proposal()].name\n```", "```py\n(voting-venv) $ populus compile\n```", "```py\nimport pytest\nimport eth_tester\n\n@pytest.fixture()\ndef voting(chain):\n    SimpleVotingFactory = chain.provider.get_contract_factory('SimpleVoting')\n    deploy_txn_hash = SimpleVotingFactory.constructor([b'Messi', b'Ronaldo']).transact()\n    contract_address = chain.wait.for_contract_address(deploy_txn_hash)\n    return SimpleVotingFactory(address=contract_address)\n...\n...\n    assert voting.functions.proposals__vote_count(0).call() == 2\n    assert voting.functions.proposals__vote_count(1).call() == 1\n    assert voting.functions.winner_name().call()[:5] == b'Messi'\n```", "```py\n@pytest.fixture()\ndef voting(chain):\n    SimpleVotingFactory = chain.provider.get_contract_factory('SimpleVoting')\n    deploy_txn_hash = SimpleVotingFactory.constructor([b'Messi', b'Ronaldo']).transact()\n    contract_address = chain.wait.for_contract_address(deploy_txn_hash)\n    return SimpleVotingFactory(address=contract_address)\n```", "```py\ndef test_initial_state(voting):\n    assert voting.functions.proposals_count().call() == 2\n\n    messi = voting.functions.proposals__name(0).call()\n    assert len(messi) == 32\n    assert messi[:5] == b'Messi'\n    assert voting.functions.proposals__name(1).call()[:7] == b'Ronaldo'\n    assert voting.functions.proposals__vote_count(0).call() == 0\n    assert voting.functions.proposals__vote_count(1).call() == 0\n```", "```py\ndef test_vote(voting, chain):\n    t = eth_tester.EthereumTester()\n    account2 = t.get_accounts()[1]\n\n    assert voting.functions.proposals__vote_count(0).call() == 0\n\n    set_txn_hash = voting.functions.vote(0).transact({'from': account2})\n    chain.wait.for_receipt(set_txn_hash)\n\n    assert voting.functions.proposals__vote_count(0).call() == 1\n```", "```py\ndef test_fail_duplicate_vote(voting, chain):\n    t = eth_tester.EthereumTester()\n    account2 = t.get_accounts()[1]\n\n    set_txn_hash = voting.functions.vote(0).transact({'from': account2})\n    chain.wait.for_receipt(set_txn_hash)\n\n    with pytest.raises(eth_tester.exceptions.TransactionFailed):\n        voting.functions.vote(1).transact({'from': account2})\n\n    with pytest.raises(eth_tester.exceptions.TransactionFailed):\n        voting.functions.vote(0).transact({'from': account2})\n```", "```py\ndef test_winning_proposal(voting, chain):\n    t = eth_tester.EthereumTester()\n    account2 = t.get_accounts()[1]\n    account3 = t.get_accounts()[2]\n    account4 = t.get_accounts()[3]\n\n    set_txn_hash = voting.functions.vote(0).transact({'from': account2})\n    chain.wait.for_receipt(set_txn_hash)\n\n    set_txn_hash = voting.functions.vote(0).transact({'from': account3})\n    chain.wait.for_receipt(set_txn_hash)\n\n    set_txn_hash = voting.functions.vote(1).transact({'from': account4})\n    chain.wait.for_receipt(set_txn_hash)\n\n    assert voting.functions.proposals__vote_count(0).call() == 2\n    assert voting.functions.proposals__vote_count(1).call() == 1\n    assert voting.functions.winner_name().call()[:5] == b'Messi'\n```", "```py\n(voting-venv) $ populus chain new localblock\n```", "```py\n(voting-venv) $ ./chains/localblock/init_chain.sh\n```", "```py\n(voting-venv) $ ./chains/localblock/run_chain.sh\n```", "```py\n    \"localblock\": {\n      \"chain\": {\n        \"class\": \"populus.chain.ExternalChain\"\n      },\n      \"web3\": {\n        \"provider\": {\n          \"class\": \"web3.providers.ipc.IPCProvider\",\n        \"settings\": {\n          \"ipc_path\":\"/tmp/geth.ipc\"\n        }\n       }\n      },\n      \"contracts\": {\n        \"backends\": {\n          \"JSONFile\": {\"$ref\": \"contracts.backends.JSONFile\"},\n          \"ProjectContracts\": {\n            \"$ref\": \"contracts.backends.ProjectContracts\"\n          }\n        }\n      }\n    }\n```", "```py\nfrom populus import Project\nfrom populus.utils.wait import wait_for_transaction_receipt\n\ndef main():\n\n    project = Project()\n\n    chain_name = \"localblock\"\n\n    with project.get_chain(chain_name) as chain:\n\n        SimpleVoting = chain.provider.get_contract_factory('SimpleVoting')\n\n        txhash = SimpleVoting.deploy(transaction={\"from\": chain.web3.eth.coinbase}, args=[[b'Messi', b'Ronaldo']])\n        receipt = wait_for_transaction_receipt(chain.web3, txhash)\n        simple_voting_address = receipt[\"contractAddress\"]\n        print(\"SimpleVoting contract address is\", simple_voting_address)\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\nfrom populus import Project\nfrom populus.utils.wait import wait_for_transaction_receipt\n```", "```py\ndef main():\n\n    project = Project()\n\n    chain_name = \"localblock\"\n\n    with project.get_chain(chain_name) as chain:\n```", "```py\n    \"localblock\": {\n      \"chain\": {\n        \"class\": \"populus.chain.ExternalChain\"\n      },\n      \"web3\": {\n        \"provider\": {\n          \"class\": \"web3.providers.ipc.IPCProvider\",\n        \"settings\": {\n          \"ipc_path\":\"/tmp/geth.ipc\"\n        }\n       }\n      },\n      \"contracts\": {\n        \"backends\": {\n          \"JSONFile\": {\"$ref\": \"contracts.backends.JSONFile\"},\n          \"ProjectContracts\": {\n            \"$ref\": \"contracts.backends.ProjectContracts\"\n          }\n        }\n      }\n    }\n```", "```py\nSimpleVoting = chain.provider.get_contract_factory('SimpleVoting')\n```", "```py\ntxhash = SimpleVoting.deploy(transaction={\"from\": chain.web3.eth.coinbase}, args=[[b'Messi', b'Ronaldo']])\n```", "```py\n@public\ndef __init__(_proposalNames: bytes32[2]):\n    for i in range(2):\n        self.proposals[i] = {\n            name: _proposalNames[i],\n            vote_count: 0\n        }\n        self.proposals_count += 1\n\nreceipt = wait_for_transaction_receipt(chain.web3, txhash)\n```", "```py\nsimple_voting_address = receipt[\"contractAddress\"]\nprint(\"SimpleVoting contract address is\", simple_voting_address)\n```", "```py\nif __name__ == \"__main__\":\n    main()\n```", "```py\nfrom web3 import Web3, IPCProvider\n\nw3 = Web3(IPCProvider(ipc_path='/tmp/geth.ipc'))\n\nprint(w3.fromWei(w3.eth.getBalance(w3.eth.coinbase), 'ether'))\n```", "```py\nfrom web3 import Web3, IPCProvider\n\nw3 = Web3(IPCProvider(ipc_path='/tmp/geth.ipc'))\n\nwith open('10_accounts.txt', 'w') as f:\n    for i in range(10):\n        f.write(w3.personal.newAccount('password123') + \"\\n\")\n```", "```py\nfrom web3 import Web3, IPCProvider\nfrom populus.utils.wait import wait_for_transaction_receipt\nimport glob\n\nw3 = Web3(IPCProvider(ipc_path='/tmp/geth.ipc'))\n\naddress = 'fa146d7af4b92eb1751c3c9c644fa436a60f7b75'\n\n...\n...\n\n        signed = w3.eth.account.signTransaction(transaction, private_key)\n        txhash = w3.eth.sendRawTransaction(signed.rawTransaction)\n        wait_for_transaction_receipt(w3, txhash)\n```", "```py\nfrom web3 import Web3, IPCProvider\nfrom populus.utils.wait import wait_for_transaction_receipt\nimport glob\n```", "```py\nw3 = Web3(IPCProvider(ipc_path='/tmp/geth.ipc'))\n```", "```py\naddress = 'fa146d7af4b92eb1751c3c9c644fa436a60f7b75'\n```", "```py\nwith open('chains/localblock/password') as f:\n    password = f.read().rstrip(\"\\n\")\n```", "```py\n    encrypted_private_key_file = glob.glob('chains/localblock/chain_data/keystore/*' + address)[0]\n    with open(encrypted_private_key_file) as f2:\n        private_key = w3.eth.account.decrypt(f2.read(), password)\n```", "```py\nw3.eth.defaultAccount = w3.eth.coinbase\n```", "```py\nwith open('10_accounts.txt', 'r') as f:\n    accounts = f.readlines()\n    for account in accounts:\n```", "```py\n        nonce = w3.eth.getTransactionCount(Web3.toChecksumAddress(w3.eth.defaultAccount))\n        transaction = {\n          'to': Web3.toChecksumAddress(account.rstrip(\"\\n\")),\n          'value': w3.toWei('10', 'ether'),\n          'gas': 1000000,\n          'gasPrice': w3.toWei('20', 'gwei'),\n          'nonce': nonce\n        }\n```", "```py\n        signed = w3.eth.account.signTransaction(transaction, private_key)\n        txhash = w3.eth.sendRawTransaction(signed.rawTransaction)\n```", "```py\nwait_for_transaction_receipt(w3, txhash)\n```", "```py\n(voting-venv) $ mkdir voting_dapp\n(voting-venv) $ cd voting_dapp\n```", "```py\nfrom web3 import Web3, IPCProvider\n\nw3 = Web3(IPCProvider(ipc_path='/tmp/geth.ipc'))\n\nfalse = False\ntrue = True\nabi = \u2026. # Take the abi from voting_projects/build/contracts.json.\n\nwith open('address.txt', 'r') as f:\n    content = f.read().rstrip(\"\\n\")\n\naddress = content\n\nSimpleVoting = w3.eth.contract(address=address, abi=abi)\n\nevent_filter = SimpleVoting.events.Voting.createFilter(fromBlock=1)\n\nimport time\nwhile True:\n    print(event_filter.get_new_entries())\n    time.sleep(2)\n```", "```py\nfrom web3 import Web3, IPCProvider\n\nw3 = Web3(IPCProvider(ipc_path='/tmp/geth.ipc'))\n\nWe connect to private Ethereum blockchain using socket.\n\nfalse = False\ntrue = True\nabi = \u2026. # Take the abi from voting_projects/build/contracts.json.\n```", "```py\nwith open('address.txt', 'r') as f:\n    content = f.read().rstrip(\"\\n\")\n\naddress = content\n```", "```py\naddress = '0x993FFADB39D323D8B134F6f0CdD83d510c45D306'\n```", "```py\nevent_filter = SimpleVoting.events.Voting.createFilter(fromBlock=1)\n```", "```py\n<name of smart contract>.events.<name of event>.createFilter(fromBlock=1)\n```", "```py\nimport time\nwhile True:\n    print(event_filter.get_new_entries())\n    time.sleep(2)\n```", "```py\n[]\n[]\n[]\n```", "```py\nfrom web3 import Web3, IPCProvider\nfrom populus.utils.wait import wait_for_transaction_receipt\nimport glob\n\nw3 = Web3(IPCProvider(ipc_path='/tmp/geth.ipc'))\n\nwith open('client_address.txt', 'r') as f:\n    content = f.read().rstrip(\"\\n\")\n\naddress = content.lower()\n\n...\n...\n\nsigned = w3.eth.account.signTransaction(txn, private_key=private_key)\nw3.eth.sendRawTransaction(signed.rawTransaction)\n```", "```py\nfrom web3 import Web3, IPCProvider\nfrom populus.utils.wait import wait_for_transaction_receipt\nimport glob\n\nw3 = Web3(IPCProvider(ipc_path='/tmp/geth.ipc'))\n\nwith open('client_address.txt', 'r') as f:\n    content = f.read().rstrip(\"\\n\")\n\naddress = content.lower()\n\nencrypted_private_key_file = glob.glob('../voting_project/chains/localblock/chain_data/keystore/*' + address)[0]\nwith open(encrypted_private_key_file) as f:\n    password = 'password123'\n    private_key = w3.eth.account.decrypt(f.read(), password)\n    w3.eth.defaultAccount = '0x' + address\n```", "```py\nfalse = False\ntrue = True\nabi = \u2026\n```", "```py\nwith open('address.txt', 'r') as f:\n    content = f.read().rstrip(\"\\n\")\n\nsmart_contract_address = content\n\nSimpleVoting = w3.eth.contract(address=smart_contract_address, abi=abi)\n```", "```py\nnonce = w3.eth.getTransactionCount(Web3.toChecksumAddress(w3.eth.defaultAccount))\n```", "```py\ntxn = SimpleVoting.functions.vote(0).buildTransaction({\n        'gas': 70000,\n        'gasPrice': w3.toWei('1', 'gwei'),\n        'nonce': nonce\n      })\n```", "```py\nsigned = w3.eth.account.signTransaction(txn, private_key=private_key)\nw3.eth.sendRawTransaction(signed.rawTransaction)\n```", "```py\n[]\n[]\n[]\n[]\n[AttributeDict({'args': AttributeDict({'_from': '0xf0738EF5635f947f13dD41F34DAe6B2caa0a9EA6', '_proposal': 0}), 'event': 'Voting', 'logIndex': 0, 'transactionIndex': 0, 'transactionHash': HexBytes('0x61b4c59425a6305af4f2560d1cd10d1540243b1f74ce07fa53a550ada2e649e7'), 'address': '0x993FFADB39D323D8B134F6f0CdD83d510c45D306', 'blockHash': HexBytes('0xb458542d9bee85ed7673d94f036e55f8daca188e5871cc910eb49cf4895964a0'), 'blockNumber': 3110})]\n[]\n[]\n[]\n[]\n[]\n[]\n```", "```py\nimport time\nwhile True:\n    print(event_filter.get_new_entries())\n    time.sleep(2)\n```", "```py\nevent_filter.get_all_entries()\n```", "```py\nstruct Proposal:\n    name: bytes32\n    vote_count: int128\n\nproposals: public(map(int128, Proposal))\n\nvoters_voted: public(map(address, int128))\n\nmanager: public(address)\n\n...\n...\n\n@public\ndef withdraw_money():\n    assert msg.sender == self.manager\n\n    send(self.manager, self.balance)\n```", "```py\n@public\ndef __init__(_proposalNames: bytes32[2]):\n    for i in range(2):\n        self.proposals[i] = Proposal({\n            name: _proposalNames[i],\n            vote_count: 0\n        })\n    self.manager = msg.sender\n```", "```py\n@public\n@payable\ndef vote(proposal: int128):\n    assert msg.value >= as_wei_value(0.01, \"ether\")\n    assert self.voters_voted[msg.sender] == 0\n    assert proposal < 2 and proposal >= 0\n\n    self.voters_voted[msg.sender] = 1\n    self.proposals[proposal].vote_count += 1\n```", "```py\n@public\ndef withdraw_money():\n    assert msg.sender == self.manager\n\n    send(self.manager, self.balance)\n```", "```py\nimport pytest\nimport eth_tester\n\n@pytest.fixture()\ndef voting(chain):\n    CommercialVotingFactory = chain.provider.get_contract_factory('CommercialVoting')\n    deploy_txn_hash = CommercialVotingFactory.constructor([b'Messi', b'Ronaldo']).transact()\n    contract_address = chain.wait.for_contract_address(deploy_txn_hash)\n    return CommercialVotingFactory(address=contract_address)\n\n...\n...\n\n    assert abs((after_withdraw_balance - initial_balance) - web3.toWei('1', 'ether')) < web3.toWei('10', 'gwei')\n```", "```py\ndef test_initial_state(voting, web3):\n    assert voting.functions.manager().call() == web3.eth.coinbase\n```", "```py\ndef test_vote_with_money(voting, chain, web3):\n    t = eth_tester.EthereumTester()\n    account2 = t.get_accounts()[1]\n    account3 = t.get_accounts()[2]\n\n    set_txn_hash = voting.functions.vote(0).transact({'from': account2,\n                                                      'value': web3.toWei('0.05', 'ether')})\n    chain.wait.for_receipt(set_txn_hash)\n\n    set_txn_hash = voting.functions.vote(1).transact({'from': account3,\n                                                      'value': web3.toWei('0.15', 'ether')})\n    chain.wait.for_receipt(set_txn_hash)\n\n    assert web3.eth.getBalance(voting.address) == web3.toWei('0.2', 'ether')\n```", "```py\ndef test_vote_with_not_enough_money(voting, web3):\n    t = eth_tester.EthereumTester()\n    account2 = t.get_accounts()[1]\n\n    with pytest.raises(eth_tester.exceptions.TransactionFailed):\n        voting.functions.vote(0).transact({'from': account2,\n                                           'value': web3.toWei('0.005', 'ether')})\n```", "```py\ndef test_manager_account_could_withdraw_money(voting, web3, chain):\n    t = eth_tester.EthereumTester()\n    account2 = t.get_accounts()[1]\n\n    set_txn_hash = voting.functions.vote(0).transact({'from': account2, 'value': web3.toWei('1', 'ether')})\n    chain.wait.for_receipt(set_txn_hash)\n\n    initial_balance = web3.eth.getBalance(web3.eth.coinbase)\n    set_txn_hash = voting.functions.withdraw_money().transact({'from': web3.eth.coinbase})\n    chain.wait.for_receipt(set_txn_hash)\n    after_withdraw_balance = web3.eth.getBalance(web3.eth.coinbase)\n\n    assert abs((after_withdraw_balance - initial_balance) - web3.toWei('1', 'ether')) < web3.toWei('10', 'gwei')\n```", "```py\nstruct Proposal:\n    name: bytes32\n    vote_count: int128\n\nproposals: public(map(int128, Proposal))\n\n...\n...\n@public\n@constant\ndef winner_name() -> bytes32:\n    return self.proposals[self.winning_proposal()].name\n```", "```py\nstruct Proposal:\n    name: bytes32\n    vote_count: int128\n\nproposals: public(map(int128, Proposal))\n\ntoken: public(map(address, bool))\nindex: int128\nmaximum_token: int128\nmanager: address\n```", "```py\n@public\ndef __init__(_proposalNames: bytes32[2]):\n    for i in range(2):\n        self.proposals[i] = Proposal({\n            name: _proposalNames[i],\n            vote_count: 0\n        })\n    self.index = 0\n    self.maximum_token = 8\n    self.manager = msg.sender\n```", "```py\n@public\ndef assign_token(target: address):\n    assert msg.sender == self.manager\n    assert self.index < self.maximum_token\n    assert not self.token[target]\n    self.token[target] = True\n    self.index += 1\n```", "```py\n@public\ndef vote(proposal: int128):\n    assert self.index == self.maximum_token\n    assert self.token[msg.sender]\n    assert proposal < 2 and proposal >= 0\n\n    self.token[msg.sender] = False\n    self.proposals[proposal].vote_count += 1\n```", "```py\nimport pytest\nimport eth_tester\n\n@pytest.fixture()\ndef voting(chain):\n    TokenBasedVotingFactory = chain.provider.get_contract_factory('TokenBasedVoting')\n    deploy_txn_hash = TokenBasedVotingFactory.constructor([b'Messi', b'Ronaldo']).transact()\n    contract_address = chain.wait.for_contract_address(deploy_txn_hash)\n    return TokenBasedVotingFactory(address=contract_address)\n\n...\n...\n\n    set_txn_hash = voting.functions.vote(0).transact({'from': account2})\n    chain.wait.for_receipt(set_txn_hash)\n```", "```py\nimport pytest\nimport eth_tester\n\n@pytest.fixture()\ndef voting(chain):\n    TokenBasedVotingFactory = chain.provider.get_contract_factory('TokenBasedVoting')\n    deploy_txn_hash = TokenBasedVotingFactory.constructor([b'Messi', b'Ronaldo']).transact()\n    contract_address = chain.wait.for_contract_address(deploy_txn_hash)\n    return TokenBasedVotingFactory(address=contract_address)\n```", "```py\ndef assign_tokens(voting, chain, web3):\n    t = eth_tester.EthereumTester()\n    accounts = t.get_accounts()\n\n    for i in range(1, 9):\n        set_txn_hash = voting.functions.assign_token(accounts[i]).transact({'from': web3.eth.coinbase})\n        chain.wait.for_receipt(set_txn_hash)\n```", "```py\ndef test_assign_token(voting, chain):\n    t = eth_tester.EthereumTester()\n    account2 = t.get_accounts()[1]\n\n    assert not voting.functions.token(account2).call()\n\n    set_txn_hash = voting.functions.assign_token(account2).transact({})\n    chain.wait.for_receipt(set_txn_hash)\n\n    assert voting.functions.token(account2).call()\n```", "```py\ndef test_cannot_vote_without_token(voting, chain, web3):\n    t = eth_tester.EthereumTester()\n    account10 = t.get_accounts()[9]\n\n    assign_tokens(voting, chain, web3)\n\n    with pytest.raises(eth_tester.exceptions.TransactionFailed):\n        voting.functions.vote(0).transact({'from': account10})\n```", "```py\ndef test_can_vote_with_token(voting, chain, web3):\n    t = eth_tester.EthereumTester()\n    account2 = t.get_accounts()[1]\n\n    assign_tokens(voting, chain, web3)\n\n    assert voting.functions.proposals__vote_count(0).call() == 0\n\n    set_txn_hash = voting.functions.vote(0).transact({'from': account2})\n    chain.wait.for_receipt(set_txn_hash)\n\n    assert voting.functions.proposals__vote_count(0).call() == 1\n```", "```py\nfrom web3 import Web3, HTTPProvider\n\nw3 = Web3(HTTPProvider('http://127.0.0.1:8545'))\nprint(w3.eth.getCode('0x891dfe5Dbf551E090805CEee41b94bB2205Bdd17'))\n```"]