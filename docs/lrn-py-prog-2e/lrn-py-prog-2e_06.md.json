["```py\n# decorators/time.measure.start.py\nfrom time import sleep, time\n\ndef f():\n    sleep(.3)\n\ndef g():\n    sleep(.5)\n\nt = time()\nf()\nprint('f took:', time() - t)  # f took: 0.3001396656036377\n\nt = time()\ng()\nprint('g took:', time() - t)  # g took: 0.5039339065551758\n```", "```py\n# decorators/time.measure.dry.py\nfrom time import sleep, time\n\ndef f():\n    sleep(.3)\n\ndef g():\n    sleep(.5)\n\ndef measure(func):\n    t = time()\n    func()\n    print(func.__name__, 'took:', time() - t)\n\nmeasure(f)  # f took: 0.30434322357177734\nmeasure(g)  # g took: 0.5048270225524902\n```", "```py\n# decorators/time.measure.arguments.py\nfrom time import sleep, time\n\ndef f(sleep_time=0.1):\n    sleep(sleep_time)\n\ndef measure(func, *args, **kwargs):\n    t = time()\n    func(*args, **kwargs)\n    print(func.__name__, 'took:', time() - t)\n\nmeasure(f, sleep_time=0.3)  # f took: 0.30056095123291016\nmeasure(f, 0.2)  # f took: 0.2033553123474121\n```", "```py\n# decorators/time.measure.deco1.py\nfrom time import sleep, time\n\ndef f(sleep_time=0.1):\n    sleep(sleep_time)\n\ndef measure(func):\n    def wrapper(*args, **kwargs):\n        t = time()\n        func(*args, **kwargs)\n        print(func.__name__, 'took:', time() - t)\n    return wrapper\n\nf = measure(f)  # decoration point\n\n```", "```py\nf(0.2)  # f took: 0.20372915267944336\nf(sleep_time=0.3)  # f took: 0.30455899238586426\nprint(f.__name__)  # wrapper <- ouch!\n```", "```py\n# decorators/syntax.py\ndef func(arg1, arg2, ...):\n    pass\nfunc = decorator(func)\n\n# is equivalent to the following:\n\n@decorator\ndef func(arg1, arg2, ...):\n    pass\n```", "```py\n# decorators/syntax.py\ndef func(arg1, arg2, ...):\n    pass\nfunc = deco1(deco2(func))\n\n# is equivalent to the following:\n\n@deco1\n@deco2\ndef func(arg1, arg2, ...):\n    pass\n```", "```py\n# decorators/syntax.py\ndef func(arg1, arg2, ...):\n    pass\nfunc = decoarg(arg_a, arg_b)(func)\n\n# is equivalent to the following:\n\n@decoarg(arg_a, arg_b)\ndef func(arg1, arg2, ...):\n    pass\n```", "```py\n# decorators/time.measure.deco2.py\nfrom time import sleep, time\nfrom functools import wraps\n\ndef measure(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        t = time()\n        func(*args, **kwargs)\n        print(func.__name__, 'took:', time() - t)\n    return wrapper\n\n@measure\ndef f(sleep_time=0.1):\n    \"\"\"I'm a cat. I love to sleep! \"\"\"\n    sleep(sleep_time)\n\nf(sleep_time=0.3)  # f took: 0.3010902404785156\nprint(f.__name__, ':', f.__doc__)  # f : I'm a cat. I love to sleep!\n```", "```py\n# decorators/two.decorators.py\nfrom time import sleep, time\nfrom functools import wraps\n\ndef measure(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        t = time()\n        result = func(*args, **kwargs)\n        print(func.__name__, 'took:', time() - t)\n        return result\n    return wrapper\n\ndef max_result(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        if result > 100:\n            print('Result is too big ({0}). Max allowed is 100.'\n                  .format(result))\n        return result\n    return wrapper\n\n@measure\n@max_result\ndef cube(n):\n    return n ** 3\n\nprint(cube(2))\nprint(cube(5))\n```", "```py\n$ python two.decorators.py\ncube took: 3.0994415283203125e-06\n8 \nResult is too big (125). Max allowed is 100.\ncube took: 1.0013580322265625e-05\n125\n```", "```py\n# decorators/decorators.factory.py\nfrom functools import wraps\n\ndef max_result(threshold):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            if result > threshold:\n                print(\n                    'Result is too big ({0}). Max allowed is {1}.'\n                    .format(result, threshold))\n            return result\n        return wrapper\n    return decorator\n\n@max_result(75)\ndef cube(n):\n    return n ** 3\n\nprint(cube(5))\n```", "```py\n$ python decorators.factory.py\nResult is too big (125). Max allowed is 75.\n125\n```", "```py\n# decorators/decorators.factory.py\n@max_result(75)\ndef cube(n):\n    return n ** 3\n\n@max_result(100)\ndef square(n):\n    return n ** 2\n\n@max_result(1000)\ndef multiply(a, b):\n    return a * b\n```", "```py\n# oop/simplest.class.py\nclass Simplest():  # when empty, the braces are optional\n    pass\n\nprint(type(Simplest))  # what type is this object?\nsimp = Simplest()  # we create an instance of Simplest: simp\nprint(type(simp))  # what type is simp?\n# is simp an instance of Simplest?\nprint(type(simp) == Simplest)  # There's a better way for this\n```", "```py\n$ python simplest.class.py\n<class 'type'>\n<class '__main__.Simplest'>\nTrue\n```", "```py\n# oop/class.namespaces.py\nclass Person:\n    species = 'Human'\n\nprint(Person.species)  # Human\nPerson.alive = True  # Added dynamically!\nprint(Person.alive)  # True\n\nman = Person()\nprint(man.species)  # Human (inherited)\nprint(man.alive)  # True (inherited)\n\nPerson.alive = False\nprint(man.alive)  # False (inherited)\n\nman.name = 'Darth'\nman.surname = 'Vader'\nprint(man.name, man.surname)  # Darth Vader\n```", "```py\n# oop/class.attribute.shadowing.py\nclass Point:\n    x = 10\n    y = 7\n\np = Point()\nprint(p.x)  # 10 (from class attribute)\nprint(p.y)  # 7 (from class attribute)\n\np.x = 12  # p gets its own `x` attribute\nprint(p.x)  # 12 (now found on the instance)\nprint(Point.x)  # 10 (class attribute still the same)\n\ndel p.x  # we delete instance attribute\nprint(p.x)  # 10 (now search has to go again to find class attr)\n\np.z = 3  # let's make it a 3D point\nprint(p.z)  # 3\n\nprint(Point.z)\n# AttributeError: type object 'Point' has no attribute 'z'\n```", "```py\n# oop/class.self.py\nclass Square:\n    side = 8\n    def area(self):  # self is a reference to an instance\n        return self.side ** 2\n\nsq = Square()\nprint(sq.area())  # 64 (side is found on the class)\nprint(Square.area(sq))  # 64 (equivalent to sq.area())\n\nsq.side = 10\nprint(sq.area())  # 100 (side is found on the instance)\n```", "```py\n# oop/class.price.py\nclass Price:\n    def final_price(self, vat, discount=0):\n        \"\"\"Returns price after applying vat and fixed discount.\"\"\"\n        return (self.net_price * (100 + vat) / 100) - discount\n\np1 = Price()\np1.net_price = 100\nprint(Price.final_price(p1, 20, 10))  # 110 (100 * 1.2 - 10)\nprint(p1.final_price(20, 10))  # equivalent\n```", "```py\n# oop/class.init.py\nclass Rectangle:\n    def __init__(self, side_a, side_b):\n        self.side_a = side_a\n        self.side_b = side_b\n\n    def area(self):\n        return self.side_a * self.side_b\n\nr1 = Rectangle(10, 4)\nprint(r1.side_a, r1.side_b)  # 10 4\nprint(r1.area())  # 40\n\nr2 = Rectangle(7, 3)\nprint(r2.area())  # 21\n```", "```py\n# oop/class_inheritance.py\nclass Engine:\n    def start(self):\n        pass\n\n    def stop(self):\n        pass\n\nclass ElectricEngine(Engine):  # Is-A Engine\n    pass\n\nclass V8Engine(Engine):  # Is-A Engine\n    pass\n\nclass Car:\n    engine_cls = Engine\n\n    def __init__(self):\n        self.engine = self.engine_cls()  # Has-A Engine\n\n    def start(self):\n        print(\n            'Starting engine {0} for car {1}... Wroom, wroom!'\n            .format(\n                self.engine.__class__.__name__,\n                self.__class__.__name__)\n        )\n        self.engine.start()\n\n    def stop(self):\n        self.engine.stop()\n\nclass RaceCar(Car):  # Is-A Car\n    engine_cls = V8Engine\n\nclass CityCar(Car):  # Is-A Car\n    engine_cls = ElectricEngine\n\nclass F1Car(RaceCar):  # Is-A RaceCar and also Is-A Car\n    pass  # engine_cls same as parent\n\ncar = Car()\nracecar = RaceCar()\ncitycar = CityCar()\nf1car = F1Car()\ncars = [car, racecar, citycar, f1car]\n\nfor car in cars:\n    car.start()\n\n\"\"\" Prints:\nStarting engine Engine for car Car... Wroom, wroom!\nStarting engine V8Engine for car RaceCar... Wroom, wroom!\nStarting engine ElectricEngine for car CityCar... Wroom, wroom!\nStarting engine V8Engine for car F1Car... Wroom, wroom!\n\"\"\"\n```", "```py\n# oop/class.issubclass.isinstance.py\nfrom class_inheritance import Car, RaceCar, F1Car\n\ncar = Car()\nracecar = RaceCar()\nf1car = F1Car()\ncars = [(car, 'car'), (racecar, 'racecar'), (f1car, 'f1car')]\ncar_classes = [Car, RaceCar, F1Car]\n\nfor car, car_name in cars:\n    for class_ in car_classes:\n        belongs = isinstance(car, class_)\n        msg = 'is a' if belongs else 'is not a'\n        print(car_name, msg, class_.__name__)\n\n\"\"\" Prints:\ncar is a Car\ncar is not a RaceCar\ncar is not a F1Car\nracecar is a Car\nracecar is a RaceCar\nracecar is not a F1Car\nf1car is a Car\nf1car is a RaceCar\nf1car is a F1Car\n\"\"\"\n```", "```py\n# oop/class.issubclass.isinstance.py\nfor class1 in car_classes:\n    for class2 in car_classes:\n        is_subclass = issubclass(class1, class2)\n        msg = '{0} a subclass of'.format(\n            'is' if is_subclass else 'is not')\n        print(class1.__name__, msg, class2.__name__)\n\n\"\"\" Prints:\nCar is a subclass of Car\nCar is not a subclass of RaceCar\nCar is not a subclass of F1Car\nRaceCar is a subclass of Car\nRaceCar is a subclass of RaceCar\nRaceCar is not a subclass of F1Car\nF1Car is a subclass of Car\nF1Car is a subclass of RaceCar\nF1Car is a subclass of F1Car\n\"\"\"\n```", "```py\n# oop/super.duplication.py\nclass Book:\n    def __init__(self, title, publisher, pages):\n        self.title = title\n        self.publisher = publisher\n        self.pages = pages\n\nclass Ebook(Book):\n    def __init__(self, title, publisher, pages, format_):\n        self.title = title\n        self.publisher = publisher\n        self.pages = pages\n        self.format_ = format_\n```", "```py\n# oop/super.explicit.py\nclass Book:\n    def __init__(self, title, publisher, pages):\n        self.title = title\n        self.publisher = publisher\n        self.pages = pages\n\nclass Ebook(Book):\n    def __init__(self, title, publisher, pages, format_):\n        Book.__init__(self, title, publisher, pages)\n        self.format_ = format_\n\nebook = Ebook(\n    'Learn Python Programming', 'Packt Publishing', 500, 'PDF')\nprint(ebook.title)  # Learn Python Programming\nprint(ebook.publisher)  # Packt Publishing\nprint(ebook.pages)  # 500\nprint(ebook.format_)  # PDF\n```", "```py\n# oop/super.implicit.py\nclass Book:\n    def __init__(self, title, publisher, pages):\n        self.title = title\n        self.publisher = publisher\n        self.pages = pages\n\nclass Ebook(Book):\n    def __init__(self, title, publisher, pages, format_):\n        super().__init__(title, publisher, pages)\n        # Another way to do the same thing is:\n        # super(Ebook, self).__init__(title, publisher, pages)\n        self.format_ = format_\n\nebook = Ebook(\n    'Learn Python Programming', 'Packt Publishing', 500, 'PDF')\nprint(ebook.title) # Learn Python Programming\nprint(ebook.publisher) # Packt Publishing\nprint(ebook.pages) # 500\nprint(ebook.format_) # PDF\n```", "```py\n# oop/multiple.inheritance.py\nclass Shape:\n    geometric_type = 'Generic Shape'\n    def area(self):  # This acts as placeholder for the interface\n        raise NotImplementedError\n    def get_geometric_type(self):\n        return self.geometric_type\n\nclass Plotter:\n    def plot(self, ratio, topleft):\n        # Imagine some nice plotting logic here...\n        print('Plotting at {}, ratio {}.'.format(\n            topleft, ratio))\n\nclass Polygon(Shape, Plotter):  # base class for polygons\n    geometric_type = 'Polygon'\n\nclass RegularPolygon(Polygon):  # Is-A Polygon\n    geometric_type = 'Regular Polygon'\n    def __init__(self, side):\n        self.side = side\n\nclass RegularHexagon(RegularPolygon):  # Is-A RegularPolygon\n    geometric_type = 'RegularHexagon'\n    def area(self):\n        return 1.5 * (3 ** .5 * self.side ** 2)\n\nclass Square(RegularPolygon):  # Is-A RegularPolygon\n    geometric_type = 'Square'\n    def area(self):\n        return self.side * self.side\n\nhexagon = RegularHexagon(10)\nprint(hexagon.area())  # 259.8076211353316\nprint(hexagon.get_geometric_type())  # RegularHexagon\nhexagon.plot(0.8, (75, 77))  # Plotting at (75, 77), ratio 0.8.\n\nsquare = Square(12)\nprint(square.area())  # 144\nprint(square.get_geometric_type())  # Square\nsquare.plot(0.93, (74, 75))  # Plotting at (74, 75), ratio 0.93.\n```", "```py\n# oop/multiple.inheritance.py\nprint(square.__class__.__mro__)\n# prints:\n# (<class '__main__.Square'>, <class '__main__.RegularPolygon'>,\n# <class '__main__.Polygon'>, <class '__main__.Shape'>,\n# <class '__main__.Plotter'>, <class 'object'>)\n```", "```py\n# oop/mro.simple.py\nclass A:\n    label = 'a'\n\nclass B(A):\n    label = 'b'\n\nclass C(A):\n    label = 'c'\n\nclass D(B, C):\n    pass\n\nd = D()\nprint(d.label)  # Hypothetically this could be either 'b' or 'c'\n```", "```py\n# oop/mro.py\nclass A:\n    label = 'a'\n\nclass B(A):\n    pass  # was: label = 'b'\n\nclass C(A):\n    label = 'c'\n\nclass D(B, C):\n    pass\n\nd = D()\nprint(d.label)  # 'c'\nprint(d.__class__.mro())  # notice another way to get the MRO\n# prints:\n# [<class '__main__.D'>, <class '__main__.B'>,\n# <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]\n```", "```py\n# oop/static.methods.py\nclass StringUtil:\n\n    @staticmethod\n    def is_palindrome(s, case_insensitive=True):\n        # we allow only letters and numbers\n        s = ''.join(c for c in s if c.isalnum())  # Study this!\n        # For case insensitive comparison, we lower-case s\n        if case_insensitive:\n            s = s.lower()\n        for c in range(len(s) // 2):\n            if s[c] != s[-c -1]:\n                return False\n        return True\n\n    @staticmethod\n    def get_unique_words(sentence):\n        return set(sentence.split())\n\nprint(StringUtil.is_palindrome(\n    'Radar', case_insensitive=False))  # False: Case Sensitive\nprint(StringUtil.is_palindrome('A nut for a jar of tuna'))  # True\nprint(StringUtil.is_palindrome('Never Odd, Or Even!'))  # True\nprint(StringUtil.is_palindrome(\n    'In Girum Imus Nocte Et Consumimur Igni')  # Latin! Show-off!\n)  # True\n\nprint(StringUtil.get_unique_words(\n    'I love palindromes. I really really love them!'))\n# {'them!', 'really', 'palindromes.', 'I', 'love'}\n```", "```py\n# oop/class.methods.factory.py\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    @classmethod\n    def from_tuple(cls, coords):  # cls is Point\n        return cls(*coords)\n\n    @classmethod\n    def from_point(cls, point):  # cls is Point\n        return cls(point.x, point.y)\n\np = Point.from_tuple((3, 7))\nprint(p.x, p.y)  # 3 7\nq = Point.from_point(p)\nprint(q.x, q.y)  # 3 7\n```", "```py\n# oop/class.methods.split.py\nclass StringUtil:\n\n    @classmethod\n    def is_palindrome(cls, s, case_insensitive=True):\n        s = cls._strip_string(s)\n        # For case insensitive comparison, we lower-case s\n        if case_insensitive:\n            s = s.lower()\n        return cls._is_palindrome(s)\n\n    @staticmethod\n    def _strip_string(s):\n        return ''.join(c for c in s if c.isalnum())\n\n    @staticmethod\n    def _is_palindrome(s):\n        for c in range(len(s) // 2):\n            if s[c] != s[-c -1]:\n                return False\n        return True\n\n    @staticmethod\n    def get_unique_words(sentence):\n        return set(sentence.split())\n\nprint(StringUtil.is_palindrome('A nut for a jar of tuna'))  # True\nprint(StringUtil.is_palindrome('A nut for a jar of beans'))  # False\n```", "```py\n# oop/private.attrs.py\nclass A:\n    def __init__(self, factor):\n        self._factor = factor\n\n    def op1(self):\n        print('Op1 with factor {}...'.format(self._factor))\n\nclass B(A):\n    def op2(self, factor):\n        self._factor = factor\n        print('Op2 with factor {}...'.format(self._factor))\n\nobj = B(100)\nobj.op1()    # Op1 with factor 100...\nobj.op2(42)  # Op2 with factor 42...\nobj.op1()    # Op1 with factor 42... <- This is BAD\n```", "```py\n# oop/private.attrs.fixed.py\nclass A:\n    def __init__(self, factor):\n        self.__factor = factor\n\n    def op1(self):\n        print('Op1 with factor {}...'.format(self.__factor))\n\nclass B(A):\n    def op2(self, factor):\n        self.__factor = factor\n        print('Op2 with factor {}...'.format(self.__factor))\n\nobj = B(100)\nobj.op1()    # Op1 with factor 100...\nobj.op2(42)  # Op2 with factor 42...\nobj.op1()    # Op1 with factor 100... <- Wohoo! Now it's GOOD!\n```", "```py\n# oop/private.attrs.py\nprint(obj.__dict__.keys())\n# dict_keys(['_factor'])\n```", "```py\n# oop/private.attrs.fixed.py\nprint(obj.__dict__.keys())\n# dict_keys(['_A__factor', '_B__factor'])\n```", "```py\n# oop/property.py\nclass Person:\n    def __init__(self, age):\n        self.age = age  # anyone can modify this freely\n\nclass PersonWithAccessors:\n    def __init__(self, age):\n        self._age = age\n\n    def get_age(self):\n        return self._age\n\n    def set_age(self, age):\n        if 18 <= age <= 99:\n            self._age = age\n        else:\n            raise ValueError('Age must be within [18, 99]')\n\nclass PersonPythonic:\n    def __init__(self, age):\n        self._age = age\n\n    @property\n    def age(self):\n        return self._age\n\n    @age.setter\n    def age(self, age):\n        if 18 <= age <= 99:\n            self._age = age\n        else:\n            raise ValueError('Age must be within [18, 99]')\n\nperson = PersonPythonic(39)\nprint(person.age)  # 39 - Notice we access as data attribute\nperson.age = 42    # Notice we access as data attribute\nprint(person.age)  # 42\nperson.age = 100   # ValueError: Age must be within [18, 99]\n```", "```py\n# oop/operator.overloading.py\nclass Weird:\n    def __init__(self, s):\n        self._s = s\n\n    def __len__(self):\n        return len(self._s)\n\n    def __bool__(self):\n        return '42' in self._s\n\nweird = Weird('Hello! I am 9 years old!')\nprint(len(weird))  # 24\nprint(bool(weird))  # False\n\nweird2 = Weird('Hello! I am 42 years old!')\nprint(len(weird2))  # 25\nprint(bool(weird2))  # True\n```", "```py\n# oop/dataclass.py\nfrom dataclasses import dataclass\n\n@dataclass\nclass Body:\n    '''Class to represent a physical body.'''\n    name: str\n    mass: float = 0\\.  # Kg\n    speed: float = 1\\.  # m/s\n\n    def kinetic_energy(self) -> float:\n        return (self.mass * self.speed ** 2) / 2\n\nbody = Body('Ball', 19, 3.1415)\nprint(body.kinetic_energy())  # 93.755711375 Joule\nprint(body)  # Body(name='Ball', mass=19, speed=3.1415)\n```", "```py\n# iterators/iterator.py\nclass OddEven:\n\n    def __init__(self, data):\n        self._data = data\n        self.indexes = (list(range(0, len(data), 2)) +\n            list(range(1, len(data), 2)))\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.indexes:\n            return self._data[self.indexes.pop(0)]\n        raise StopIteration\n\noddeven = OddEven('ThIsIsCoOl!')\nprint(''.join(c for c in oddeven))  # TIICO!hssol\n\noddeven = OddEven('HoLa')  # or manually...\nit = iter(oddeven)  # this calls oddeven.__iter__ internally\nprint(next(it))  # H\n```", "```py\nprint(next(it))  # L\nprint(next(it))  # o\nprint(next(it))  # a\n```"]