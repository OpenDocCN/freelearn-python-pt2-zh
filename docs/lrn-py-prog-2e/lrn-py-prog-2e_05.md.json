["```py\n# squares.py\ndef square1(n):\n    return n ** 2  # squaring through the power operator\n\ndef square2(n):\n    return n * n  # squaring through multiplication\n```", "```py\n# alias.py\n>>> range(7)\nrange(0, 7)\n>>> list(range(7))  # put all elements in a list to view them\n[0, 1, 2, 3, 4, 5, 6]\n>>> _ = list  # create an \"alias\" to list\n>>> _(range(7))  # same as list(range(7))\n[0, 1, 2, 3, 4, 5, 6]\n```", "```py\n# map.example.py\n>>> map(lambda *a: a, range(3))  # 1 iterable\n<map object at 0x10acf8f98>  # Not useful! Let's use alias\n>>> _(map(lambda *a: a, range(3)))  # 1 iterable\n[(0,), (1,), (2,)]\n>>> _(map(lambda *a: a, range(3), 'abc'))  # 2 iterables\n[(0, 'a'), (1, 'b'), (2, 'c')]\n>>> _(map(lambda *a: a, range(3), 'abc', range(4, 7)))  # 3\n[(0, 'a', 4), (1, 'b', 5), (2, 'c', 6)]\n>>> # map stops at the shortest iterator\n>>> _(map(lambda *a: a, (), 'abc'))  # empty tuple is shortest\n[]\n>>> _(map(lambda *a: a, (1, 2), 'abc'))  # (1, 2) shortest\n[(1, 'a'), (2, 'b')]\n>>> _(map(lambda *a: a, (1, 2, 3, 4), 'abc'))  # 'abc' shortest\n[(1, 'a'), (2, 'b'), (3, 'c')]\n```", "```py\n# decorate.sort.undecorate.py\nstudents = [\n    dict(id=0, credits=dict(math=9, physics=6, history=7)),\n    dict(id=1, credits=dict(math=6, physics=7, latin=10)),\n    dict(id=2, credits=dict(history=8, physics=9, chemistry=10)),\n    dict(id=3, credits=dict(math=5, physics=5, geography=7)),\n]\n\ndef decorate(student):\n    # create a 2-tuple (sum of credits, student) from student dict\n    return (sum(student['credits'].values()), student)\n\ndef undecorate(decorated_student):\n    # discard sum of credits, return original student dict\n    return decorated_student[1]\n\nstudents = sorted(map(decorate, students), reverse=True)\nstudents = _(map(undecorate, students))\n```", "```py\n{'credits': {'history': 7, 'math': 9, 'physics': 6}, 'id': 0}\n```", "```py\n>>> decorate(students[0])\n(22, {'credits': {'history': 7, 'math': 9, 'physics': 6}, 'id': 0})\n```", "```py\n$ python decorate.sort.undecorate.py\n[{'credits': {'chemistry': 10, 'history': 8, 'physics': 9}, 'id': 2},\n {'credits': {'latin': 10, 'math': 6, 'physics': 7}, 'id': 1},\n {'credits': {'history': 7, 'math': 9, 'physics': 6}, 'id': 0},\n {'credits': {'geography': 7, 'math': 5, 'physics': 5}, 'id': 3}]\n```", "```py\n# zip.grades.py\n>>> grades = [18, 23, 30, 27]\n>>> avgs = [22, 21, 29, 24]\n>>> _(zip(avgs, grades))\n[(22, 18), (21, 23), (29, 30), (24, 27)]\n>>> _(map(lambda *a: a, avgs, grades))  # equivalent to zip\n[(22, 18), (21, 23), (29, 30), (24, 27)]\n```", "```py\n# maxims.py\n>>> a = [5, 9, 2, 4, 7]\n>>> b = [3, 7, 1, 9, 2]\n>>> c = [6, 8, 0, 5, 3]\n>>> maxs = map(lambda n: max(*n), zip(a, b, c))\n>>> _(maxs)\n[6, 9, 2, 9, 7]\n```", "```py\n# filter.py\n>>> test = [2, 5, 8, 0, 0, 1, 0]\n>>> _(filter(None, test))\n[2, 5, 8, 1]\n>>> _(filter(lambda x: x, test))  # equivalent to previous one\n[2, 5, 8, 1]\n>>> _(filter(lambda x: x > 4, test))  # keep only items > 4\n[5, 8]\n```", "```py\n# squares.map.py\n# If you code like this you are not a Python dev! ;)\n>>> squares = []\n>>> for n in range(10):\n...     squares.append(n ** 2)\n...\n>>> squares\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n# This is better, one line, nice and readable\n>>> squares = map(lambda n: n**2, range(10))\n>>> _(squares)\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```", "```py\n# squares.comprehension.py\n>>> [n ** 2 for n in range(10)]\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```", "```py\n# even.squares.py\n# using map and filter\nsq1 = list(\n    map(lambda n: n ** 2, filter(lambda n: not n % 2, range(10)))\n)\n# equivalent, but using list comprehensions\nsq2 = [n ** 2 for n in range(10) if not n % 2]\n\nprint(sq1, sq1 == sq2)  # prints: [0, 4, 16, 36, 64] True\n```", "```py\n# pairs.for.loop.py\nitems = 'ABCD'\npairs = []\n\nfor a in range(len(items)):\n    for b in range(a, len(items)):\n        pairs.append((items[a], items[b]))\n```", "```py\n$ python pairs.for.loop.py\n[('A', 'A'), ('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'B'), ('B', 'C'), ('B', 'D'), ('C', 'C'), ('C', 'D'), ('D', 'D')]\n```", "```py\n# pairs.list.comprehension.py\nitems = 'ABCD'\npairs = [(items[a], items[b])\n    for a in range(len(items)) for b in range(a, len(items))]\n```", "```py\n# pythagorean.triple.py\nfrom math import sqrt\n# this will generate all possible pairs\nmx = 10\ntriples = [(a, b, sqrt(a**2 + b**2))\n    for a in range(1, mx) for b in range(a, mx)]\n# this will filter out all non pythagorean triples\ntriples = list(\n    filter(lambda triple: triple[2].is_integer(), triples))\n\nprint(triples)  # prints: [(3, 4, 5.0), (6, 8, 10.0)]\n```", "```py\n# pythagorean.triple.int.py\nfrom math import sqrt\nmx = 10\ntriples = [(a, b, sqrt(a**2 + b**2))\n    for a in range(1, mx) for b in range(a, mx)]\ntriples = filter(lambda triple: triple[2].is_integer(), triples)\n# this will make the third number in the tuples integer\ntriples = list(\n    map(lambda triple: triple[:2] + (int(triple[2]), ), triples))\n\nprint(triples)  # prints: [(3, 4, 5), (6, 8, 10)]\n```", "```py\n# pythagorean.triple.comprehension.py\nfrom math import sqrt\n# this step is the same as before\nmx = 10\ntriples = [(a, b, sqrt(a**2 + b**2))\n    for a in range(1, mx) for b in range(a, mx)]\n# here we combine filter and map in one CLEAN list comprehension\ntriples = [(a, b, int(c)) for a, b, c in triples if c.is_integer()]\nprint(triples)  # prints: [(3, 4, 5), (6, 8, 10)]\n```", "```py\n# dictionary.comprehensions.py\nfrom string import ascii_lowercase\nlettermap = dict((c, k) for k, c in enumerate(ascii_lowercase, 1))\n```", "```py\n$ python dictionary.comprehensions.py\n{'a': 1,\n 'b': 2,\n ...\n 'y': 25,\n 'z': 26}\n```", "```py\nlettermap = {c: k for k, c in enumerate(ascii_lowercase, 1)} \n```", "```py\n# dictionary.comprehensions.duplicates.py\nword = 'Hello'\nswaps = {c: c.swapcase() for c in word}\nprint(swaps)  # prints: {'H': 'h', 'e': 'E', 'l': 'L', 'o': 'O'}\n```", "```py\n# dictionary.comprehensions.positions.py\nword = 'Hello'\npositions = {c: k for k, c in enumerate(word)}\nprint(positions)  # prints: {'H': 0, 'e': 1, 'l': 3, 'o': 4}\n```", "```py\n# set.comprehensions.py\nword = 'Hello'\nletters1 = set(c for c in word)\nletters2 = {c for c in word}\nprint(letters1)  # prints: {'H', 'o', 'e', 'l'}\nprint(letters1 == letters2)  # prints: True\n```", "```py\n# first.n.squares.py\ndef get_squares(n): # classic function approach\n    return [x ** 2 for x in range(n)]\nprint(get_squares(10))\n\ndef get_squares_gen(n):  # generator approach\n    for x in range(n):\n        yield x ** 2  # we yield, we don't return\nprint(list(get_squares_gen(10)))\n```", "```py\n# first.n.squares.manual.py\ndef get_squares_gen(n):\n    for x in range(n):\n        yield x ** 2\n\nsquares = get_squares_gen(4)  # this creates a generator object\nprint(squares)  # <generator object get_squares_gen at 0x10dd...>\nprint(next(squares))  # prints: 0\nprint(next(squares))  # prints: 1\nprint(next(squares))  # prints: 4\nprint(next(squares))  # prints: 9\n# the following raises StopIteration, the generator is exhausted,\n# any further call to next will keep raising StopIteration\nprint(next(squares))\n```", "```py\n# gen.yield.return.py\ndef geometric_progression(a, q):\n    k = 0\n    while True:\n        result = a * q**k\n        if result <= 100000:\n            yield result\n        else:\n            return\n        k += 1\n\nfor n in geometric_progression(2, 5):\n    print(n)\n```", "```py\n$ python gen.yield.return.py\n2\n10\n50\n250\n1250\n6250\n31250\n```", "```py\n# first.n.squares.manual.method.py\ndef get_squares_gen(n):\n    for x in range(n):\n        yield x ** 2\n\nsquares = get_squares_gen(3)\nprint(squares.__next__())  # prints: 0\nprint(squares.__next__())  # prints: 1\nprint(squares.__next__())  # prints: 4\n# the following raises StopIteration, the generator is exhausted,\n# any further call to next will keep raising StopIteration\n```", "```py\n# gen.send.preparation.py\ndef counter(start=0):\n    n = start\n    while True:\n        yield n\n        n += 1\n\nc = counter()\nprint(next(c))  # prints: 0\nprint(next(c))  # prints: 1\nprint(next(c))  # prints: 2\n```", "```py\n# gen.send.preparation.stop.py\nstop = False\ndef counter(start=0):\n    n = start\n    while not stop:\n        yield n\n        n += 1\n\nc = counter()\nprint(next(c))  # prints: 0\nprint(next(c))  # prints: 1\nstop = True\nprint(next(c))  # raises StopIteration\n```", "```py\n# gen.send.py\ndef counter(start=0):\n    n = start\n    while True:\n        result = yield n             # A\n        print(type(result), result)  # B\n        if result == 'Q':\n            break\n        n += 1\n\nc = counter()\nprint(next(c))         # C\nprint(c.send('Wow!'))  # D\nprint(next(c))         # E\nprint(c.send('Q'))     # F\n```", "```py\n$ python gen.send.py\n0\n<class 'str'> Wow!\n1\n<class 'NoneType'> None\n2\n<class 'str'> Q\nTraceback (most recent call last):\n File \"gen.send.py\", line 14, in <module>\n print(c.send('Q')) # F\nStopIteration\n```", "```py\n# gen.yield.for.py def print_squares(start, end):\n    for n in range(start, end):\n        yield n ** 2\n\nfor n in print_squares(2, 5):\n    print(n)\n```", "```py\n# gen.yield.from.py\ndef print_squares(start, end):\n    yield from (n ** 2 for n in range(start, end))\n\nfor n in print_squares(2, 5):\n    print(n)\n```", "```py\n# generator.expressions.py\n>>> cubes = [k**3 for k in range(10)]  # regular list\n>>> cubes\n[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]\n>>> type(cubes)\n<class 'list'>\n>>> cubes_gen = (k**3 for k in range(10))  # create as generator\n>>> cubes_gen\n<generator object <genexpr> at 0x103fb5a98>\n>>> type(cubes_gen)\n<class 'generator'>\n>>> _(cubes_gen)  # this will exhaust the generator\n[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]\n>>> _(cubes_gen)  # nothing more to give\n[]\n```", "```py\n# gen.map.py\ndef adder(*n):\n    return sum(n)\ns1 = sum(map(lambda *n: adder(*n), range(100), range(1, 101)))\ns2 = sum(adder(*n) for n in zip(range(100), range(1, 101)))\n```", "```py\n# gen.filter.py\ncubes = [x**3 for x in range(10)]\n\nodd_cubes1 = filter(lambda cube: cube % 2, cubes)\nodd_cubes2 = (cube for cube in cubes if cube % 2)\n```", "```py\n# gen.map.filter.py\nN = 20\ncubes1 = map(\n    lambda n: (n, n**3),\n    filter(lambda n: n % 3 == 0 or n % 5 == 0, range(N))\n)\ncubes2 = (\n    (n, n**3) for n in range(N) if n % 3 == 0 or n % 5 == 0)\n```", "```py\n# sum.example.py\ns1 = sum([n**2 for n in range(10**6)])\ns2 = sum((n**2 for n in range(10**6)))\ns3 = sum(n**2 for n in range(10**6))\n```", "```py\n# sum.example.2.py\ns = sum([n**2 for n in range(10**8)])  # this is killed\n# s = sum(n**2 for n in range(10**8))    # this succeeds\nprint(s)  # prints: 333333328333333350000000\n```", "```py\n$ python sum.example.2.py\nKilled  \n```", "```py\n$ python sum.example.2.py\n333333328333333350000000  \n```", "```py\n# performances.py\nfrom time import time\nmx = 5000\n\nt = time()  # start time for the for loop\nfloop = []\nfor a in range(1, mx):\n    for b in range(a, mx):\n        floop.append(divmod(a, b))\nprint('for loop: {:.4f} s'.format(time() - t))  # elapsed time\n\nt = time()  # start time for the list comprehension\ncompr = [\n    divmod(a, b) for a in range(1, mx) for b in range(a, mx)]\nprint('list comprehension: {:.4f} s'.format(time() - t))\n\nt = time()  # start time for the generator expression\ngener = list(\n    divmod(a, b) for a in range(1, mx) for b in range(a, mx))\nprint('generator expression: {:.4f} s'.format(time() - t))\n```", "```py\n$ python performances.py\nfor loop: 4.4814 s\nlist comprehension: 3.0210 s\ngenerator expression: 3.4334 s\n```", "```py\n# performances.map.py\nfrom time import time\nmx = 2 * 10 ** 7\n\nt = time()\nabsloop = []\nfor n in range(mx):\n    absloop.append(abs(n))\nprint('for loop: {:.4f} s'.format(time() - t))\n\nt = time()\nabslist = [abs(n) for n in range(mx)]\nprint('list comprehension: {:.4f} s'.format(time() - t))\n\nt = time()\nabsmap = list(map(abs, range(mx)))\nprint('map: {:.4f} s'.format(time() - t))\n```", "```py\n$ python performances.map.py\nfor loop: 3.8948 s\nlist comprehension: 1.8594 s\nmap: 1.1548 s\n```", "```py\n>>> import this\n...\nExplicit is better than implicit.\nSimple is better than complex.\n...\nReadability counts.\n...\nIf the implementation is hard to explain, it's a bad idea.\n...\n```", "```py\n# functions.py\ndef gcd(a, b):\n    \"\"\"Calculate the Greatest Common Divisor of (a, b). \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a\n```", "```py\n# pythagorean.triple.generation.py\nfrom functions import gcd\nN = 50\n\ntriples = sorted(                                    # 1\n    ((a, b, c) for a, b, c in (                      # 2\n        ((m**2 - n**2), (2 * m * n), (m**2 + n**2))  # 3\n        for m in range(1, int(N**.5) + 1)            # 4\n        for n in range(1, m)                         # 5\n        if (m - n) % 2 and gcd(m, n) == 1            # 6\n    ) if c <= N), key=lambda *triple: sum(*triple)   # 7\n)\n```", "```py\n# pythagorean.triple.generation.for.py\nfrom functions import gcd\n\ndef gen_triples(N):\n    for m in range(1, int(N**.5) + 1):                  # 1\n        for n in range(1, m):                           # 2\n            if (m - n) % 2 and gcd(m, n) == 1:          # 3\n                c = m**2 + n**2                         # 4\n                if c <= N:                              # 5\n                    a = m**2 - n**2                     # 6\n                    b = 2 * m * n                       # 7\n                    yield (a, b, c)                     # 8\n\ntriples = sorted(\n    gen_triples(50), key=lambda *triple: sum(*triple))  # 9\n```", "```py\n[(3, 4, 5), (5, 12, 13), (15, 8, 17), (7, 24, 25), (21, 20, 29), (35, 12, 37), (9, 40, 41)]  \n```", "```py\n# scopes.py\nA = 100\nex1 = [A for A in range(5)]\nprint(A)  # prints: 100\n\nex2 = list(A for A in range(5))\nprint(A)  # prints: 100\n\nex3 = dict((A, 2 * A) for A in range(5))\nprint(A)  # prints: 100\n\nex4 = set(A for A in range(5))\nprint(A)  # prints: 100\n\ns = 0\nfor A in range(5):\n    s += A\nprint(A)  # prints: 4\n```", "```py\n# scopes.noglobal.py\nex1 = [A for A in range(5)]\nprint(A)  # breaks: NameError: name 'A' is not defined\n```", "```py\n# scopes.for.py\ns = 0\nfor A in range(5):\n    s += A\nprint(A) # prints: 4\nprint(globals())\n```", "```py\n$ python scopes.for.py\n4\n{'__name__': '__main__', '__doc__': None, ..., 's': 10, 'A': 4}\n```", "```py\n# fibonacci.first.py\ndef fibonacci(N):\n    \"\"\"Return all fibonacci numbers up to N. \"\"\"\n    result = [0]\n    next_n = 1\n    while next_n <= N:\n        result.append(next_n)\n        next_n = sum(result[-2:])\n    return result\n\nprint(fibonacci(0))   # [0]\nprint(fibonacci(1))   # [0, 1, 1]\nprint(fibonacci(50))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n```", "```py\n# fibonacci.second.py\ndef fibonacci(N):\n    \"\"\"Return all fibonacci numbers up to N. \"\"\"\n    yield 0\n    if N == 0:\n        return\n    a = 0\n    b = 1\n    while b <= N:\n        yield b\n        a, b = b, a + b\n\nprint(list(fibonacci(0)))   # [0]\nprint(list(fibonacci(1)))   # [0, 1, 1]\nprint(list(fibonacci(50)))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n```", "```py\n# fibonacci.elegant.py\ndef fibonacci(N):\n    \"\"\"Return all fibonacci numbers up to N. \"\"\"\n    a, b = 0, 1\n    while a <= N:\n        yield a\n        a, b = b, a + b\n```"]