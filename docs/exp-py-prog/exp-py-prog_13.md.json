["```py\n**>>> from gmaps import Geocoding**\n**>>> api = Geocoding()**\n**>>> geocoded = api.geocode('Warsaw')[0]**\n**>>> print(\"{:>25s}, {:6.2f}, {:6.2f}\".format(**\n**...         geocoded['formatted_address'],**\n**...         geocoded['geometry']['location']['lat'],**\n**...         geocoded['geometry']['location']['lng'],**\n**...     ))**\n**Warsaw, Poland,  52.23,  21.01**\n\n```", "```py\nimport time\n\nfrom gmaps import Geocoding\n\napi = Geocoding()\n\nPLACES = (\n    'Reykjavik', 'Vien', 'Zadar', 'Venice',\n    'Wroc\u0142aw', 'Bolognia', 'Berlin', 'S\u0142ubice',\n    'New York', 'Dehli',\n)\n\ndef fetch_place(place):\n    geocoded = api.geocode(place)[0]\n\n    print(\"{:>25s}, {:6.2f}, {:6.2f}\".format(\n        geocoded['formatted_address'],\n        geocoded['geometry']['location']['lat'],\n        geocoded['geometry']['location']['lng'],\n    ))\n\ndef main():\n    for place in PLACES:\n        fetch_place(place)\n\nif __name__ == \"__main__\":\n    started = time.time()\n    main()\n    elapsed = time.time() - started\n\n    print()\n    print(\"time elapsed: {:.2f}s\".format(elapsed))\n```", "```py\n**$ python3 synchronous.py**\n **Reykjav\u00edk, Iceland,  64.13, -21.82**\n **Vienna, Austria,  48.21,  16.37**\n **Zadar, Croatia,  44.12,  15.23**\n **Venice, Italy,  45.44,  12.32**\n **Wroc\u0142aw, Poland,  51.11,  17.04**\n **Bologna, Italy,  44.49,  11.34**\n **Berlin, Germany,  52.52,  13.40**\n **Slubice, Poland,  52.35,  14.56**\n **New York, NY, USA,  40.71, -74.01**\n **Dehli, Gujarat, India,  21.57,  73.22**\n\n**time elapsed: 2.79s**\n\n```", "```py\nfrom threading import Thread\n\ndef main():\n    threads = []\n    for place in PLACES:\n        thread = Thread(target=fetch_place, args=[place])\n        thread.start()\n        threads.append(thread)\n\n    while threads:\n        threads.pop().join()\n```", "```py\n**$ python3 threaded.py**\n **Wroc\u0142aw, Poland,  51.11,  17.04**\n **Vienna, Austria,  48.21,  16.37**\n **Dehli, Gujarat, India,  21.57,  73.22**\n **New York, NY, USA,  40.71, -74.01**\n **Bologna, Italy,  44.49,  11.34**\n **Reykjav\u00edk, Iceland,  64.13, -21.82**\n **Zadar, Croatia,  44.12,  15.23**\n **Berlin, Germany,  52.52,  13.40**\n **Slubice, Poland,  52.35,  14.56**\n **Venice, Italy,  45.44,  12.32**\n\n**time elapsed: 1.05s**\n\n```", "```py\nfrom queue import Queue, Empty\nfrom threading import Thread\n\nTHREAD_POOL_SIZE = 4\n\ndef worker(work_queue):\n    while not work_queue.empty():\n        try:\n            item = work_queue.get(block=False)\n        except Empty:\n            break\n        else:\n            fetch_place(item)\n            work_queue.task_done()\n\ndef main():\n    work_queue = Queue()\n\n    for place in PLACES:\n        work_queue.put(place)\n\n    threads = [\n        Thread(target=worker, args=(work_queue,))\n        for _ in range(THREAD_POOL_SIZE)\n    ]\n\n    for thread in threads:\n        thread.start()\n\n    work_queue.join()\n\n    while threads:\n        threads.pop().join()\n```", "```py\n**$ python threadpool.py** \n **Reykjav\u00edk, Iceland,  64.13, -21.82**\n **Venice, Italy,  45.44,  12.32**\n **Vienna, Austria,  48.21,  16.37**\n **Zadar, Croatia,  44.12,  15.23**\n **Wroc\u0142aw, Poland,  51.11,  17.04**\n **Bologna, Italy,  44.49,  11.34**\n **Slubice, Poland,  52.35,  14.56**\n **Berlin, Germany,  52.52,  13.40**\n **New York, NY, USA,  40.71, -74.01**\n **Dehli, Gujarat, India,  21.57,  73.22**\n\n**time elapsed: 1.20s**\n\n```", "```py\nimport time\nfrom queue import Queue, Empty\nfrom threading import Thread\n\nfrom gmaps import Geocoding\n\napi = Geocoding()\n\nPLACES = (\n    'Reykjavik', 'Vien', 'Zadar', 'Venice',\n    'Wroc\u0142aw', 'Bolognia', 'Berlin', 'S\u0142ubice',\n    'New York', 'Dehli',\n)\n\nTHREAD_POOL_SIZE = 4\n\ndef fetch_place(place):\n    return api.geocode(place)[0]\n\n**def present_result(geocoded):**\n **print(\"{:>25s}, {:6.2f}, {:6.2f}\".format(**\n **geocoded['formatted_address'],**\n **geocoded['geometry']['location']['lat'],**\n **geocoded['geometry']['location']['lng'],**\n **))**\n\ndef worker(work_queue, results_queue):\n    while not work_queue.empty():\n        try:\n            item = work_queue.get(block=False)\n        except Empty:\n            break\n        else:\n **results_queue.put(**\n **fetch_place(item)**\n **)**\n            work_queue.task_done()\n\ndef main():\n    work_queue = Queue()\n **results_queue = Queue()**\n\n    for place in PLACES:\n        work_queue.put(place)\n\n    threads = [\n **Thread(target=worker, args=(work_queue, results_queue))**\n        for _ in range(THREAD_POOL_SIZE)\n    ]\n\n    for thread in threads:\n        thread.start()\n\n    work_queue.join()\n\n    while threads:\n        threads.pop().join()\n\n **while not results_queue.empty():**\n **present_result(results_queue.get())**\n\nif __name__ == \"__main__\":\n    started = time.time()\n    main()\n    elapsed = time.time() - started\n\n    print()\n    print(\"time elapsed: {:.2f}s\".format(elapsed))\n```", "```py\n**$ python threadpool_with_results.py** \n **Vienna, Austria,  48.21,  16.37**\n **Reykjav\u00edk, Iceland,  64.13, -21.82**\n **Zadar, Croatia,  44.12,  15.23**\n **Venice, Italy,  45.44,  12.32**\n **Wroc\u0142aw, Poland,  51.11,  17.04**\n **Bologna, Italy,  44.49,  11.34**\n **Slubice, Poland,  52.35,  14.56**\n **Berlin, Germany,  52.52,  13.40**\n **New York, NY, USA,  40.71, -74.01**\n **Dehli, Gujarat, India,  21.57,  73.22**\n\n**time elapsed: 1.30s**\n\n```", "```py\ndef worker(work_queue, results_queue):\n    while True:\n        try:\n            item = work_queue.get(block=False)\n        except Empty:\n            break\n        else:\n **try:**\n **result = fetch_place(item)**\n **except Exception as err:**\n **results_queue.put(err)**\n **else:**\n **results_queue.put(result)**\n **finally:**\n **work_queue.task_done()**\n\ndef main():\n    work_queue = Queue()\n    results_queue = Queue()\n\n    for place in PLACES:\n        work_queue.put(place)\n\n    threads = [\n        Thread(target=worker, args=(work_queue, results_queue))\n        for _ in range(THREAD_POOL_SIZE)\n    ]\n\n    for thread in threads:\n        thread.start()\n\n    work_queue.join()\n\n    while threads:\n        threads.pop().join()\n\n **while not results_queue.empty():**\n **result = results_queue.get()**\n\n **if isinstance(result, Exception):**\n **raise result**\n\n        present_result(result)\n```", "```py\nPLACES = (\n    'Reykjavik', 'Vien', 'Zadar', 'Venice',\n    'Wroc\u0142aw', 'Bolognia', 'Berlin', 'S\u0142ubice',\n    'New York', 'Dehli',\n) * 10\n\nTHREAD_POOL_SIZE = 10\n```", "```py\n**$ python3 threadpool_with_errors.py**\n **New York, NY, USA,  40.71, -74.01**\n **Berlin, Germany,  52.52,  13.40**\n **Wroc\u0142aw, Poland,  51.11,  17.04**\n **Zadar, Croatia,  44.12,  15.23**\n **Vienna, Austria,  48.21,  16.37**\n **Bologna, Italy,  44.49,  11.34**\n **Reykjav\u00edk, Iceland,  64.13, -21.82**\n **Venice, Italy,  45.44,  12.32**\n **Dehli, Gujarat, India,  21.57,  73.22**\n **Slubice, Poland,  52.35,  14.56**\n **Vienna, Austria,  48.21,  16.37**\n **Zadar, Croatia,  44.12,  15.23**\n **Venice, Italy,  45.44,  12.32**\n **Reykjav\u00edk, Iceland,  64.13, -21.82**\n**Traceback (most recent call last):**\n **File \"threadpool_with_errors.py\", line 83, in <module>**\n **main()**\n **File \"threadpool_with_errors.py\", line 76, in main**\n **raise result**\n **File \"threadpool_with_errors.py\", line 43, in worker**\n **result = fetch_place(item)**\n **File \"threadpool_with_errors.py\", line 23, in fetch_place**\n **return api.geocode(place)[0]**\n **File \"...\\site-packages\\gmaps\\geocoding.py\", line 37, in geocode**\n **return self._make_request(self.GEOCODE_URL, parameters, \"results\")**\n **File \"...\\site-packages\\gmaps\\client.py\", line 89, in _make_request**\n **)(response)**\n**gmaps.errors.RateLimitExceeded: {'status': 'OVER_QUERY_LIMIT', 'results': [], 'error_message': 'You have exceeded your rate-limit for this API.', 'url': 'https://maps.googleapis.com/maps/api/geocode/json?address=Wroc%C5%82aw&sensor=false'}**\n\n```", "```py\nFrom threading import Lock\n\nclass Throttle:\n    def __init__(self, rate):\n        self._consume_lock = Lock()\n        self.rate = rate\n        self.tokens = 0\n        self.last = 0\n\n    def consume(self, amount=1):\n        with self._consume_lock:\n            now = time.time()\n\n            # time measument is initialized on first\n            # token request to avoid initial bursts\n            if self.last == 0:\n                self.last = now\n\n            elapsed = now - self.last\n\n            # make sure that quant of passed time is big\n            # enough to add new tokens\n            if int(elapsed * self.rate):\n                self.tokens += int(elapsed * self.rate)\n                self.last = now\n\n            # never over-fill the bucket\n            self.tokens = (\n                self.rate\n                if self.tokens > self.rate\n                else self.tokens\n            )\n\n            # finally dispatch tokens if available\n            if self.tokens >= amount:\n                self.tokens -= amount\n            else:\n                amount = 0\n\n            return amount\n```", "```py\ndef worker(work_queue, results_queue, throttle):\n    while True:\n        try:\n            item = work_queue.get(block=False)\n        except Empty:\n            break\n        else:\n **while not throttle.consume():**\n **pass**\n\n            try:\n                result = fetch_place(item)\n            except Exception as err:\n                results_queue.put(err)\n            else:\n                results_queue.put(result)\n            finally:\n                work_queue.task_done()\n```", "```py\nimport os\n\npid_list = []\n\ndef main():\n    pid_list.append(os.getpid())\n    child_pid = os.fork()\n\n    if child_pid == 0:\n        pid_list.append(os.getpid())\n        print()\n        print(\"CHLD: hey, I am the child process\")\n        print(\"CHLD: all the pids i know %s\" % pid_list)\n\n    else:\n        pid_list.append(os.getpid())\n        print()\n        print(\"PRNT: hey, I am the parent\")\n        print(\"PRNT: the child is pid %d\" % child_pid)\n        print(\"PRNT: all the pids i know %s\" % pid_list)\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\n**$ python3 forks.py**\n\n**PRNT: hey, I am the parent**\n**PRNT: the child is pid 21916**\n**PRNT: all the pids i know [21915, 21915]**\n\n**CHLD: hey, I am the child process**\n**CHLD: all the pids i know [21915, 21916]**\n\n```", "```py\nfrom multiprocessing import Process\nimport os\n\ndef work(identifier):\n    print(\n        'hey, i am a process {}, pid: {}'\n        ''.format(identifier, os.getpid())\n    )\n\ndef main():\n    processes = [\n        Process(target=work, args=(number,))\n        for number in range(5)\n    ]\n    for process in processes:\n        process.start()\n\n    while processes:\n        processes.pop().join()\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\n**$ python3 processing.py**\n**hey, i am a process 1, pid: 9196**\n**hey, i am a process 0, pid: 8356**\n**hey, i am a process 3, pid: 9524**\n**hey, i am a process 2, pid: 3456**\n**hey, i am a process 4, pid: 6576**\n\n```", "```py\nfrom multiprocessing import Process, Pipe\n\nclass CustomClass:\n    pass\n\ndef work(connection):\n    while True:\n        instance = connection.recv()\n\n        if instance:\n            print(\"CHLD: {}\".format(instance))\n\n        else:\n            return\n\ndef main():\n    parent_conn, child_conn = Pipe()\n\n    child = Process(target=work, args=(child_conn,))\n\n    for item in (\n        42,\n        'some string',\n        {'one': 1},\n        CustomClass(),\n        None,\n    ):\n        print(\"PRNT: send {}:\".format(item))\n        parent_conn.send(item)\n\n    child.start()\n    child.join()\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\n**PRNT: send: 42**\n**PRNT: send: some string**\n**PRNT: send: {'one': 1}**\n**PRNT: send: <__main__.CustomClass object at 0x101cb5b00>**\n**PRNT: send: None**\n**CHLD: recv: 42**\n**CHLD: recv: some string**\n**CHLD: recv: {'one': 1}**\n**CHLD: recv: <__main__.CustomClass object at 0x101cba400>**\n\n```", "```py\nfrom multiprocessing import Process, Value, Array\n\ndef f(n, a):\n    n.value = 3.1415927\n    for i in range(len(a)):\n        a[i] = -a[i]\n\nif __name__ == '__main__':\n    num = Value('d', 0.0)\n    arr = Array('i', range(10))\n\n    p = Process(target=f, args=(num, arr))\n    p.start()\n    p.join()\n\n    print(num.value)\n    print(arr[:])\n```", "```py\n**3.1415927**\n**[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]**\n\n```", "```py\nfrom multiprocessing import Pool\n\nfrom gmaps import Geocoding\n\napi = Geocoding()\n\nPLACES = (\n    'Reykjavik', 'Vien', 'Zadar', 'Venice',\n    'Wroc\u0142aw', 'Bolognia', 'Berlin', 'S\u0142ubice',\n    'New York', 'Dehli',\n)\n\nPOOL_SIZE = 4\n\ndef fetch_place(place):\n    return api.geocode(place)[0]\n\ndef present_result(geocoded):\n    print(\"{:>25s}, {:6.2f}, {:6.2f}\".format(\n        geocoded['formatted_address'],\n        geocoded['geometry']['location']['lat'],\n        geocoded['geometry']['location']['lng'],\n    ))\n\ndef main():\n    with Pool(POOL_SIZE) as pool:\n        results = pool.map(fetch_place, PLACES)\n\n    for result in results:\n        present_result(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\nfrom multiprocessing import Pool as ProcessPool\nfrom multiprocessing.dummy import Pool as ThreadPool\n\ndef main(use_threads=False):\n    if use_threads:\n        pool_cls = ThreadPool\n    else:\n        pool_cls = ProcessPool\n\n    with pool_cls(POOL_SIZE) as pool:\n        results = pool.map(fetch_place, PLACES)\n\n    for result in results:\n        present_result(result)\n```", "```py\nasync def async_hello():\n    print(\"hello, world!\")\n```", "```py\n**>>> async def async_hello():**\n**...     print(\"hello, world!\")**\n**...** \n**>>> async_hello()**\n**<coroutine object async_hello at 0x1014129e8>**\n\n```", "```py\n**>>> import asyncio**\n**>>> async def async_hello():**\n**...     print(\"hello, world!\")**\n**...** \n**>>> loop = asyncio.get_event_loop()**\n**>>> loop.run_until_complete(async_hello())**\n**hello, world!**\n**>>> loop.close()**\n\n```", "```py\nimport asyncio\n\nasync def print_number(number):\n    print(number)\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n\n    loop.run_until_complete(\n        asyncio.wait([\n            print_number(number)\n            for number in range(10)\n        ])\n    )\n    loop.close()\n```", "```py\n**$ python asyncprint.py** \n**0**\n**7**\n**8**\n**3**\n**9**\n**4**\n**1**\n**5**\n**2**\n**6**\n\n```", "```py\nimport time\nimport random\nimport asyncio\n\nasync def waiter(name):\n    for _ in range(4):\n        time_to_sleep = random.randint(1, 3) / 4\n        time.sleep(time_to_sleep)\n        print(\n            \"{} waited {} seconds\"\n            \"\".format(name, time_to_sleep)\n        )\n\nasync def main():\n    await asyncio.wait([waiter(\"foo\"), waiter(\"bar\")])\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n    loop.close()\n```", "```py\n**$ time python corowait.py** \n**bar waited 0.25 seconds**\n**bar waited 0.25 seconds**\n**bar waited 0.5 seconds**\n**bar waited 0.5 seconds**\n**foo waited 0.75 seconds**\n**foo waited 0.75 seconds**\n**foo waited 0.25 seconds**\n**foo waited 0.25 seconds**\n\n**real\t0m3.734s**\n**user\t0m0.153s**\n**sys\t0m0.028s**\n\n```", "```py\nasync def waiter(name):\n    for _ in range(4):\n        time_to_sleep = random.randint(1, 3) / 4\n        await asyncio.sleep(time_to_sleep)\n        print(\n            \"{} waited {} seconds\"\n            \"\".format(name, time_to_sleep)\n        )\n```", "```py\n**$ time python corowait_improved.py** \n**bar waited 0.25 seconds**\n**foo waited 0.25 seconds**\n**bar waited 0.25 seconds**\n**foo waited 0.5 seconds**\n**foo waited 0.25 seconds**\n**bar waited 0.75 seconds**\n**foo waited 0.25 seconds**\n**bar waited 0.5 seconds**\n\n**real  0m1.953s**\n**user  0m0.149s**\n**sys   0m0.026s**\n\n```", "```py\nasync def main():\n    await asyncio.sleep(0)\n```", "```py\n@asyncio.couroutine\ndef main():\n    yield from asyncio.sleep(0)\n```", "```py\nimport aiohttp\n\nsession = aiohttp.ClientSession()\n\nasync def geocode(place):\n    params = {\n        'sensor': 'false',\n        'address': place\n    }\n    async with session.get(\n        'https://maps.googleapis.com/maps/api/geocode/json',\n        params=params\n    ) as response:\n        result = await response.json()\n        return result['results']\n```", "```py\nimport asyncio\n# note: local module introduced earlier\nfrom asyncgmaps import geocode, session\n\nPLACES = (\n    'Reykjavik', 'Vien', 'Zadar', 'Venice',\n    'Wroc\u0142aw', 'Bolognia', 'Berlin', 'S\u0142ubice',\n    'New York', 'Dehli',\n)\n\nasync def fetch_place(place):\n    return (await geocode(place))[0]\n\nasync def present_result(result):\n    geocoded = await result\n    print(\"{:>25s}, {:6.2f}, {:6.2f}\".format(\n        geocoded['formatted_address'],\n        geocoded['geometry']['location']['lat'],\n        geocoded['geometry']['location']['lng'],\n    ))\n\nasync def main():\n    await asyncio.wait([\n        present_result(fetch_place(place))\n        for place in PLACES\n    ])\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n\n    # aiohttp will raise issue about unclosed\n    # ClientSession so we perform cleanup manually\n    loop.run_until_complete(session.close())\n    loop.close()\n```", "```py\n**>>> def loudy_return():**\n**...     print(\"processing\")**\n**...     return 42**\n**...** \n**>>> from concurrent.futures import ThreadPoolExecutor**\n**>>> with ThreadPoolExecutor(1) as executor:**\n**...     future = executor.submit(loudy_return)**\n**...** \n**processing**\n**>>> future**\n**<Future at 0x33cbf98 state=finished returned int>**\n**>>> future.result()**\n**42**\n\n```", "```py\ndef main():\n    with ThreadPoolExecutor(POOL_SIZE) as pool:\n        results = pool.map(fetch_place, PLACES)\n\n    for result in results:\n        present_result(result)\n```", "```py\nasync def fetch_place(place):\n    coro = loop.run_in_executor(None, api.geocode, place)\n    result = await coro\n    return result[0]\n```"]