["```py\n**>>> MyType = type('MyType', (object,), {'a': 1})**\n**>>> ob = MyType()**\n**>>> type(ob)**\n**<class '__main__.MyType'>**\n**>>> ob.a**\n**1**\n**>>> isinstance(ob, object)**\n**True**\n\n```", "```py\nclass Singleton:\n    _instance = None\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls, *args, **kwargs)\n\n        return cls._instance\n```", "```py\n**>>> instance_a = Singleton()**\n**>>> instance_b = Singleton()**\n**>>> id(instance_a) == id(instance_b)**\n**True**\n**>>> instance_a == instance_b**\n**True**\n\n```", "```py\n**>>> class ConcreteClass(Singleton): pass**\n**>>> Singleton()**\n**<Singleton object at 0x000000000306B470>**\n**>>> ConcreteClass()**\n**<Singleton object at 0x000000000306B470>**\n\n```", "```py\n**>>> class ConcreteClass(Singleton): pass**\n**>>> ConcreteClass()**\n**<ConcreteClass object at 0x00000000030615F8>**\n**>>> Singleton()**\n**<Singleton object at 0x000000000304BCF8>**\n\n```", "```py\nclass Singleton(type):\n    _instances = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n```", "```py\n**>>> ConcreteClass() == ConcreteClass()**\n**True**\n**>>> ConcreteSubclass() == ConcreteSubclass()**\n**True**\n**>>> ConcreteClass()**\n**<ConcreteClass object at 0x000000000307AF98>**\n**>>> ConcreteSubclass()**\n**<ConcreteSubclass object at 0x000000000307A3C8>**\n\n```", "```py\nclass Borg(object):\n    _state = {}\n\n    def __new__(cls, *args, **kwargs):\n        ob = super().__new__(cls, *args, **kwargs)\n        ob.__dict__ = cls._state\n        return ob\n```", "```py\n**>>> from io import StringIO**\n**>>> my_file = StringIO('some content')**\n**>>> my_file.read()**\n**'some content'**\n**>>> my_file.seek(0)**\n**>>> my_f**\n**ile.read(1)**\n**'s'**\n\n```", "```py\nfrom os.path import split, splitext\n\nclass DublinCoreAdapter:\n    def __init__(self, filename):\n        self._filename = filename\n\n    @property\n    def title(self):\n        return splitext(split(self._filename)[-1])[0]\n\n    @property\n    def languages(self):\n        return ('en',)\n\n    def __getitem__(self, item):\n        return getattr(self, item, 'Unknown')\n\nclass DublinCoreInfo(object):\n    def summary(self, dc_dict):\n        print('Title: %s' % dc_dict['title'])\n        print('Creator: %s' % dc_dict['creator'])\n        print('Languages: %s' % ', '.join(dc_dict['languages']))\n```", "```py\n**>>> adapted = DublinCoreAdapter('example.txt')**\n**>>> infos = DublinCoreInfo()**\n**>>> infos.summary(adapted)**\n**Title: example**\n**Creator: Unknown**\n**Languages: en**\n\n```", "```py\nfrom zope.interface import Interface, Attribute\n\nclass IRectangle(Interface):\n    width = Attribute(\"The width of rectangle\")\n    height = Attribute(\"The height of rectangle\")\n\n    def area():\n        \"\"\" Return area of rectangle\n        \"\"\"\n\n    def perimeter():\n        \"\"\" Return perimeter of rectangle\n        \"\"\"\n```", "```py\n@implementer(IRectangle)\nclass Square:\n    \"\"\" Concrete implementation of square with rectangle interface\n    \"\"\"\n\n    def __init__(self, size):\n        self.size = size\n\n    @property\n    def width(self):\n        return self.size\n\n    @property\n    def height(self):\n        return self.size\n\n    def area(self):\n        return self.size ** 2\n\n    def perimeter(self):\n        return 4 * self.size\n\n@implementer(IRectangle)\nclass Rectangle:\n    \"\"\" Concrete implementation of rectangle\n    \"\"\"\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def area(self):\n        return self.width * self.height\n\n    def perimeter(self):\n        return self.width * 2 + self.height * 2\n```", "```py\n**>>> from zope.interface.verify import verifyClass, verifyObject**\n**>>> verifyObject(IRectangle, Square(2))**\n**True**\n**>>> verifyClass(IRectangle, Square)**\n**True**\n**>>> verifyObject(IRectangle, Rectangle(2, 2))**\n**True**\n**>>> verifyClass(IRectangle, Rectangle)**\n**True**\n\n```", "```py\n@implementer(IRectangle)\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n@implementer(IRectangle)\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return math.pi * self.radius ** 2\n\n    def perimeter(self):\n        return 2 * math.pi * self.radius\n```", "```py\n**>>> verifyClass(IRectangle, Point)**\n\n**Traceback (most recent call last):**\n **File \"<stdin>\", line 1, in <module>**\n **File \"zope/interface/verify.py\", line 102, in verifyClass**\n **return _verify(iface, candidate, tentative, vtype='c')**\n **File \"zope/interface/verify.py\", line 62, in _verify**\n **raise BrokenImplementation(iface, name)**\n**zope.interface.exceptions.BrokenImplementation: An object has failed to implement interface <InterfaceClass __main__.IRectangle>**\n\n **The perimeter attribute was not provided.**\n\n```", "```py\n**>>> verifyObject(IRectangle, Circle(2))**\n\n**Traceback (most recent call last):**\n **File \"<stdin>\", line 1, in <module>**\n **File \"zope/interface/verify.py\", line 105, in verifyObject**\n **return _verify(iface, candidate, tentative, vtype='o')**\n **File \"zope/interface/verify.py\", line 62, in _verify**\n **raise BrokenImplementation(iface, name)**\n**zope.interface.exceptions.BrokenImplementation: An object has failed to implement interface <InterfaceClass __main__.IRectangle>**\n\n **The width attribute was not provided.**\n\n```", "```py\nassert type(instance) == list\n```", "```py\nassert isinstance(instance, list)\n```", "```py\nassert isinstance(instance, (list, tuple, range))\n```", "```py\nfrom abc import ABCMeta, abstractmethod\n\nclass Pushable(metaclass=ABCMeta):\n\n    @abstractmethod\n    def push(self, x):\n        \"\"\" Push argument no matter what it means\n        \"\"\"\n```", "```py\nfrom abc import ABCMeta, abstractmethod\n\nclass Pushable(metaclass=ABCMeta):\n    @abstractmethod\n    def push(self, x):\n        \"\"\" Push argument no matter what it means\n        \"\"\"\n```", "```py\nclass DummyPushable(Pushable):\n    def push(self, x):\n        return\n\nclass IncompletePushable(Pushable):\n    pass\n```", "```py\n**>>> DummyPushable()**\n**<__main__.DummyPushable object at 0x10142bef0>**\n\n```", "```py\n**>>> IncompletePushable()**\n**Traceback (most recent call last):**\n **File \"<stdin>\", line 1, in <module>**\n**TypeError: Can't instantiate abstract class IncompletePushable with abstract methods push**\n\n```", "```py\n**>>> class SomethingWithPush:**\n**...     def push(self, x):**\n**...         pass**\n**...** \n**>>> isinstance(SomethingWithPush(), Pushable)**\n**False**\n\n```", "```py\nfrom abc import ABCMeta, abstractmethod\n\nclass Pushable(metaclass=ABCMeta):\n\n    @abstractmethod\n    def push(self, x):\n        \"\"\" Push argument no matter what it means\n        \"\"\"\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Pushable:\n            if any(\"push\" in B.__dict__ for B in C.__mro__):\n                return True\n        return NotImplemented\n```", "```py\n**>>> class SomethingWithPush:**\n**...     def push(self, x):**\n**...         pass**\n**...** \n**>>> isinstance(SomethingWithPush(), Pushable)**\n**True**\n\n```", "```py\nfrom abc import (\n    ABCMeta,\n    abstractmethod,\n    abstractproperty\n)\n\nclass IRectangle(metaclass=ABCMeta):\n\n    @abstractproperty\n    def width(self):\n        return\n\n    @abstractproperty\n    def height(self):\n        return\n\n    @abstractmethod\n    def area(self):\n        \"\"\" Return rectangle area\n        \"\"\"\n\n    @abstractmethod\n    def perimeter(self):\n        \"\"\" Return rectangle perimeter\n        \"\"\"\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is IRectangle:\n            if all([\n                any(\"area\" in B.__dict__ for B in C.__mro__),\n                any(\"perimeter\" in B.__dict__ for B in C.__mro__),\n                any(\"width\" in B.__dict__ for B in C.__mro__),\n                any(\"height\" in B.__dict__ for B in C.__mro__),\n            ]):\n                return True\n        return NotImplemented\n```", "```py\ndef draw_rectangle(rectangle: IRectange):\n    ...\n```", "```py\ndef ensure_interface(function):\n    signature = inspect.signature(function)\n    parameters = signature.parameters\n\n    @wraps(function)\n    def wrapped(*args, **kwargs):\n        bound = signature.bind(*args, **kwargs)\n        for name, value in bound.arguments.items():\n            annotation = parameters[name].annotation\n\n            if not isinstance(annotation, ABCMeta):\n                continue\n\n            if not isinstance(value, annotation):\n                raise TypeError(\n                    \"{} does not implement {} interface\"\n                    \"\".format(value, annotation)\n                )\n\n        function(*args, **kwargs)\n\n    return wrapped\n```", "```py\nclass ImplicitRectangle:\n    def __init__(self, width, height):\n        self._width = width\n        self._height = height\n\n    @property\n    def width(self):\n        return self._width\n\n    @property\n    def height(self):\n        return self._height\n\n    def area(self):\n        return self.width * self.height\n\n    def perimeter(self):\n        return self.width * 2 + self.height * 2\n\n@ensure_interface\ndef draw_rectangle(rectangle: IRectangle):\n    print(\n        \"{} x {} rectangle drawing\"\n        \"\".format(rectangle.width, rectangle.height)\n    )\n```", "```py\n**>>> draw_rectangle('foo')**\n**Traceback (most recent call last):**\n **File \"<input>\", line 1, in <module>**\n **File \"<input>\", line 101, in wrapped**\n**TypeError: foo does not implement <class 'IRectangle'> interface**\n\n```", "```py\n**>>> draw_rectangle(ImplicitRectangle(2, 10))**\n**2 x 10 rectangle drawing**\n\n```", "```py\n**>>> class Url(object):**\n**...     def __init__(self, location):**\n**...         self._url = urlopen(location)**\n**...     def headers(self):**\n**...         return dict(self._url.headers.items())**\n**...     def get(self):**\n**...         return self._url.read()**\n**...** \n**>>> python_org = Url('http://python.org')**\n**>>> python_org.headers().keys()**\n**dict_keys(['Accept-Ranges', 'Via', 'Age', 'Public-Key-Pins', 'X-Clacks-Overhead', 'X-Cache-Hits', 'X-Cache', 'Content-Type', 'Content-Length', 'Vary', 'X-Served-By', 'Strict-Transport-Security', 'Server', 'Date', 'Connection', 'X-Frame-Options'])**\n\n```", "```py\n**>>> ubuntu_iso = Url('http://ubuntu.mirrors.proxad.net/hardy/ubuntu-8.04-desktop-i386.iso')**\n**>>> ubuntu_iso.headers()['Last-Modified']**\n**'Wed, 23 Apr 2008 01:03:34 GMT'**\n\n```", "```py\nclass Event:\n    _observers = []\n\n    def __init__(self, subject):\n        self.subject = subject\n\n    @classmethod\n    def register(cls, observer):\n        if observer not in cls._observers:\n            cls._observers.append(observer)\n\n    @classmethod\n    def unregister(cls, observer):\n        if observer in cls._observers:\n            cls._observers.remove(observer)\n\n    @classmethod\n    def notify(cls, subject):\n        event = cls(subject)\n        for observer in cls._observers:\n            observer(event)\n```", "```py\nclass WriteEvent(Event):\n    def __repr__(self):\n        return 'WriteEvent'\n\ndef log(event):\n    print(\n        '{!r} was fired with subject \"{}\"'\n        ''.format(event, event.subject)\n    )\n\nclass AnotherObserver(object):\n    def __call__(self, event):\n        print(\n            \"{!r} trigerred {}'s action\"\n            \"\".format(event, self.__class__.__name__)\n        )\n\nWriteEvent.register(log)\nWriteEvent.register(AnotherObserver())\n```", "```py\n**>>> WriteEvent.notify(\"something happened\")**\n**WriteEvent was fired with subject \"something happened\"**\n**WriteEvent trigerred AnotherObserver's action**\n\n```", "```py\nclass VisitableList(list):\n    def accept(self, visitor):\n        visitor.visit_list(self)\n\nclass VisitableDict(dict):\n    def accept(self, visitor):\n        visitor.visit_dict(self)\n\nclass Printer(object):\n    def visit_list(self, instance):\n        print('list content: {}'.format(instance))\n\n    def visit_dict(self, instance):\n        print('dict keys: {}'.format(\n            ', '.join(instance.keys()))\n        )\n```", "```py\n**>>> visitable_list = VisitableList([1, 2, 5])**\n**>>> visitable_list.accept(Printer())**\n**list content: [1, 2, 5]**\n**>>> visitable_dict = VisitableDict({'one': 1, 'two': 2, 'three': 3})**\n**>>> visitable_dict.accept(Printer())**\n**dict keys: two, one, three**\n\n```", "```py\n**>>> def visit(visited, visitor):**\n**...     cls = visited.__class__.__name__**\n**...     method_name = 'visit_%s' % cls**\n**...     method = getattr(visitor, method_name, None)**\n**...     if isinstance(method, Callable):**\n**...         method(visited)**\n**...     else:**\n**...         raise AttributeError(**\n**...             \"No suitable '{}' method in visitor\"**\n**...             \"\".format(method_name)**\n**...         )**\n**...** \n**>>> visit([1,2,3], Printer())**\n**list content: [1, 2, 3]**\n**>>> visit({'one': 1, 'two': 2, 'three': 3}, Printer())**\n**dict keys: two, one, three**\n**>>> visit((1, 2, 3), Printer())**\n**Traceback (most recent call last):**\n **File \"<input>\", line 1, in <module>**\n **File \"<input>\", line 10, in visit**\n**AttributeError: No suitable 'visit_tuple' method in visitor**\n\n```", "```py\n**>>> def visit(directory, visitor):**\n**...     for root, dirs, files in os.walk(directory):**\n**...         for file in files:**\n**...             # foo.txt \u2192 .txt**\n**...             ext = os.path.splitext(file)[-1][1:]**\n**...             if hasattr(visitor, ext):**\n**...                 getattr(visitor, ext)(file)**\n**...**\n**>>> class FileReader(object):**\n**...     def pdf(self, filename):**\n**...         print('processing: {}'.format(filename))**\n**...**\n**>>> walker = visit('/Users/tarek/Desktop', FileReader())**\n**processing slides.pdf**\n**processing sholl23.pdf**\n\n```", "```py\nfrom collections import Counter\n\nclass Indexer:\n    def process(self, text):\n        text = self._normalize_text(text)\n        words = self._split_text(text)\n        words = self._remove_stop_words(words)\n        stemmed_words = self._stem_words(words)\n\n        return self._frequency(stemmed_words)\n\n    def _normalize_text(self, text):\n        return text.lower().strip()\n\n    def _split_text(self, text):\n        return text.split()\n\n    def _remove_stop_words(self, words):\n        raise NotImplementedError\n\n    def _stem_words(self, words):\n        raise NotImplementedError\n\n    def _frequency(self, words):\n        return Counter(words)\n```", "```py\nclass BasicIndexer(Indexer):\n    _stop_words = {'he', 'she', 'is', 'and', 'or', 'the'}\n\n    def _remove_stop_words(self, words):\n        return (\n            word for word in words\n            if word not in self._stop_words\n        )\n\n    def _stem_words(self, words):\n        return (\n            (\n                len(word) > 3 and\n                word.rstrip('aeiouy') or\n                word\n            )\n            for word in words\n        )\n```", "```py\n**>>> indexer = BasicIndexer()**\n**>>> indexer.process(\"Just like Johnny Flynn said\\nThe breath I've taken and the one I must to go on\")**\n**Counter({\"i'v\": 1, 'johnn': 1, 'breath': 1, 'to': 1, 'said': 1, 'go': 1, 'flynn': 1, 'taken': 1, 'on': 1, 'must': 1, 'just': 1, 'one': 1, 'i': 1, 'lik': 1})**\n\n```"]