["```py\nAtomisator is a product that fetches RSS feeds and saves them in a database, with a filtering process.\n\nIf you are a developer, you might want to look at the API description (api.txt)\n\nIf you are a manager, you can read the features list and the FAQ (features.txt)\n\nIf you are a designer, you can read the architecture and infrastructure notes (arch.txt)\n```", "```py\n**>>> from atomisator.parser import parse**\n**>>> # Let's use it:**\n**>>> stuff = parse('some-feed.xml')**\n**>>> next(stuff)**\n**{'title': 'foo', 'content': 'blabla'}**\n\n```", "```py\n**>>> from atomisator.parser import parse**\n**>>> # Let's use it:**\n**>>> my_feed = parse('http://tarekziade.wordpress.com/feed')**\n**>>> next(my_feed)**\n**{'title': 'eight tips to start with python', 'content': 'The first tip is..., ...'}**\n\n```", "```py\n=====\nTitle\n=====\n\nSection 1\n=========\nThis *word* has emphasis.\n\nSection 2\n=========\n\nSubsection\n::::::::::\n\nText.\n```", "```py\n**$ pip install docutils**\n\n```", "```py\n**$ more text.txt**\n**Title**\n**=====**\n\n**content.**\n\n**$ rst2html.py text.txt**\n**<?xml version=\"1.0\" encoding=\"utf-8\" ?>**\n**...**\n**<html ...>**\n**<head>**\n**...**\n**</head>**\n**<body>**\n**<div class=\"document\" id=\"title\">**\n**<h1 class=\"title\">Title</h1>**\n**<p>content.</p>**\n**</div>**\n**</body>**\n**</html>**\n\n```", "```py\n==============\nDocument title\n==============\n\nIntroduction to the document content.\n\nSection 1\n=========\n\nFirst document section with two subsections.\n\nNote the ``=`` used as heading underline.\n\nSubsection A\n------------\n\nFirst subsection (A) of Section 1.\n\nNote the ``-`` used as heading underline.\n\nSubsection B\n------------\nSecond subsection (B) of Section 1.\n\nSection 2\n=========\n\nSecond section of document with one subsection.\n\nSubsection C\n------------\n\nSubsection (C) of Section 2.\n```", "```py\nBullet list:\n\n- one\n- two\n- three\n\nEnumerated list:\n\n1\\. one\n2\\. two\n#. auto-enumerated\n\nDefinition list:\n\none\n    one is a number.\n\ntwo\n    two is also a number.\n```", "```pyinline preformated```", "```py\nThis is a code example\n\n::\n\n    >>> 1 + 1\n    2\n\nLet's continue our text\n```", "```py\nThis is a code example::\n\n    >>> 1 + 1\n    2\n\nLet's continue our text\n```", "```py\nTry `Plone CMS`_, it is great ! It is based on Zope_.\n\n.. _`Plone CMS`: http://plone.org\n.. _Zope: http://zope.org\n```", "```py (backtick) characters.\n\nInternal links can also be used by adding a marker in the text:\n\n```", "```py\n\nSections are also targets that can be used:\n\n```", "```py\n\n# Building the documentation\n\nAn easier way to guide your readers and your writers is to provide each one of them with helpers and guidelines, as we have learned in the previous section of this chapter.\n\nFrom a writer's point of view, this is done by having a set of reusable templates together with a guide that describes how and when to use them in a project. It is called a **documentation portfolio**.\n\nFrom a reader's point of view, it is important to be able to browse the documentation with no pain, and getting used to finding the information efficiently. It is done by building a **document landscape**.\n\n## Building the portfolio\n\nThere are many kinds of documents a software project can have, from low-level documents that refer directly to the code, to design papers that provide a high-level overview of the application.\n\nFor instance, Scott Ambler defines an extensive list of document types in his book, *Agile Modeling: Effective Practices for eXtreme Programming and the Unified Process*, *John Wiley & Sons*. He builds a portfolio from early specifications to operations documents. Even the project management documents are covered, so the whole documenting needs are built with a standardized set of templates.\n\nSince a complete portfolio is tightly related to the methodologies used to build the software, this chapter will only focus on a common subset that you can complete with your specific needs. Building an efficient portfolio takes a long time as it captures your working habits.\n\nA common set of documents in software projects can be classified into three categories:\n\n*   **Design**: This includes all the documents that provide architectural information and low-level design information, such as class diagrams or database diagrams\n*   **Usage**: This includes all the documents on how to use the software; this can be in the shape of a cookbook and tutorials or a module-level help\n*   **Operations**: This provides guidelines on how to deploy, upgrade, or operate the software\n\n### Design\n\nThe important point when creating such documents is to make sure the target readership is perfectly known and the content scope is limited. So, a generic template for design documents can provide a light structure with a little advice for the writer.\n\nSuch a structure might include:\n\n*   Title\n*   Author\n*   Tags (keywords)\n*   Description (abstract)\n*   Target (who should read this?)\n*   Content (with diagrams)\n*   References to other documents\n\nThe content should be three or four pages when printed, at the most, to be sure to limit the scope. If it gets bigger, it should be split into several documents or summarized.\n\nThe template also provides the author's name and a list of tags to manage its evolutions and ease its classification. This will be covered later in the chapter.\n\nThe example design document template in reST could be as follows:\n\n```", "```py\n\n### Usage\n\nThe usage documentation describes how a particular part of the software is used. This documentation can describe low-level parts, such as how a function works, but also high-level parts, such as command-line arguments for calling the program. This is the most important part of documentation in framework applications, since the target readership is mainly the developers that are going to reuse the code.\n\nThe three main kinds of documents are:\n\n*   **Recipe**: This is a short document that explains how to do something. This kind of document targets one readership and focuses on one specific topic.\n*   **Tutorial**: This is a step-by-step document that explains how to use a feature of the software. This document can refer to recipes, and each instance is intended to one readership.\n*   **Module helper**: This is a low-level document that explains what a module contains. This document could be shown (for instance) when you call the `help` built-in over a module.\n\n#### Recipe\n\nA recipe answers a very specific problem and provides a solution to resolve it. For example, ActiveState provide a huge repository of Python recipes online where developers can describe how to do something in Python (refer to [http://code.activestate.com/recipes/langs/python/](http://code.activestate.com/recipes/langs/python/)). Such a set of recipes related to a single area/project is often called *cookbook*.\n\nThese recipes must be short and are structured like this:\n\n*   Title\n*   Submitter\n*   Last updated\n*   Version\n*   Category\n*   Description\n*   Source (the source code)\n*   Discussion (the text explaining the code)\n*   Comments (from the Web)\n\nOften, they are one-screen long and do not go into great detail. This structure perfectly fits a software's needs and can be adapted in a generic structure, where the target readership is added and the category is replaced by tags:\n\n*   Title (short sentence)\n*   Author\n*   Tags (keywords)\n*   Who should read this?\n*   Prerequisites (other documents to read, for example)\n*   Problem (a short description)\n*   Solution (the main text, one or two screens)\n*   References (links to other documents)\n\nThe date and version are not useful here, since project documentation should be rather managed like a source code in the project. This means that the best way to handle the documentation is to manage it through the version control system. In most cases, this is exactly the same code repository as the one used for the project's code.\n\nA simple reusable template for the recipes could be as follows:\n\n```", "```py\n\n#### Tutorial\n\nA tutorial differs from a recipe in its purpose. It is not intended to resolve an isolated problem, but rather describes how to use a feature of the application step by step. This can be longer than a recipe and can concern many parts of the application. For example, Django provides a list of tutorials on its website. *Writing your first Django App, part 1* (refer to [https://docs.djangoproject.com/en/1.9/intro/tutorial01/](https://docs.djangoproject.com/en/1.9/intro/tutorial01/)) explains in few screens how to build an application with Django.\n\nA structure for such a document will be:\n\n*   Title (short sentence)\n*   Author\n*   Tags (words)\n*   Description (abstract)\n*   Who should read this?\n*   Prerequisites (other documents to read, for example)\n*   Tutorial (the main text)\n*   References (links to other documents)\n\n#### Module helper\n\nThe last template that can be added in our collection is the module helper template. A module helper refers to a single module and provides a description of its contents, together with usage examples.\n\nSome tools can automatically build such documents by extracting the docstrings and computing module help using `pydoc`, such as Epydoc (refer to [http://epydoc.sourceforge.net](http://epydoc.sourceforge.net)). So it is possible to generate an extensive documentation based on API introspection. This kind of documentation is often provided in Python frameworks. For instance, Plone provides an [http://api.plone.org](http://api.plone.org) server that keeps an up-to-date collection of module helpers.\n\nThe main problems with this approach are:\n\n*   There is no smart selection performed over the modules that are really interesting to the document\n*   The code can be obfuscated by the documentation\n\nFurthermore, a module documentation provides examples that sometimes refer to several parts of the module and that are hard to split between the functions' and classes' docstrings. The module docstring could be used for that purpose by writing text at the top of the module. But this ends in having a hybrid file composed of a block of text rather than a block of code. This is rather obfuscating when the code represents less than 50% of the total length. If you are the author, this is perfectly fine. But when people try to read the code (not the documentation), they will have to skip the docstrings part.\n\nAnother approach is to separate the text in its own file. A manual selection can then be operated to decide which Python module will have its module helper file. The documents can then be separated from the code base and allowed to live their own life, as we will see in the next part. This is how Python is documented.\n\nMany developers will disagree on the fact that doc and code separation is better than docstrings. This approach means that the documentation process is fully integrated in the development cycle; otherwise it will quickly become obsolete. The docstrings approach solves this problem by providing proximity between the code and its usage example but doesn't bring it to a higher level\u2014a document that can be used as part of a plain documentation.\n\nThe template for a module helper is really simple, as it contains just a little metadata before the content is written. The target is not defined since it is the developers who wish to use the module:\n\n*   Title (module name)\n*   Author\n*   Tags (words)\n*   Content\n\n### Note\n\nThe next chapter will cover test-driven development using doctests and module helpers.\n\n### Operations\n\nOperation documents are used to describe how the software can be operated. Consider the following points for instance:\n\n*   Installation and deployment documents\n*   Administration documents\n*   Frequently Asked Questions (FAQ) documents\n*   Documents that explain how people can contribute, ask for help, or provide feedback\n\nThese documents are very specific but they can probably use the tutorial template defined in the earlier section.\n\n# Making your own portfolio\n\nThe templates that we discussed earlier are just a basis that you can use to document your software. With time, you will eventually develop your own templates and style for making documentation. But always keep in mind the light but sufficient approach for project documentation: each document added should have a clearly defined target readership and should fill a real need. Documents that don't add a real value should not be written.\n\nEach project is unique and has different documentation needs. For example, small terminal tools with simple usage can definitely live with only a single `README` file as its document landscape. Having such a minimal single-document approach is completely fine if the target readers are precisely defined and consistently grouped (system administrators, for instance).\n\nAlso, do not apply the provided templates too rigorously. Some additional metadata provided as an example is really useful in either big projects or in strictly formalized teams. Tags, for instance, are intended to improve textual search in big documentations but will not provide any value in a documentation landscape consisting only of a few documents.\n\nAlso, including the document author is not always a good idea. Such an approach may be especially questionable in open source projects. In such projects, you will want the community to also contribute to documentation. In most cases, such documents are continuously updated whenever there is such a need by whoever makes the contribution. People tend to treat the document *author* also as the document *owner*. This may discourage people to update the documentation if every document has its author always specified. Usually, the version control software provides clearer and more transparent information about real document authors than explicitly provided metadata annotations. The situations where explicit authors are really recommended are various design documents, especially in projects where the design process is strictly formalized. The best example is the series of PEP documents with the Python language enhancement proposals.\n\n## Building the landscape\n\nThe document portfolio built in the previous section provides a structure at document level but does not provide a way to group and organize it to build the documentation the readers will have. This is what Andreas R\u00fcping calls a document landscape, referring to the mental map the readers use when they browse documentation. He came up with the conclusion that the best way to organize documents is to build a logical tree.\n\nIn other words, the different kinds of documents composing the portfolio need to find a place to live within a tree of directories. This place must be obvious to the writers when they create the document and to the readers when they are looking for it.\n\nA great help when browsing documentation is the index pages at each level that can drive writers and readers.\n\nBuilding a document landscape is done in two steps:\n\n*   Building a tree for the producers (the writers)\n*   Building a tree for the consumers (the readers) on top of the producers' tree\n\nThis distinction between producers and consumers is important since they access the documents in different places and different formats.\n\n### Producer's layout\n\nFrom a producer's point of view, each document is processed exactly like a Python module. It should be stored in the version control system and works like code. Writers do not care about the final appearance of their prose and where it is available, they just want to make sure that they are writing a document, so it is the single source of truth on the topic covered. reStructuredText files stored in a folder tree are available in the version control system together with the software code and are a convenient solution to building the documentation landscape for producers.\n\nBy convention, the `docs` folder is used as a root of documentation tree:\n\n```", "```py\n\nNotice that the tree is located in a `source` folder because the `docs` folder will be used as a root folder to set up a special tool in the next section.\n\nFrom there, an `index.txt` file can be added at each level (besides the root), explaining what kind of documents the folder contains or summarizing what each subfolder contains. These index files can define a listing of the documents they contain. For instance, the `operations` folder can contain a list of operations documents available:\n\n```", "```py\n\nIt is important to know that people tend to forget to update such lists of documents and tables of content. So it is better to have them updated automatically. In the next subsection, we will discuss one tool that, among many other features, can also handle this use case.\n\n### Consumer's layout\n\nFrom a consumer's point of view, it is important to work out the index files and to present the whole documentation in a format that is easy to read and looks good. Web pages are the best pick and are easy to generate from reStructuredText files.\n\n**Sphinx** ([http://sphinx.pocoo.org](http://sphinx.pocoo.org)) is a set of scripts and `docutils` extensions that can be used to generate an HTML structure from our text tree. This tool is used (for instance) to build the Python documentation, and many projects are now using it for their documentation. Among its built-in features, it produces a really nice browsing system, together with a light but sufficient client-side JavaScript search engine. It also uses `pygments` for rendering code examples, which produces really nice syntax highlights.\n\nSphinx can be easily configured to stick with the document landscape defined in the earlier section. It can be easily installed with `pip` as `Sphinx` package.\n\nThe easiest way to start working with Sphinx is to use the `sphinx-quickstart` script. This utility will generate a script together with `Makefile`, which can be used to generate the web documentation every time it is needed. It will interactively ask you some questions and then bootstrap the whole initial documentation source tree and configuration file. Once it is done, you can easily tweak it whenever you want. Let's assume we have already bootstrapped the whole Sphinx environment and we want to see its HTML representation. This can be easily done using the `make html` command:\n\n```", "```py\n\n![Consumer's layout](graphics/5295_09_04.jpg)\n\nFigure 4 An example HTML version of documentation built with Sphinx \u2013 [http://graceful.readthedocs.org/en/latest/](http://graceful.readthedocs.org/en/latest/)\n\nBesides the HTML versions of the documents, the tool also builds automatic pages, such as a module list and an index. Sphinx provides a few `docutils` extensions to drive these features. The main ones are:\n\n*   A directive that builds a table of contents\n*   A marker that can be used to register a document as a module helper\n*   A marker to add an element in the index\n\n#### Working on the index pages\n\nSphinx provides a `toctree` directive that can be used to inject a table of contents in a document with links to other documents. Each line must be a file with its relative path, starting from the current document. Glob-style names can also be provided to add several files that match the expression.\n\nFor example, the index file in the `cookbook` folder, which we have previously defined in the producer's landscape, can look like this:\n\n```", "```py\n\nWith this syntax, the HTML page will display a list of all the reStructuredText documents available in the `cookbook` folder. This directive can be used in all the index files to build a browsable documentation.\n\n#### Registering module helpers\n\nFor module helpers, a marker can be added so that it is automatically listed and available in the module's index page:\n\n```", "```py\n\nNotice that the `db` prefix here can be used to avoid module collision. Sphinx will use it as a module category and will group all modules that start with `db.` in this category.\n\n#### Adding index markers\n\nAnother option can be used to fill the index page by linking the document to an entry:\n\n```", "```py\n\nTwo new entries, `Database Access` and `Session`, will be added in the index page.\n\n#### Cross-references\n\nFinally, Sphinx provides an inline markup to set cross-references. For instance, a link to a module can be done like this:\n\n```"]