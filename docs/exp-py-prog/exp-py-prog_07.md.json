["```py\nfrom distutils.core import setup, Extension\n\nmodule1 = Extension(\n    'demo',\n    sources=['demo.c']\n)\n\nsetup(\n    name='PackageName',\n    version='1.0',\n    description='This is a demo package',\n    ext_modules=[module1]\n)\n```", "```py\n**python setup.py build**\n\n```", "```py\n\"\"\"Python module that provides fibonacci sequence function\"\"\"\n\ndef fibonacci(n):\n    \"\"\"Return nth Fibonacci sequence number computed recursively.\n    \"\"\"\n    if n < 2:\n        return 1\n    else:\n        return fibonacci(n - 1) + fibonacci(n - 2)\n```", "```py\nlong long fibonacci(unsigned int n) {\n    if (n < 2) {\n        return 1;\n    } else {\n        return fibonacci(n - 2) + fibonacci(n - 1);\n    }\n}\n```", "```py\n#include <Python.h>\n\nlong long fibonacci(unsigned int n) {\n    if (n < 2) {\n        return 1;\n    } else {\n        return fibonacci(n-2) + fibonacci(n-1);\n    }\n}\n\nstatic PyObject* fibonacci_py(PyObject* self, PyObject* args) {\n    PyObject *result = NULL;\n    long n;\n\n    if (PyArg_ParseTuple(args, \"l\", &n)) {\n        result = Py_BuildValue(\"L\", fibonacci((unsigned int)n));\n    }\n\n    return result;\n}\n\nstatic char fibonacci_docs[] =\n    \"fibonacci(n): Return nth Fibonacci sequence number \"\n    \"computed recursively\\n\";\n\nstatic PyMethodDef fibonacci_module_methods[] = {\n    {\"fibonacci\", (PyCFunction)fibonacci_py,\n     METH_VARARGS, fibonacci_docs},\n    {NULL, NULL, 0, NULL}\n};\n\nstatic struct PyModuleDef fibonacci_module_definition = {\n    PyModuleDef_HEAD_INIT,\n    \"fibonacci\",\n    \"Extension module that provides fibonacci sequence function\",\n    -1,\n    fibonacci_module_methods\n};\n\nPyMODINIT_FUNC PyInit_fibonacci(void) {\n    Py_Initialize();\n\n    return PyModule_Create(&fibonacci_module_definition);\n}\n```", "```py\nfrom setuptools import setup, Extension\n\nsetup(\n    name='fibonacci',\n    ext_modules=[\n        Extension('fibonacci', ['fibonacci.c']),\n    ]\n)\n```", "```py\n**$ ls -1a**\n**fibonacci.c**\n**setup.py**\n\n**$ pip install -e .**\n**Obtaining file:///Users/swistakm/dev/book/chapter7**\n**Installing collected packages: fibonacci**\n **Running setup.py develop for fibonacci**\n**Successfully installed Fibonacci**\n\n**$ ls -1ap**\n**build/**\n**fibonacci.c**\n**fibonacci.cpython-35m-darwin.so**\n**fibonacci.egg-info/**\n**setup.py**\n\n**$ python**\n**Python 3.5.1 (v3.5.1:37a07cee5969, Dec  5 2015, 21:12:44)** \n**[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin**\n**Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.**\n**>>> import fibonacci**\n**>>> help(fibonacci.fibonacci)**\n\n**Help on built-in function fibonacci in fibonacci:**\n\n**fibonacci.fibonacci = fibonacci(...)**\n **fibonacci(n): Return nth Fibonacci sequence number computed recursively**\n\n**>>> [fibonacci.fibonacci(n) for n in range(10)]**\n**[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]**\n**>>>** \n\n```", "```py\n#include <Python.h>\n```", "```py\nlong long fibonacci(unsigned int n) {\n    if (n < 2) {\n        return 1;\n    } else {\n        return fibonacci(n - 2) + fibonacci(n - 1);\n    }\n}\n```", "```py\nstatic PyObject* fibonacci_py(PyObject* self, PyObject* args)s\n```", "```py\nstatic PyObject* fibonacci_py(PyObject* self, PyObject* args) {\n    PyObject *result = NULL;\n    long n;\n\n    if (PyArg_ParseTuple(args, \"l\", &n)) {\n        result = Py_BuildValue(\"L\", fibonacci((unsigned int)n));\n    }\n\n    return result;\n}\n```", "```py\nstatic char fibonacci_docs[] =\n    \"fibonacci(n): Return nth Fibonacci sequence number \"\n    \"computed recursively\\n\";\n```", "```py\nstatic PyMethodDef fibonacci_module_methods[] = {\n    {\"fibonacci\", (PyCFunction)fibonacci_py,\n     METH_VARARGS, fibonacci_docs},\n    {NULL, NULL, 0, NULL}\n};\n```", "```py\nstatic struct PyModuleDef fibonacci_module_definition = {\n    PyModuleDef_HEAD_INIT,\n    \"fibonacci\",\n    \"Extension module that provides fibonacci sequence function\",\n    -1,\n    fibonacci_module_methods\n};\n```", "```py\nPyMODINIT_FUNC PyInit_fibonacci(void) {\n    return PyModule_Create(&fibonacci_module_definition);\n}\n```", "```py\n#include <Python.h>\n\nstatic PyObject* print_args(PyObject *self, PyObject *args, PyObject *keywds)\n{\n    char *first;\n    char *second;\n\n    static char *kwlist[] = {\"first\", \"second\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, keywds, \"ss\", kwlist,\n                                     &first, &second))\n        return NULL;\n\n    printf(\"%s %s\\n\", first, second);\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyMethodDef module_methods[] = {\n    {\"print_args\", (PyCFunction)print_args,\n     METH_VARARGS | METH_KEYWORDS,\n     \"print provided arguments\"},\n    {NULL, NULL, 0, NULL}\n};\n\nstatic struct PyModuleDef module_definition = {\n    PyModuleDef_HEAD_INIT,\n    \"kwargs\",\n    \"Keyword argument processing example\",\n    -1,\n    module_methods\n};\n\nPyMODINIT_FUNC PyInit_kwargs(void) {\n    return PyModule_Create(&module_definition);\n}\n```", "```py\nstatic PyObject* fibonacci_py(PyObject* self, PyObject* args) {\n **PyObject *result = NULL;**\n    long n;\n\n **if (PyArg_ParseTuple(args, \"l\", &n)) {**\n **result = Py_BuildValue(\"L\", fibonacci((unsigned int) n));**\n    }\n\n **return result;**\n}\n```", "```py\nvoid PyErr_SetString(PyObject* type, const char* message)\n```", "```py\n    if (PyArg_ParseTuple(args, \"l\", &n)) {\n      result = Py_BuildValue(\"L\", fibonacci((unsigned int) n));\n    }\n```", "```py\nstatic PyObject* fibonacci_py(PyObject* self, PyObject* args) {\n    PyObject *result = NULL;\n    long n;\n    long long fib;\n\n    if (PyArg_ParseTuple(args, \"l\", &n)) {\n        if (n<0) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"n must not be less than 0\");\n        } else {\n            result = Py_BuildValue(\"L\", fibonacci((unsigned int)n));\n        }\n    }\n\n    return result;\n}\n```", "```py\nstatic PyObject* fibonacci_py(PyObject* self, PyObject* args) {\n    PyObject *result = NULL;\n    long n;\n    long long fib;\n\n    if (PyArg_ParseTuple(args, \"l\", &n)) {\n        if (n<0) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"n must not be less than 0\");\n        } else {\n            Py_BEGIN_ALLOW_THREADS;\n            fib = fibonacci(n);\n            Py_END_ALLOW_THREADS;\n\n            result = Py_BuildValue(\"L\", fib);\n        }}\n\n    return result;\n}\n```", "```py\nvoid bug(PyObject *list) {\n    PyObject *item = PyList_GetItem(list, 0);\n\n    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n    PyObject_Print(item, stdout, 0); /* BUG! */\n}\n```", "```py\nvoid no_bug(PyObject *list) {\n    PyObject *item = PyList_GetItem(list, 0);\n\n    Py_INCREF(item);\n    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n    PyObject_Print(item, stdout, 0);\n    Py_DECREF(item);\n}\n```", "```py\nfrom setuptools import setup\nfrom Cython.Build import cythonize\n\nsetup(\n    name='fibonacci',\n    ext_modules=cythonize(['fibonacci.py'])\n)\n```", "```py\nimport os\n\nfrom distutils.core import setup\nfrom distutils.extension import Extension\n\ntry:\n    # cython source to source compilation available\n    # only when Cython is available\n    import Cython\n    # and specific environment variable says\n    # explicitely that Cython should be used\n    # to generate C sources\n    USE_CYTHON = bool(os.environ.get(\"USE_CYTHON\"))\n\nexcept ImportError:\n    USE_CYTHON = False\n\next = '.pyx' if USE_CYTHON else '.c'\n\nextensions = [Extension(\"fibonacci\", [\"fibonacci\"+ext])]\n\nif USE_CYTHON:\n    from Cython.Build import cythonize\n    extensions = cythonize(extensions)\n\nsetup(\n    name='fibonacci',\n    ext_modules=extensions,\n    extras_require={\n        # Cython will be set in that specific version\n        # as a requirement if package will be intalled\n        # with '[with-cython]' extra feature\n        'cython': ['cython==0.23.4']\n    }\n)\n```", "```py\n**$ USE_CYTHON=1 pip install .[with-cython]**\n\n```", "```py\n\"\"\"Cython module that provides fibonacci sequence function.\"\"\"\n\ndef fibonacci(unsigned int n):\n    \"\"\"Return nth Fibonacci sequence number computed recursively.\"\"\"\n    if n < 2:\n        return n\n    else:\n        return fibonacci(n - 1) + fibonacci(n - 2)\n```", "```py\n**>>> from fibonacci import fibonacci**\n**>>> fibonacci(5)**\n**5**\n**>>> fibonacci(-1)**\n**Traceback (most recent call last):**\n **File \"<stdin>\", line 1, in <module>**\n **File \"fibonacci.pyx\", line 21, in fibonacci.fibonacci (fibonacci.c:704)**\n**OverflowError: can't convert negative value to unsigned int**\n**>>> fibonacci(10 ** 10)**\n**Traceback (most recent call last):**\n **File \"<stdin>\", line 1, in <module>**\n **File \"fibonacci.pyx\", line 21, in fibonacci.fibonacci (fibonacci.c:704)**\n**OverflowError: value too large to convert to unsigned int**\n\n```", "```py\ncdef long long fibonacci_cc(unsigned int n):\n    if n < 2:\n        return n\n    else:\n        return fibonacci_cc(n - 1) + fibonacci_cc(n - 2)\n\ndef fibonacci(unsigned int n):\n    \"\"\" Return nth Fibonacci sequence number computed recursively\n    \"\"\"\n    return fibonacci_cc(n)\n```", "```py\ndef fibonacci(unsigned int n):\n    \"\"\" Return nth Fibonacci sequence number computed recursively\n    \"\"\"\n **with nogil:**\n        result = fibonacci_cc(n)\n\n    return fibonacci_cc(n)\n```", "```py\n**cdef long long fibonacci_cc(unsigned int n) nogil:**\n    if n < 2:\n        return n\n    else:\n        return fibonacci_cc(n - 1) + fibonacci_cc(n - 2)\n```", "```py\n**>>> import ctypes**\n**>>> ctypes.cdll.LoadLibrary('libc.so.6')**\n**<CDLL 'libc.so.6', handle 7f0603e5f000 at 7f0603d4cbd0>**\n\n```", "```py\n**>>> import ctypes**\n**>>> ctypes.cdll.LoadLibrary('libc.dylib')**\n\n```", "```py\n**>>> import ctypes**\n**>>> from ctypes.util import find_library**\n**>>> ctypes.cdll.LoadLibrary(find_library('c'))**\n**<CDLL '/usr/lib/libc.dylib', handle 7fff69b97c98 at 0x101b73ac8>**\n**>>> ctypes.cdll.LoadLibrary(find_library('bz2'))**\n**<CDLL '/usr/lib/libbz2.dylib', handle 10042d170 at 0x101b6ee80>**\n**>>> ctypes.cdll.LoadLibrary(find_library('AGL'))**\n**<CDLL '/System/Library/Frameworks/AGL.framework/AGL', handle 101811610 at 0x101b73a58>**\n\n```", "```py\n**>>> import ctypes**\n**>>> from ctypes.util import find_library**\n**>>>** \n**>>> libc = ctypes.cdll.LoadLibrary(find_library('c'))**\n**>>>** \n**>>> libc.printf(b\"Hello world!\\n\")**\n**Hello world!**\n**13**\n\n```", "```py\n**>>> import ctypes**\n**>>> IntArray5 = ctypes.c_int * 5**\n**>>> c_int_array = IntArray5(1, 2, 3, 4, 5)**\n**>>> FloatArray2 = ctypes.c_float * 2**\n**>>> c_float_array = FloatArray2(0, 3.14)**\n**>>> c_float_array[1]**\n**3.140000104904175**\n\n```", "```py\nvoid qsort(void *base, size_t nel, size_t width,\n           int (*compar)(const void *, const void *));\n```", "```py\nCMPFUNC = ctypes.CFUNCTYPE(\n    # return type\n    ctypes.c_int,\n    # first argument type\n    ctypes.POINTER(ctypes.c_int),\n    # second argument type\n    ctypes.POINTER(ctypes.c_int),\n)\n```", "```py\nfrom random import shuffle\n\nimport ctypes\nfrom ctypes.util import find_library\n\nlibc = ctypes.cdll.LoadLibrary(find_library('c'))\n\nCMPFUNC = ctypes.CFUNCTYPE(\n    # return type\n    ctypes.c_int,\n    # first argument type\n    ctypes.POINTER(ctypes.c_int),\n    # second argument type\n    ctypes.POINTER(ctypes.c_int),\n)\n\ndef ctypes_int_compare(a, b):\n    # arguments are pointers so we access using [0] index\n    print(\" %s cmp %s\" % (a[0], b[0]))\n\n    # according to qsort specification this should return:\n    # * less than zero if a < b\n    # * zero if a == b\n    # * more than zero if a > b\n    return a[0] - b[0]\n\ndef main():\n    numbers = list(range(5))\n    shuffle(numbers)\n    print(\"shuffled: \", numbers)\n\n    # create new type representing array with length\n    # same as the length of numbers list\n    NumbersArray = ctypes.c_int * len(numbers)\n    # create new C array using a new type\n    c_array = NumbersArray(*numbers)\n\n    libc.qsort(\n        # pointer to the sorted array\n        c_array,\n        # length of the array\n        len(c_array),\n        # size of single array element\n        ctypes.sizeof(ctypes.c_int),\n        # callback (pointer to the C comparison function)\n        CMPFUNC(ctypes_int_compare)\n    )\n    print(\"sorted:   \", list(c_array))\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\n**$ python ctypes_qsort.py** \n**shuffled:  [4, 3, 0, 1, 2]**\n **4 cmp 3**\n **4 cmp 0**\n **3 cmp 0**\n **4 cmp 1**\n **3 cmp 1**\n **0 cmp 1**\n **4 cmp 2**\n **3 cmp 2**\n **1 cmp 2**\n**sorted:    [0, 1, 2, 3, 4]**\n\n```", "```py\nfrom random import shuffle\n\nfrom cffi import FFI\n\nffi = FFI()\n\nffi.cdef(\"\"\"\nvoid qsort(void *base, size_t nel, size_t width,\n           int (*compar)(const void *, const void *));\n\"\"\")\nC = ffi.dlopen(None)\n\n@ffi.callback(\"int(void*, void*)\")\ndef cffi_int_compare(a, b):\n    # Callback signature requires exact matching of types.\n    # This involves less more magic than in ctypes\n    # but also makes you more specific and requires\n    # explicit casting\n    int_a = ffi.cast('int*', a)[0]\n    int_b = ffi.cast('int*', b)[0]\n    print(\" %s cmp %s\" % (int_a, int_b))\n\n    # according to qsort specification this should return:\n    # * less than zero if a < b\n    # * zero if a == b\n    # * more than zero if a > b\n    return int_a - int_b\n\ndef main():\n    numbers = list(range(5))\n    shuffle(numbers)\n    print(\"shuffled: \", numbers)\n\n    c_array = ffi.new(\"int[]\", numbers)\n\n    C.qsort(\n        # pointer to the sorted array\n        c_array,\n        # length of the array\n        len(c_array),\n        # size of single array element\n        ffi.sizeof('int'),\n        # callback (pointer to the C comparison function)\n        cffi_int_compare,\n    )\n    print(\"sorted:   \", list(c_array))\n\nif __name__ == \"__main__\":\n    main()\n```"]