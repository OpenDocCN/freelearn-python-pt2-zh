["```py\n**>>> print(bytes([102, 111, 111]))**\n**b'foo'**\n\n```", "```py\n**>>> list(b'foo bar')**\n**[102, 111, 111, 32, 98, 97, 114]**\n**>>> tuple(b'foo bar')**\n**(102, 111, 111, 32, 98, 97, 114)**\n\n```", "```py\n**>>> type(\"some string\")**\n**<class 'str'>**\n\n```", "```py\n**>>> type(b\"some bytes\")**\n**<class 'bytes'>**\n\n```", "```py\ns = \"\"\nfor substring in substrings:\n    s += substring\n```", "```py\ns = \"\".join(substrings)\n```", "```py\n**>>> ','.join(['some', 'comma', 'separated', 'values'])**\n**'some,comma,separated,values'**\n\n```", "```py\n**>>> evens = []**\n**>>> for i in range(10):**\n**...     if i % 2 == 0:**\n**...         evens.append(i)**\n**...** \n**>>> evens**\n**[0, 2, 4, 6, 8]**\n\n```", "```py\n**>>> [i for i in range(10) if i % 2 == 0]**\n**[0, 2, 4, 6, 8]**\n\n```", "```py\n**>>> i = 0**\n**>>> for element in ['one', 'two', 'three']:**\n**...     print(i, element)**\n**...     i += 1**\n**...**\n**0 one**\n**1 two**\n**2 three**\n\n```", "```py\n**>>> for i, element in enumerate(['one', 'two', 'three']):**\n**...     print(i, element)**\n**...**\n**0 one**\n**1 two**\n**2 three**\n\n```", "```py\n**>>> for item in zip([1, 2, 3], [4, 5, 6]):**\n**...     print(item)**\n**...** \n**(1, 4)**\n**(2, 5)**\n**(3, 6)**\n\n```", "```py\n**>>> for item in zip(*zip([1, 2, 3], [4, 5, 6])):**\n**...     print(item)**\n**...** \n**(1, 2, 3)**\n**(4, 5, 6)**\n\n```", "```py\n**>>> first, second, third = \"foo\", \"bar\", 100**\n**>>> first**\n**'foo'**\n**>>> second**\n**'bar'**\n**>>> third**\n**100**\n\n```", "```py\n**>>> # starred expression to capture rest of the sequence**\n**>>> first, second, *rest = 0, 1, 2, 3**\n**>>> first**\n**0**\n**>>> second**\n**1**\n**>>> rest**\n**[2, 3]**\n\n**>>> # starred expression to capture middle of the sequence**\n**>>> first, *inner, last = 0, 1, 2, 3**\n**>>> first**\n**0**\n**>>> inner**\n**[1, 2]**\n**>>> last**\n**3**\n\n**>>> # nested unpacking**\n**>>> (a, b), (c, d) = (1, 2), (3, 4)**\n**>>> a, b, c, d**\n**(1, 2, 3, 4)**\n\n```", "```py\n{\n    1: ' one',\n    2: ' two',\n    3: ' three',\n}\n```", "```py\nsquares = {number: number**2 for number in range(100)}\n```", "```py\n**>>> words = {'foo': 'bar', 'fizz': 'bazz'}**\n**>>> items = words.items()**\n**>>> words['spam'] = 'eggs'**\n**>>> items**\n**dict_items([('spam', 'eggs'), ('fizz', 'bazz'), ('foo', 'bar')])**\n\n```", "```py\n**>>> {number: None for number in range(5)}.keys()**\n**dict_keys([0, 1, 2, 3, 4])**\n\n```", "```py\n**>>> {str(number): None for number in range(5)}.keys()**\n**dict_keys(['1', '2', '4', '0', '3'])**\n**>>> {str(number): None for number in reversed(range(5))}.keys()**\n**dict_keys(['2', '3', '1', '4', '0'])**\n\n```", "```py\n**>>> from collections import OrderedDict**\n**>>> OrderedDict((str(number), None) for number in range(5)).keys()**\n**odict_keys(['0', '1', '2', '3', '4'])**\n\n```", "```py\n**>>> set([set([1,2,3]), set([2,3,4])])**\n**Traceback (most recent call last):**\n **File \"<stdin>\", line 1, in <module>**\n**TypeError: unhashable type: 'set'**\n\n```", "```py\n**>>> set([frozenset([1,2,3]), frozenset([2,3,4])])**\n**{frozenset({1, 2, 3}), frozenset({2, 3, 4})}**\n**>>> frozenset([frozenset([1,2,3]), frozenset([2,3,4])])**\n**frozenset({frozenset({1, 2, 3}), frozenset({2, 3, 4})})**\n\n```", "```py\n**>>> i = iter('abc')**\n**>>> next(i)**\n**'a'**\n**>>> next(i)**\n**'b'**\n**>>> next(i)**\n**'c'**\n**>>> next(i)**\n**Traceback (most recent call last):**\n **File \"<input>\", line 1, in <module>**\n**StopIteration**\n\n```", "```py\nclass CountDown:def __init__(self, step):\n        self.step = step\n    def __next__(self):\n        \"\"\"Return the next element.\"\"\"\n        if self.step <= 0:\n            raise StopIteration\n        self.step -= 1\n        return self.step\n    def __iter__(self):\n        \"\"\"Return the iterator itself.\"\"\"\n        return self\n```", "```py\n**>>> for element in CountDown(4):**\n**...     print(element)**\n**...** \n**3**\n**2**\n**1**\n**0**\n\n```", "```py\ndef fibonacci():\n    a, b = 0, 1\n    while True:\n        yield b\n        a, b = b, a + b\n```", "```py\n**>>> fib = fibonacci()**\n**>>> next(fib)**\n**1**\n**>>> next(fib)**\n**1**\n**>>> next(fib)**\n**2**\n**>>> [next(fib) for i in range(10)]**\n**[3, 5, 8, 13, 21, 34, 55, 89, 144, 233]**\n\n```", "```py\n**>>> import tokenize**\n**>>> reader = open('hello.py').readline**\n**>>> tokens = tokenize.generate_tokens(reader)**\n**>>> next(tokens)**\n**TokenInfo(type=57 (COMMENT), string='# -*- coding: utf-8 -*-', start=(1, 0), end=(1, 23), line='# -*- coding: utf-8 -*-\\n')**\n**>>> next(tokens)**\n**TokenInfo(type=58 (NL), string='\\n', start=(1, 23), end=(1, 24), line='# -*- coding: utf-8 -*-\\n')**\n**>>> next(tokens)**\n**TokenInfo(type=1 (NAME), string='def', start=(2, 0), end=(2, 3), line='def hello_world():\\n')**\n\n```", "```py\ndef power(values):\n    for value in values:\n        print('powering %s' % value)\n        yield value\n\ndef adder(values):\n    for value in values:\n        print('adding to %s' % value)\n        if value % 2 == 0:\n            yield value + 3\n        else:\n            yield value + 2\n```", "```py\n**>>> elements = [1, 4, 7, 9, 12, 19]**\n**>>> results = adder(power(elements))**\n**>>> next(results)**\n**powering 1**\n**adding to 1**\n**3**\n**>>> next(results)**\n**powering 4**\n**adding to 4**\n**7**\n**>>> next(results)**\n**powering 7**\n**adding to 7**\n**9**\n\n```", "```py\ndef psychologist():\n    print('Please tell me your problems')\n    while True:\n        answer = (yield)\n        if answer is not None:\n            if answer.endswith('?'):\n                print(\"Don't ask yourself too much questions\")\n            elif 'good' in answer:\n                print(\"Ahh that's good, go on\")\n            elif 'bad' in answer:\n                print(\"Don't be so negative\")\n```", "```py\n**>>> free = psychologist()**\n**>>> next(free)**\n**Please tell me your problems**\n**>>> free.send('I feel bad')**\n**Don't be so negative**\n**>>> free.send(\"Why I shouldn't ?\")**\n**Don't ask yourself too much questions**\n**>>> free.send(\"ok then i should find what is good for me\")**\n**Ahh that's good, go on**\n\n```", "```py\nclass WithoutDecorators:\n    def some_static_method():\n        print(\"this is static method\")\n    some_static_method = staticmethod(some_static_method)\n\n    def some_class_method(cls):\n        print(\"this is class method\")\n    some_class_method = classmethod(some_class_method)\n```", "```py\nclass WithDecorators:\n    @staticmethod\n    def some_static_method():\n        print(\"this is static method\")\n\n    @classmethod\n    def some_class_method(cls):\n        print(\"this is class method\")\n```", "```py\n@some_decorator\ndef decorated_function():\n    pass\n```", "```py\ndef decorated_function():\n    pass\ndecorated_function = some_decorator(decorated_function)\n```", "```py\ndef mydecorator(function):\n    def wrapped(*args, **kwargs):     \n        # do some stuff before the original\n        # function gets called\n        result = function(*args, **kwargs)\n        # do some stuff after function call and\n        # return the result\n        return result\n    # return wrapper as a decorated function\n    return wrapped\n```", "```py\nclass DecoratorAsClass:\n    def __init__(self, function):\n        self.function = function\n\n    def __call__(self, *args, **kwargs):\n        # do some stuff before the original\n        # function gets called\n        result = self.function(*args, **kwargs)\n        # do some stuff after function call and\n        # return the result\n        return result\n```", "```py\ndef repeat(number=3):\n    \"\"\"Cause decorated function to be repeated a number of times.\n\n    Last value of original function call is returned as a result\n    :param number: number of repetitions, 3 if not specified\n    \"\"\"\n    def actual_decorator(function):\n        def wrapper(*args, **kwargs):\n            result = None\n            for _ in range(number):\n                result = function(*args, **kwargs)\n            return result\n        return wrapper\n    return actual_decorator\n```", "```py\n**>>> @repeat(2)**\n**... def foo():**\n**...     print(\"foo\")**\n**...** \n**>>> foo()**\n**foo**\n**foo**\n\n```", "```py\n**>>> @repeat()**\n**... def bar():**\n**...     print(\"bar\")**\n**...** \n**>>> bar()**\n**bar**\n**bar**\n**bar**\n\n```", "```py\n**>>> @repeat**\n**... def bar():**\n**...     pass**\n**...** \n**>>> bar()**\n**Traceback (most recent call last):**\n **File \"<input>\", line 1, in <module>**\n**TypeError: actual_decorator() missing 1 required positional**\n**argument: 'function'**\n\n```", "```py\ndef dummy_decorator(function):\n    def wrapped(*args, **kwargs):\n        \"\"\"Internal wrapped function documentation.\"\"\"\n        return function(*args, **kwargs)\n    return wrapped\n\n@dummy_decorator\ndef function_with_important_docstring():\n    \"\"\"This is important docstring we do not want to lose.\"\"\"\n```", "```py\n**>>> function_with_important_docstring.__name__**\n**'wrapped'**\n**>>> function_with_important_docstring.__doc__**\n**'Internal wrapped function documentation.'**\n\n```", "```py\nfrom functools import wraps\n\ndef preserving_decorator(function):\n    @wraps(function)\n    def wrapped(*args, **kwargs):\n        \"\"\"Internal wrapped function documentation.\"\"\"\n        return function(*args, **kwargs)\n    return wrapped\n\n@preserving_decorator\ndef function_with_important_docstring():\n    \"\"\"This is important docstring we do not want to lose.\"\"\"\n```", "```py\n**>>> function_with_important_docstring.__name__**\n**'function_with_important_docstring.'**\n**>>> function_with_important_docstring.__doc__**\n**'This is important docstring we do not want to lose.'**\n\n```", "```py\nrpc_info = {}\n\ndef xmlrpc(in_=(), out=(type(None),)):\n    def _xmlrpc(function):\n        # registering the signature\n        func_name = function.__name__\n        rpc_info[func_name] = (in_, out)\n        def _check_types(elements, types):\n            \"\"\"Subfunction that checks the types.\"\"\"\n            if len(elements) != len(types):\n                raise TypeError('argument count is wrong')\n            typed = enumerate(zip(elements, types))\n            for index, couple in typed:\n                arg, of_the_right_type = couple\n                if isinstance(arg, of_the_right_type):\n                    continue\n                raise TypeError(\n                    'arg #%d should be %s' % (index, of_the_right_type))\n\n        # wrapped function\n        def __xmlrpc(*args):  # no keywords allowed\n            # checking what goes in\n            checkable_args = args[1:]  # removing self\n            _check_types(checkable_args, in_)\n            # running the function\n            res = function(*args)\n            # checking what goes out\n            if not type(res) in (tuple, list):\n                checkable_res = (res,)\n            else:\n                checkable_res = res\n            _check_types(checkable_res, out)\n\n            # the function and the type\n            # checking succeeded\n            return res\n        return __xmlrpc\n    return _xmlrpc\n```", "```py\nclass RPCView:\n    @xmlrpc((int, int))  # two int -> None\n    def meth1(self, int1, int2):\n        print('received %d and %d' % (int1, int2))\n\n    @xmlrpc((str,), (int,))  # string -> int\n    def meth2(self, phrase):\n        print('received %s' % phrase)\n        return 12\n```", "```py\n**>>> rpc_info**\n**{'meth2': ((<class 'str'>,), (<class 'int'>,)), 'meth1': ((<class 'int'>, <class 'int'>), (<class 'NoneType'>,))}**\n**>>> my = RPCView()**\n**>>> my.meth1(1, 2)**\n**received 1 and 2**\n**>>> my.meth2(2)**\n**Traceback (most recent call last):**\n **File \"<input>\", line 1, in <module>**\n **File \"<input>\", line 26, in __xmlrpc**\n **File \"<input>\", line 20, in _check_types**\n**TypeError: arg #0 should be <class 'str'>**\n\n```", "```py\nimport time\nimport hashlib\nimport pickle\n\ncache = {}\n\ndef is_obsolete(entry, duration):\n    return time.time() - entry['time']> duration\n\ndef compute_key(function, args, kw):\n    key = pickle.dumps((function.__name__, args, kw))\n    return hashlib.sha1(key).hexdigest()\n\ndef memoize(duration=10):\n    def _memoize(function):\n        def __memoize(*args, **kw):\n            key = compute_key(function, args, kw)\n\n            # do we have it already ?\n            if (key in cache and\n                not is_obsolete(cache[key], duration)):\n                print('we got a winner')\n                return cache[key]['value']\n\n            # computing\n            result = function(*args, **kw)\n            # storing the result\n            cache[key] = {\n                'value': result,\n                'time': time.time()\n            }\n            return result\n        return __memoize\n    return _memoize\n```", "```py\n**>>> @memoize()**\n**... def very_very_very_complex_stuff(a, b):**\n**...     # if your computer gets too hot on this calculation**\n**...     # consider stopping it**\n**...     return a + b**\n**...**\n**>>> very_very_very_complex_stuff(2, 2)**\n**4**\n**>>> very_very_very_complex_stuff(2, 2)**\n**we got a winner**\n**4**\n**>>> @memoize(1) # invalidates the cache after 1 second**\n**... def very_very_very_complex_stuff(a, b):**\n**...     return a + b**\n**...**\n**>>> very_very_very_complex_stuff(2, 2)**\n**4**\n**>>> very_very_very_complex_stuff(2, 2)**\n**we got a winner**\n**4**\n**>>> cache**\n**{'c2727f43c6e39b3694649ee0883234cf': {'value': 4, 'time':**\n**1199734132.7102251)}**\n**>>> time.sleep(2)**\n**>>> very_very_very_complex_stuff(2, 2)**\n**4**\n\n```", "```py\nclass User(object):\n    def __init__(self, roles):\n        self.roles = roles\n\nclass Unauthorized(Exception):\n    pass\n\ndef protect(role):\n    def _protect(function):\n        def __protect(*args, **kw):\n            user = globals().get('user')\n            if user is None or role not in user.roles:\n                raise Unauthorized(\"I won't tell you\")\n            return function(*args, **kw)\n        return __protect\n    return _protect\n```", "```py\n**>>> tarek = User(('admin', 'user'))**\n**>>> bill = User(('user',))**\n**>>> class MySecrets(object):**\n**...     @protect('admin')**\n**...     def waffle_recipe(self):**\n**...         print('use tons of butter!')**\n**...**\n**>>> these_are = MySecrets()**\n**>>> user = tarek**\n**>>> these_are.waffle_recipe()**\n**use tons of butter!**\n**>>> user = bill**\n**>>> these_are.waffle_recipe()**\n**Traceback (most recent call last):**\n**File \"<stdin>\", line 1, in <module>**\n**File \"<stdin>\", line 7, in wrap**\n**__main__.Unauthorized: I won't tell you**\n\n```", "```py\nfrom threading import RLock\nlock = RLock()\n\ndef synchronized(function):\n    def _synchronized(*args, **kw):\n        lock.acquire()\n        try:\n            return function(*args, **kw)\n        finally:\n            lock.release()\n    return _synchronized\n\n@synchronized\ndef thread_safe():  # make sure it locks the resource\n    pass\n```", "```py\n**>>> hosts = open('/etc/hosts')**\n**>>> try:**\n**...     for line in hosts:**\n**...         if line.startswith('#'):**\n**...             continue**\n**...         print(line.strip())**\n**... finally:**\n**...     hosts.close()**\n**...**\n**127.0.0.1       localhost**\n**255.255.255.255 broadcasthost**\n**::1             localhost**\n\n```", "```py\n**>>> with open('/etc/hosts') as hosts:**\n**...     for line in hosts:**\n**...         if line.startswith('#'):**\n**...             continue**\n**...         print(line.strip )**\n**...**\n**127.0.0.1       localhost**\n**255.255.255.255 broadcasthost**\n**::1             localhost**\n\n```", "```py\nwith context_manager:\n    # block of code\n    ...\n```", "```py\nwith context_manager as context:\n    # block of code\n    ...\n```", "```py\nwith A() as a, B() as b:\n    ...\n```", "```py\nwith A() as a:\n    with B() as b:\n        ...\n```", "```py\nclass ContextIllustration:\n    def __enter__(self):\n        print('entering context')\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        print('leaving context')\n\n        if exc_type is None:\n            print('with no error')\n        else:\n            print('with an error (%s)' % exc_value)\n```", "```py\n**>>> with ContextIllustration():**\n**...     print(\"inside\")**\n**...** \n**entering context**\n**inside**\n**leaving context**\n**with no error**\n\n```", "```py\n**>>> with ContextIllustration():**\n**...     raise RuntimeError(\"raised within 'with'\")**\n**...** \n**entering context**\n**leaving context**\n**with an error (raised within 'with')**\n**Traceback (most recent call last):**\n **File \"<input>\", line 2, in <module>**\n**RuntimeError: raised within 'with'**\n\n```", "```py\nfrom contextlib import contextmanager\n\n@contextmanager\ndef context_illustration():\n    print('entering context')\n\n    try:\n        yield\n    except Exception as e:\n        print('leaving context')\n        print('with an error (%s)' % e)\n        # exception needs to be reraised\n        raise\n    else:\n        print('leaving context')\n        print('with no error')\n```", "```py\n**>>> for number in range(1):**\n**...     break**\n**... else:**\n**...     print(\"no break\")**\n**...**\n**>>>**\n**>>> for number in range(1):**\n**...     pass**\n**... else:**\n**...     print(\"break\")**\n**...**\n**break**\n\n```", "```py\n**>>> def f(ham: str, eggs: str = 'eggs') -> str:**\n**...     pass**\n**...** \n**>>> print(f.__annotations__)**\n**{'return': <class 'str'>, 'eggs': <class 'str'>, 'ham': <class 'str'>}**\n\n```", "```py\n**>>> def square(number: 0<=3 and 1=0) -> (\\**\n**...     +9000): return number**2**\n**>>> square(10)**\n**100**\n\n```"]