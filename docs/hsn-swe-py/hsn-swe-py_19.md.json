["```py\ndef factors_of(number:(int)) -> (list):\n    \"\"\"\nReturns a list of factors of the provided number: \nAll integer-values (x) between 2 and number/2 where number % x == 0\n\"\"\"\n    if type(number) != int:\n        raise TypeError(\n            'factors_of expects a positive integer value, but was passed '\n            '\"%s\" (%s)' % (number, type(number).__name__)\n        )\n    if number < 1:\n        raise ValueError(\n            'factors_of expects a positive integer value, but was passed '\n            '\"%s\" (%s)' % (number, type(number).__name__)\n        )\n    return [\n        x for x in range(2, int(number/2) + 1)\n        if number % x == 0\n    ]\n```", "```py\n#!/usr/bin/env python\n\"\"\"serial_baseline.py\n\nGetting data that we can use to estimate how long a factor_of call will \ntake for some sample \"large\" numbers.\n\"\"\"\n\nprint(\n    '# Execution of %s, using all of one CPU\\'s capacity' % __file__\n)\nprint('='*80)\nprint()\n\nimport time\nfrom factors import factors_of\n\n# - The number we'll start with\nrange_start = 10000000\n# - The number of calls we'll make to the function\nrange_length = 1000\n# - The number that we'll end with - range *stops* at the number \n#   specified without including it in the value-set\nrange_end = range_start + range_length + 1\n# - Keep track of the time that the process starts\nstart_time = time.time()\n# - Execute the function-call the requisite number of times\nfor number in range(range_start, range_end):\n    factors_of(number)\n# - Determine the total length of time the process took to execute\nrun_time = time.time() - start_time\n# - Show the relevant data\nprint(\n    '%d iterations executed in %0.6f seconds' % \n    (range_length, run_time)\n)\nprint(\n    'Average time per iteration was %0.6f seconds' %\n```", "```py\n    (run_time/range_length)\n)\n```", "```py\nTEST_NUMBERS = [\n    11,         # Should process very quickly\n    16,         # Also quick, and has factors\n    101,        # Slower, but still quick\n    102,        # Slower, but still quick\n    1001,       # Slower still, but still fairly quick\n    1000001,    # Visibly longer processing time\n    1000000001, # Quite a while\n]\n```", "```py\n#!/usr/bin/env python\n\"\"\"multiprocessing_baseline.py\n\nGetting data that we can use to estimate how long a factor_of call will \ntake for some sample \"large\" numbers.\n\"\"\"\n\nprint(\n    '# Execution of %s, using all available CPU capacity (%d)' % \n    (__file__, multiprocessing.cpu_count())\n)\nprint('='*80)\n\nimport multiprocessing\nimport time\n```", "```py\n# - Keep track of the processes\nprocesses = []\n# - Create and start all the processes needed\nfor number in range(range_start, range_end):\n    process = multiprocessing.Process(\n        name='factors_of-%d' % number,\n        target=factors_of,\n        args=(number,),\n    )\n    processes.append(process)\n    process.start()\n```", "```py\n# - Iterate over the entire process-set, and use join() to connect \n#   and wait for them\nfor process in processes:\n    process.join()\n```", "```py\n#!/usr/bin/env python\n\"\"\"multiprocessing_tests.py\nAlso prints several bits of information as it runs, but those \ncan be removed once their purpose has been served\n\"\"\"\n\nimport multiprocessing\nimport random\n# - If we want to simulate longer run-times later for some reason, \n#   this will need to be uncommented\n# import time\n\nfrom datetime import datetime\n```", "```py\n# - Use the small, fixed set of numbers to test with:\nfrom factors import TEST_NUMBERS\n# - Randomize the sequence of numbers\nTEST_NUMBERS.sort(key=lambda i:random.randrange(1,1000000))\n```", "```py\nqueue = multiprocessing.Queue()\n```", "```py\ndef factors_of(number:(int)) -> (list):\n    \"\"\"\nReturns a list of factors of the provided number: \nAll integer-values (x) between 2 and number/2 where number % x == 0\n\"\"\"\n    print(\n        '==> [%s] factors_of(%d) called' % \n        (datetime.now().strftime('%H:%M:%S.%f'), number)\n    )\n```", "```py\n    if type(number) != int:\n        raise TypeError(\n            'factors_of expects a positive integer value, but was passed '\n            '\"%s\" (%s)' % (number, type(number).__name__)\n        )\n    if number < 1:\n        raise ValueError(\n            'factors_of expects a positive integer value, but was passed '\n            '\"%s\" (%s)' % (number, type(number).__name__)\n        )\n# - If we want to simulate longer run-times later for some reason, \n#   this will need to be uncommented\n#    time.sleep(10)\n```", "```py\n    factors = [\n            x for x in range(2, int(number/2) + 1)\n            if number % x == 0\n        ]\n    print(\n        '<== [%s] factors_of(%d) complete' % \n        (datetime.now().strftime('%H:%M:%S.%f'), number)\n    )\n```", "```py\n    queue.put((number, factors))\n```", "```py\nprint(\n    '# Execution of %s, using all available CPU capacity (%d)' % \n    (__file__, multiprocessing.cpu_count())\n)\nprint('='*80)\nprint()\n```", "```py\nstart_time = time.time()\n```", "```py\nprocesses = []\nfor number in TEST_NUMBERS:\n    # - Thread has been created, but not started yet\n    process = multiprocessing.Process(\n        name='factors_of-%d' % number,\n        target=factors_of,\n        args=(number,),\n    )\n    # - Keeping track of the individual threads\n    processes.append(process)\n    # - Starting the current thread\n    process.start()\n```", "```py\nfor process in processes:\n    print(\n        '*** [%s] Joining %s process' % \n        (datetime.now().strftime('%H:%M:%S.%f'), process.name)\n    )\n    process.join()\n```", "```py\n# - Determine the total length of time the process took to execute\nrun_time = time.time() - start_time\n# - Show the relevant data\nprint('='*80)\nprint(\n    '%d factor_of iterations executed in %0.6f seconds' % \n    (len(TEST_NUMBERS), run_time)\n)\nprint(\n    'Average time per iteration was %0.6f seconds' % \n    (run_time/len(TEST_NUMBERS))\n)\n```", "```py\nprint('='*80)\nprint('results:')\nwhile not queue.empty():\n    print(queue.get())\n```", "```py\nWORKER_OPERATIONS = namedtuple(\n    'WORKER_OPERATIONS', ['factors_of',]\n)\n(\n    factors_of='factors_of',\n)\n```", "```py\n    def _set_operation(self, value:str) -> None:\n# - Other operations would need to be added \n        if not value in _OPERATIONS:\n            raise ValueError(\n                '%s.operation expects a string value (one of '\n                '\"%s\"), but was passed \"%s\" (%s)' % \n                (\n                    self.__class__.__name__, \n                    '\", \"'.join(_OPERATIONS._fields), \n                    value, type(value).__name__\n                )\n            )\n        self._operation = value\n```", "```py\nMESSAGE_ORIGINS = namedtuple(\n    'MESSAGE_ORIGINS', ['orchestrator', 'worker', 'dispatcher']\n)\n(\n    orchestrator='orchestrator',\n    worker='worker',\n    dispatcher='dispatcher',\n)\n```", "```py\n    def _handle_message(self, message:(DaemonMessage,)) -> None:\n        self.info(\n            '%s._handle_message called:' % self.__class__.__name__\n        )\n        target = message.data.get('target')\n        self.debug('+- target ....... (%s) %s' % (\n            type(target).__name__, target)\n        )\n        self.debug('+- operation .... (%s) %s' % (\n            type(message.operation).__name__, message.operation)\n        )\n        if message.operation == WORKER_OPERATIONS.factors_of:\n            self.factors_of(message)\n        else:\n            raise RuntimeError(\n                '%s error: \"%s\" (%s) is not a recognized '\n                'operation' % \n                (\n                    self.__class__.__name__, message.operation, \n                    type(message.operation).__name__\n                )\n            )\n```", "```py\n    def factors_of(self, number):\n\n        # ... code that generates the results\n\n        # - Assuming that the configuration for RabbitMQSender \n        #   is handled elsewhere, we can just get a new instance\n        sender = RabbitMQSender()\n        outbound_message = DaemonMessage(\n            operation=dispatch_results,\n            origin=MESSAGE_ORIGINS.worker,\n            data={\n                'number':number,\n                'factors':factors,\n            },\n            signing_key=self.signing_key\n        )\n        sender.send_message(outbound_message, self.dispatcher_queue)\n```", "```py\ndef preflight(self):\n    \"\"\"\nSends a message to the orchestrator to indicate that the instance is \nno longer available\n\"\"\"\n        # - Assuming that the configuration for RabbitMQSender \n        #   is handled elsewhere, we can just get a new instance\n        sender = RabbitMQSender()\n        outbound_message = DaemonMessage(\n            operation=ORCHESTRATOR_OPERATIONS.register_worker,\n            origin=MESSAGE_ORIGINS.worker,\n            data={\n                'worker_id':self.worker_id,\n                'max_capacity':1,\n            },\n            signing_key=self.signing_key\n        )\n        sender.send_message(outbound_message, self.orchestrator_queue)\n\ndef cleanup(self):\n    \"\"\"\nSends a message to the orchestrator to indicate that the instance is \nno longer available\n\"\"\"\n        # - Assuming that the configuration for RabbitMQSender \n        #   is handled elsewhere, we can just get a new instance\n        sender = RabbitMQSender()\n        outbound_message = DaemonMessage(\n            operation=DISPATCH_OPERATIONS.unregister_worker,\n            origin=MESSAGE_ORIGINS.worker,\n            data={\n                'worker_id':self.worker_id,\n            },\n            signing_key=self.signing_key\n        )\n        sender.send_message(outbound_message, self.orchestrator_queue)\n```", "```py\nORCHESTRATOR_OPERATIONS = namedtuple(\n    'ORCHESTRATOR_OPERATIONS', [\n        'register_worker', 'unregister_worker', 'worker_pulse'\n    ]\n)\n(\n    register_worker='register_worker',\n    unregister_worker='unregister_worker',\n    worker_pulse='worker_pulse',\n)\n```", "```py\n    def _handle_message(self, message:(DaemonMessage,)) -> None:\n        self.info(\n            '%s._handle_message called:' % self.__class__.__name__\n        )\n\n        # ...\n\n        if message.operation == ORCHESTRATOR_OPERATIONS.register_worker:\n            self.register_worker(message)\n        elif message.operation == ORCHESTRATOR_OPERATIONS.unregister_worker:\n            self.unregister_worker(message)\n        elif message.operation == ORCHESTRATOR_OPERATIONS.worker_pulse:\n            self.worker_pulse(message)\n        else:\n            raise RuntimeError(\n                '%s error: \"%s\" (%s) is not a recognized '\n                'operation' % \n                (\n                    self.__class__.__name__, message.operation, \n                    type(message.operation).__name__\n                )\n            )\n```", "```py\nDISPATCH_OPERATIONS = namedtuple(\n    'DISPATCH_OPERATIONS', ['dispatch_results',]\n)\n(\n    dispatch_results='dispatch_results',\n)\n```", "```py\n    def _handle_message(self, message:(DaemonMessage,)) -> None:\n        self.info(\n            '%s._handle_message called:' % self.__class__.__name__\n        )\n\n        # ...\n\n        if message.operation == DISPATCH_OPERATIONS.dispatch_results:\n            self.dispatch_results(message)\n        else:\n            raise RuntimeError(\n                '%s error: \"%s\" (%s) is not a recognized '\n                'operation' % \n                (\n                    self.__class__.__name__, message.operation, \n                    type(message.operation).__name__\n                )\n            )\n```", "```py\n#!/usr/bin/env python\n\"\"\"factors_stdin.py\n\nA command-line-ready script that allows factors_of to be called with \n\n> {incoming list of numbers} | python factors_stdin.py\n\nwhich executes factors_of against the provided numbers and prints the \nresult FOR EACH NUMBER in the format\n\nnumber:[factors-of-number]\n\"\"\"\n```", "```py\nfrom sys import stdin\n```", "```py\nfrom factors import factors_of\n```", "```py\nif __name__ == '__main__':\n    # - Create a list of stdin lines - multi-line input is \n    #   common enough that it needs to be handled\n    lines = [line.strip() for line in stdin]\n    # - We need the numbers as individual values, though, so \n    #   build a list of them that we'll actually execute against\n    numbers = []\n    for line in lines:\n        numbers += [n for n in line.split(' ') if n]\n```", "```py\n    for number in numbers:\n        try:\n            number = int(number)\n        except Exception as error:\n            pass\n        else:\n            # - We've got the number, so execute the function and \n            #   print the results\n            print('%d:%s' % (number, factors_of(number)))\n```", "```py\n#!/usr/bin/env python\n\"\"\"factors_cli.py\n\nA command-line-ready script that allows factors_of to be called with \n\n> python factors_cli.py number [number [number]] ...\n\nwhich executes factors_of against the provided numbers and \nprints the results for each in the format\n\nnumber:[factors-of-number]\n\"\"\"\n\nfrom factors import factors_of\nfrom sys import argv\n```", "```py\nif __name__ == '__main__':\n    # - Get the numbers from the arguments\n    numbers = argv[1:]\n    for number in numbers:\n        try:\n            number = int(number)\n        except Exception as error:\n            # - Errors should probably be logged in some fashion, \n            #   but the specifics may well vary across different\n            #   systems, so for now we'll just pass, skipping anything \n            #   that can't be handled.\n            pass\n        else:\n            # - We've got the number, so execute the function and \n            #   print the results\n            print('%d:%s' % (number, factors_of(number)))\n```"]