["```py\n# .gitignore for hms_sys project\n# Geany project-files\n*.geany\n```", "```py\n# hms_sys\n\nThe system-level repository for the hms_sys project, from \"Hands On \nSoftware Engineering with Python,\" published by Packt.\n\n## Geany Project Set-up\n\nGeany project-files (`*.geany`) are in the `.gitignore` for the entire \nrepository, since they have filesystem-specific paths that would break \nas they were moved from one developer's local environment to another. \nInstructions for (re-)creating those projects are provided for each.\n\n### HMS System (Overall) -- `hms_sys.geany`\n\nThis is an over-arching project that encompasses *all* of the component \nprojects. It can be re-created by launching Geany, then using \nProject \u2192 New and providing:\n\n * *Name:* HMS System (Overall)\n * *Filename:* `[path-to-git-repo]/hms_sys/hms_sys.geany`\n * *Base path:* `[path-to-git-repo]/hms_sys`\n```", "```py\n# Makefile for the HMS Core (hms-core) project\n\nmain: test setup\n        # Doesn't (yet) do anything other than running the test and \n        # setup targets\n\nsetup:\n        # Calls the main setup.py to build a source-distribution\n        # python setup.py sdist\n\ntest:\n        # Executes the unit-tests for the package, allowing the build-\n        # process to die and stop the build if a test fails\n```", "```py\n#!/usr/bin/env python\n\nfrom setuptools import setup\n\n# The actual setup function call:\nsetup(\n    name='HMS-Core',\n    version='0.1.dev0',\n    author='Brian D. Allbee',\n    description='',\n    package_dir={\n        '':'src',\n        # ...\n    },\n    # Can also be automatically generated using \n    #     setuptools.find_packages...\n    packages=[\n        'hms_core',\n        # ...\n    ],\n    package_data={\n#        'hms_core':[\n#            'filename.ext',\n#            # ...\n#        ]\n    },\n    entry_points={\n#        'console_scripts':[\n#            'executable_name = namespace.path:function',\n#            # ...\n#        ],\n    },\n)\n```", "```py\n# Makefile for the HMS Core (hms-core) project\nTMPDIR=/tmp/build/hms_core_build\n\nlocal: setup\n # Doesn't (yet) do anything other than running the test and \n # setup targets\n\nsetup:\n # Calls the main setup.py to build a source-distribution\n ~/py_envs/hms/core/bin/python setup.py sdist\n\nunit_test:\n # Executes the unit-tests for the package, allowing the build-\n # process to die and stop the build if a test fails\n ~/py_envs/hms/core/bin/python setup.py test\n```", "```py\nbuild_dir:\n # Creates a temporary build-directory, copies the project-files \n # to it.\n # Creating \"$(TMPDIR)\"\n mkdir -p $(TMPDIR)\n # Copying project-files to $(TMPDIR)\n cp -R bin $(TMPDIR)\n cp -Ret cetera$(TMPDIR)\n cp -R src $(TMPDIR)\n cp -R var $(TMPDIR)\n cp setup.py $(TMPDIR)\n```", "```py\ndev_prep:\n # Renames any dev-specific files so that they will be the \"real\" \n # files included in the build.\n # At this point, there are none, so we'll just exit\n\ndev: unit_test build_dir dev_prep\n # A make-target that generates a build intended to be deployed \n # to a shared development environment.\n cd $(TMPDIR);~/py_envs/hms/core/bin/python setup.py sdist\n```", "```py\nclass ExampleParent:\n\n    def __init__(self):\n        pass\n\n    def public_method(self, arg, *args, **kwargs):\n        print('%s.public_method called:' % self.__class__.__name__)\n        print('+- arg ...... %s' % arg)\n        print('+- args ..... %s' % str(args))\n        print('+- kwargs ... %s' % kwargs)\n\n    def _protected_method(self, arg, *args, **kwargs):\n        print('%s._protected_method called:' % self.__class__.__name__)\n        print('+- arg ...... %s' % arg)\n        print('+- args ..... %s' % str(args))\n        print('+- kwargs ... %s' % kwargs)\n\n    def __private_method(self, arg, *args, **kwargs):\n        print('%s.__private_method called:' % self.__class__.__name__)\n        print('+- arg ...... %s' % arg)\n        print('+- args ..... %s' % str(args))\n        print('+- kwargs ... %s' % kwargs)\n\n    def show(self):\n        self.public_method('example public', 1, 2, 3, key='value')\n        self._protected_method('example \"protected\"', 1, 2, 3, key='value')\n        self.__private_method('example \"private\"', 1, 2, 3, key='value')\n```", "```py\nclass ExampleChild(ExampleParent):\n    pass\n```", "```py\nimport abc\n\nclass Showable(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def show(self):\n        pass\n\nclass Parent(Showable):\n\n    _lead_len = 33\n\n    def __init__(self, arg, *args, **kwargs):\n        self.arg = arg\n        self.args = args\n        self.kwargs = kwargs\n\n    def public(self):\n        return (\n            ('%s.arg [public] ' % self.__class__.__name__).ljust(\n                self.__class__._lead_len, '.') + ' %s' % self.arg\n            )\n\n    def _protected(self):\n        return (\n            ('%s.arg [protected] ' % self.__class__.__name__).ljust(\n                self.__class__._lead_len, '.') + ' %s' % self.arg\n            )\n\n    def __private(self):\n        return (\n            ('%s.arg [private] ' % self.__class__.__name__).ljust(\n                self.__class__._lead_len, '.') + ' %s' % self.arg\n            )\n\n    def show(self):\n        print(self.public())\n        print(self._protected())\n        print(self.__private())\n\nclass Child(Parent):\n    pass\n\nclass ChildOverride(Parent):\n\n    def public(self):\n        return (\n            ('%s.arg [PUBLIC] ' % self.__class__.__name__).ljust(\n                self.__class__._lead_len, '.') + ' %s' % self.arg\n            )\n\n    def _protected(self):\n        return (\n            ('%s.arg [PROTECTED] ' % self.__class__.__name__).ljust(\n                self.__class__._lead_len, '.') + ' %s' % self.arg\n            )\n```", "```py\n    def __private(self):\n        return (\n            ('%s.arg [PRIVATE] ' % self.__class__.__name__).ljust(\n                self.__class__._lead_len, '.') + ' %s' % self.arg\n            )\n```", "```py\n#!/usr/bin/env python\n\nimport unittest\n\nclass testShowable(unittest.TestCase):\n    pass\n\nclass testParent(unittest.TestCase):\n    pass\n\nclass testChild(unittest.TestCase):\n    pass\n\nclass testChildOverride(unittest.TestCase):\n    pass\n\nunittest.main()\n```", "```py\nclass testParent(unittest.TestCase):\n    def testpublic(self):\n        print('### Testing Parent.public')\n    def test_protected(self):\n        print('### Testing Parent._protected')\n    def test__private(self):\n        print('### Testing Parent.__private')\n```", "```py\nclass testParent(unittest.TestCase):\n    def testpublic(self):\n        pass\n    def test_protected(self):\n        pass\n    def test__private(self):\n        pass\n```", "```py\n#!/usr/bin/env python\n\nimport inspect\n\nimport me as target_module\n\ntarget_classes = set([\n    member[0] for member in \n    inspect.getmembers(target_module, inspect.isclass)\n])\n# target_classes = {\n#   'Child', 'ChildOverride', 'Parent', 'Showable'\n# } at this point\n```", "```py\nexpected_cases = set([\n    'test%s' % class_name \n    for class_name in target_classes\n    ]\n)\n# expected_cases = {\n#   'testChild', 'testShowable', 'testChildOverride', \n#   'testParent'\n# } at this point\n```", "```py\nimport unittest\n\nimport test_me as test_module\n\ntest_cases = set([\n    member[0] for member in \n    inspect.getmembers(test_module, inspect.isclass)\n    if issubclass(member[1], unittest.TestCase)\n])\n# test_cases, before any TestCase classes have been defined, \n# is an empty set\n```", "```py\nmissing_tests = expected_cases.difference(test_cases)\n# missing_tests = {\n#   'testShowable', 'testChild', 'testParent', \n#   'testChildOverride'\n# }\n```", "```py\nif missing_tests:\n    print(\n        'Test-policies require test-case classes to be '\n        'created for each class in the code-base. The '\n        'following have not been created:\\n * %s' % \n        '\\n * '.join(missing_tests)\n    )\n```", "```py\n#!/usr/bin/env python\n\nimport unittest\n\nclass testChild(unittest.TestCase):\n    pass\n\nclass testChildOverride(unittest.TestCase):\n    pass\n\nclass testParent(unittest.TestCase):\n    pass\n\nclass testShowable(unittest.TestCase):\n    pass\n\nif __name__ == '__main__':\n    unittest.main()\n```", "```py\ntarget_class = target_module.Parent\n\ntarget_properties = set([\n    member[0] for member in \n    inspect.getmembers(target_class, inspect.isdatadescriptor)\n])\n# target_properties = {'__weakref__'}\n```", "```py\ntarget_functions = set([\n    member[0] for member in \n    inspect.getmembers(target_class, inspect.isfunction)\n])\ntarget_methods = set([\n    member[0] for member in \n    inspect.getmembers(target_class, inspect.ismethod)\n])\ntarget_methods = target_methods.union(target_functions)\n# target_methods = {\n#   '_Parent__private', 'public', 'show', \n#   '_protected', '__init__'\n# }\n```", "```py\ntarget_properties = set([\n    member[0] for member in \n    inspect.getmembers(target_class, inspect.isdatadescriptor)\n    if not member[0].startswith('__')\n])\n# target_properties = {'prop'}\n```", "```py\nproperty_tests = set()\nsourceMRO = list(target_class.__mro__)\nsourceMRO.reverse()\n# Get all the item's properties\nproperties = [\n    member for member in inspect.getmembers(\n        target_class, inspect.isdatadescriptor)\n    if member[0][0:2] != '__'\n]\n# sourceMRO = [\n#   <class 'object'>, <class 'me.Showable'>, \n#   <class 'me.Parent'>\n# ]\n```", "```py\npropSources = {}\npropImplementations = {}\nfor name, value in properties:\n    propSources[name] = None\n    propImplementations[name] = None\n# Populate the dictionaries based on the names found\nfor memberName in propSources:\n    implementation = target_class.__dict__.get(memberName)\n    if implementation and propImplementations[memberName] != implementation:\n        propImplementations[memberName] = implementation\n        propSources[memberName] = target_class\n# propImplementations = {\n#   \"prop\": <property object at 0x7fa2f0edeb38>\n# }\n# propSources = {\n#   \"prop\": <class 'me.Parent'>\n# }\n# If the target_class is changed to target_module.Child:\n# propImplementations = {\n#   \"prop\": None    # Not set because prop originates in Parent\n# }\n# propSources = {\n#   \"prop\": None    # Also not set for the same reason\n# }\n```", "```py\nproperty_tests = set(\n    [\n        'test%s' % key for key in propSources \n        if propSources[key] == target_class\n    ]\n)\n# property_tests = {'testprop'}\n# If the target_class is changed to target_module.Child:\n# property_tests = set()\n```", "```py\nmethod_tests = set()\nsourceMRO = list(target_class.__mro__)\nsourceMRO.reverse()\n# Get all the item's methods\nmethods = [\n    member for member in inspect.getmembers(\n        target_class, inspect.isfunction)\n] + [\n    member for member in inspect.getmembers(\n        target_class, inspect.ismethod)\n]\n```", "```py\nmethSources = {}\nmethImplementations = {}\nfor name, value in methods:\n    if name.startswith('_%s__' % target_class.__name__):\n        # Locally-defined private method - Don't test it\n        continue\n    if hasattr(value, '__isabstractmethod__') and value.__isabstractmethod__:\n        # Locally-defined abstract method - Don't test it\n        continue\n    methSources[name] = None\n    methImplementations[name] = None\n```", "```py\nmethod_tests = set(\n    [\n        'test%s' % key for key in methSources \n        if methSources[key] == target_class\n    ]\n)\n# method_tests = {\n#   'testpublic', 'test__init__', 'test_protected', \n#   'testshow'\n# }\n# If the target_class is changed to target_module.Child:\n# method_tests = set()\n# If the target_class is changed to target_module.Showable:\n# method_tests = set()\n```", "```py\ndef testCodeCoverage(self):\n    if not self.__class__._testModule:\n        return\n    self.assertEqual([], self._missingTestCases, \n        'unit testing policies require test-cases for all classes '\n        'and functions in the %s module, but the following have not '\n        'been defined: (%s)' % (\n            self.__class__._testModule.__name__, \n            ', '.join(self._missingTestCases)\n        )\n    )\n```", "```py\nclass ModuleCoverageTest(unittest.TestCase):\n    \"\"\"\nA reusable unit-test that checks to make sure that all classes in the \nmodule being tested have corresponding test-case classes in the \nunit-test module where the derived class is defined.\n\"\"\"\n@classmethod\ndef setUpClass(cls):\n    if not cls._testModule:\n        cls._missingTestCases = []\n        return\n```", "```py\ncls._moduleClasses = inspect.getmembers(\n     cls._testModule, inspect.isclass)\ncls._moduleFunctions = inspect.getmembers(\n     cls._testModule, inspect.isfunction)\n```", "```py\ncls._testModuleName = cls._testModule.__name__\n```", "```py\ncls._classTests = dict(\n   [\n       ('test%s' % m[0], m[1]) \n       for m in cls._moduleClasses\n       if m[1].__module__ == cls._testModuleName\n   ]\n)\ncls._functionTests = dict(\n   [\n       ('test%s' % m[0], m[1]) \n       for m in cls._moduleFunctions\n       if m[1].__module__ == cls._testModuleName\n   ]\n)\n```", "```py\ncls._requiredTestCases = sorted(\n   list(cls._classTests.keys()) + list(cls._functionTests.keys())\n)\n```", "```py\ncls._actualTestCases = dict(\n    [\n      item for item in \n      inspect.getmembers(inspect.getmodule(cls), \n      inspect.isclass) \n    if item[1].__name__[0:4] == 'test'\n       and issubclass(item[1], unittest.TestCase)\n    ]\n)\n```", "```py\ncls._missingTestCases = sorted(\n   set(cls._requiredTestCases).difference(\n       set(cls._actualTestCases.keys())))\n```", "```py\nfrom unit_testing import ModuleCoverageTest\n\nclass testmeCodeCoverage(ModuleCoverageTest):\n    _testModule = me\n\nif __name__ == '__main__':\n    unittest.main()\n```", "```py\nclass testmeCodeCoverage(ModuleCoverageTest):\n    _testModule = me\n\nclass testChild(unittest.TestCase):\n    pass\n\nclass testChildOverride(unittest.TestCase):\n    pass\n\nclass testParent(unittest.TestCase):\n    pass\n\nclass testShowable(unittest.TestCase):\n    pass\n\nif __name__ == '__main__':\n    unittest.main()\n```", "```py\ncls._propertyTestsByClass = {}\nfor testClass in cls._classTests:\n    cls._propertyTestsByClass[testClass] = set()\n    sourceClass = cls._classTests[testClass]\n    sourceMRO = list(sourceClass.__mro__)\n    sourceMRO.reverse()\n    # Get all the item's properties\n    properties = [\n         member for member in inspect.getmembers(\n               sourceClass, inspect.isdatadescriptor)\n            if member[0][0:2] != '__'\n         ]\n    # Create and populate data-structures that keep track of where \n    # property-members originate from, and what their implementation \n    # looks like. Initially populated with None values:\n    propSources = {}\n    propImplementations = {}\n    for name, value in properties:\n        propSources[name] = None\n        propImplementations[name] = None\n     for memberName in propSources:\n        implementation = sourceClass.__dict__.get(memberName)\n        if implementation \\\n           and propImplementations[memberName] != implementation:\n               propImplementations[memberName] = implementation\n               propSources[memberName] = sourceClass\n         cls._propertyTestsByClass[testClass] = set(\n            [\n               'test%s' % key for key in propSources \n               if propSources[key] == sourceClass\n            ]\n)\n```", "```py\ncls._methodTestsByClass = {}\nfor testClass in cls._classTests:\n    cls._methodTestsByClass[testClass] = set()\n    sourceClass = cls._classTests[testClass]\n    sourceMRO = list(sourceClass.__mro__)\n    sourceMRO.reverse()\n# Get all the item's methods\nmethods = [\n   member for member in inspect.getmembers(\n          sourceClass, inspect.ismethod)\n   ] + [\n   member for member in inspect.getmembers(\n          sourceClass, inspect.isfunction)\n   ]\n# Create and populate data-structures that keep track of where \n# method-members originate from, and what their implementation \n# looks like. Initially populated with None values:\nmethSources = {}\nmethImplementations = {}\nfor name, value in methods:\n    if name.startswith('_%s__' % sourceClass.__name__):\n       # Locally-defined private method - Don't test it\n         continue\n    if hasattr(value, '__isabstractmethod__') \\\n       and value.__isabstractmethod__:\n       # Locally-defined abstract method - Don't test it\n         continue                methSources[name] = None\n       methImplementations[name] = None\n  for memberName in methSources:\n       implementation = sourceClass.__dict__.get(memberName)\n          if implementation \\\n             and methImplementations[memberName] != implementation:\n             methImplementations[memberName] = implementation\n             methSources[memberName] = sourceClass\n   cls._methodTestsByClass[testClass] = set(\n        [\n            'test%s' % key for key in methSources \n            if methSources[key] == sourceClass\n        ]\n)\n```", "```py\n{\n    \"testChild\": set(),\n    \"testChildOverride\": set(),\n    \"testParent\": {\"testprop\"},\n    \"testShowable\": set()\n}\n```", "```py\n{\n    \"testChild\": set(),\n    \"testChildOverride\": {\n        \"test_protected\", \"testpublic\"\n    },\n    \"testParent\": {\n        \"test__init__\", \"test_protected\", \n        \"testpublic\", \"testshow\"\n    },\n    \"testShowable\": set()\n}\n```", "```py\n@classmethod\ndef AddMethodTesting(cls, target):\n    if cls.__name__ == 'ModuleCoverageTest':\n        raise RuntimeError('ModuleCoverageTest should be extended '\n            'into a local test-case class, not used as one directly.')\n    if not cls._testModule:\n        raise AttributeError('%s does not have a _testModule defined '\n          'as a class attribute. Check that the decorator-method is '\n          'being called from the extended local test-case class, not '\n          'from ModuleCoverageTest itself.' % (cls.__name__))\n```", "```py\ntry:\n   if cls._methodTestsByClass:\n      populate = False\n    else:\n        populate = True\nexcept AttributeError:\n    populate = True\nif populate:\n    cls.setUpClass()\n```", "```py\ndef testMethodCoverage(self):\n    requiredTestMethods = cls._methodTestsByClass[target.__name__]\n    activeTestMethods = set(\n      [\n          m[0] for m in \n          inspect.getmembers(target, inspect.isfunction)\n          if m[0][0:4] == 'test'\n      ]\n    )\n    missingMethods = sorted(\n        requiredTestMethods.difference(activeTestMethods)\n    )\n    self.assertEquals([], missingMethods, \n        'unit testing policy requires test-methods to be created for '\n        'all public and protected methods, but %s is missing the '\n        'following test-methods: %s' % (\n        target.__name__, missingMethods\n    )\n)\n```", "```py\ntarget.testMethodCoverage = testMethodCoverage\nreturn target\n```", "```py\nclass testmeCodeCoverage(ModuleCoverageTest):\n    _testModule = me\n\n@testmeCodeCoverage.AddPropertyTesting\n@testmeCodeCoverage.AddMethodTesting\nclass testChild(unittest.TestCase):\n    pass\n\n@testmeCodeCoverage.AddPropertyTesting\n@testmeCodeCoverage.AddMethodTesting\nclass testChildOverride(unittest.TestCase):\n    pass\n\n@testmeCodeCoverage.AddPropertyTesting\n@testmeCodeCoverage.AddMethodTesting\nclass testParent(unittest.TestCase):\n    pass\n\n@testmeCodeCoverage.AddPropertyTesting\n@testmeCodeCoverage.AddMethodTesting\nclass testShowable(unittest.TestCase):\n    pass\n```", "```py\n#!/usr/bin/env python\n\n# Python unit-test-module template. Copy the template to a new\n# unit-test-module location, and start replacing names as needed:\n#\n# PackagePath  ==> The path/namespace of the parent of the module/package\n#                  being tested in this file.\n# ModuleName   ==> The name of the module being tested\n#\n# Then remove this comment-block\n\n\"\"\"\nDefines unit-tests for the module at PackagePath.ModuleName.\n\"\"\"\n\n#######################################\n# Any needed from __future__ imports  #\n# Create an \"__all__\" list to support #\n#   \"from module import member\" use   #\n#######################################\n```", "```py\n__all__ = [\n    # Test-case classes\n    # Child test-modules\n]\n```", "```py\n#######################################\n# Standard library imports needed     #\n#######################################\n\nimport os\nimport sys\nimport unittest\n\n#######################################\n# Third-party imports needed          #\n#######################################\n\n#######################################\n# Local imports needed                #\n#######################################\n\nfrom unit_testing import *\n\n#######################################\n# Initialization needed before member #\n#   definition can take place         #\n#######################################\n```", "```py\n#######################################\n# Module-level Constants              #\n#######################################\n\nLocalSuite = unittest.TestSuite()\n\n#######################################\n# Import the module being tested      #\n#######################################\n\nimport PackagePath.ModuleName as ModuleName\n```", "```py\n#######################################\n# Code-coverage test-case and         #\n# decorator-methods                   #\n#######################################\n\nclass testModuleNameCodeCoverage(ModuleCoverageTest):\n    _testModule = ModuleName\n\nLocalSuite.addTests(\n    unittest.TestLoader().loadTestsFromTestCase(\n        testModuleNameCodeCoverage\n   )\n)\n```", "```py\n#######################################\n# Test-cases in the module            #\n#######################################\n\n#######################################\n# Child-module test-cases to execute  #\n#######################################\n```", "```py\n# import child_module\n# LocalSuite.addTests(child_module.LocalSuite._tests)\n```", "```py\n#######################################\n# Imports to resolve circular         #\n# dependencies. Avoid if possible.    #\n#######################################\n\n#######################################\n# Initialization that needs to        #\n# happen after member definition.     #\n#######################################\n\n#######################################\n# Code to execute if file is called   #\n# or run directly.                    #\n#######################################\n```", "```py\nif __name__ == '__main__':\n    import time\n    results = unittest.TestResult()\n    testStartTime = time.time()\n    LocalSuite.run(results)\n    results.runTime = time.time() - testStartTime\n    PrintTestResults(results)\n    if not results.errors and not results.failures:\n        SaveTestReport(results, 'PackagePath.ModuleName',\n            'PackagePath.ModuleName.test-results')\n```", "```py\n# import child_module\n# LocalSuite.addTests(child_module.LocalSuite._tests)\n```", "```py\n#!/usr/bin/env python\n\n# Adding our unit testing standards\nimport sys\nsys.path.append('../standards')\n\nfrom setuptools import setup\n\n# The actual setup function call:\nsetup(\n    name='HMS-Core',\n    version='0.1.dev0',\n    author='Brian D. Allbee',\n    description='',\n    package_dir={\n        '':'src',\n        # ...\n    },\n    # Can also be automatically generated using \n    #     setuptools.find_packages...\n    packages=[\n        'hms_core',\n        # ...\n    ],\n    package_data={\n#        'hms_core':[\n#            'filename.ext',\n#            # ...\n#        ]\n    },\n    entry_points={\n#        'console_scripts':[\n#            'executable_name = namespace.path:function',\n#            # ...\n#        ],\n    },\n# Adding the test suite for the project\n    test_suite='tests.test_hms_core',\n)\n```", "```py\n# Makefile for the HMS Core (hms-core) project\n\nmain: test setup\n        # Doesn't (yet) do anything other than running the test and \n        # setup targets\n\nsetup:\n        # Calls the main setup.py to build a source-distribution\n        # python setup.py sdist\n\ntest:\n        # Executes the unit-tests for the package, allowing the build-\n        # process to die and stop the build if a test fails\n        python setup.py. test\n```"]