["```py\nfrom hms_core.daemons import BaseDaemon, DaemonMessage, \\ \n    InvalidMessageError \nfrom hms_core.daemons import BaseDaemon\n```", "```py\nfrom hms_core.daemons import BaseDaemon\nfrom hms_core.messaging import DaemonMessage, InvalidMessageError\n```", "```py\nclass HasMessageData(metaclass=abc.ABCMeta):\n    \"\"\"\nProvides interface requirements, and type-identity for objects that \nare expected to provide a to_message_data method.\n\"\"\"\n\n    ###################################\n    # Abstract methods                #\n    ###################################\n\n    @abc.abstractmethod\n    def to_message_data(self) -> (dict,):\n        \"\"\"\nCreates and returns a dictionary representation of the instance \nthat is safe to be passed to a DaemonMessage instance during or \nafter creation as the data of that message.\n\nself .............. (HasMessageData instance, required) The \n                    instance to execute against\n\"\"\"\n        raise NotImplementedError(\n            '%s.to_message_data has not been implemented as '\n            'required by HasMessageData' % \n            (self.__class__.__name__)\n        )\n```", "```py\ndef to_message_data(self) -> (dict,):\n    \"\"\"\nCreates and returns a dictionary representation of the instance \nthat is safe to be passed to a DaemonMessage instance during or \nafter creation as the data of that message.\n\"\"\"\n    return {\n        'oid':str(self.oid),\n        # - Properties from BaseProduct:\n        'available':self.available,\n        'description':self.description,\n        'dimensions':self.dimensions,\n        'metadata':self.metadata,\n        'name':self.name,\n        'shipping_weight':self.shipping_weight,\n        'summary':self.summary,\n        # - Date/time values, since we may well want/need to \n        #   keep those in sync across environments\n        'created':datetime.strftime(\n            self.created, self.__class__._data_time_string\n        ),\n        'modified':datetime.strftime(\n            self.modified, self.__class__._data_time_string\n        ),\n    }\n```", "```py\nnew_product_message = DaemonMessage(\n    'create', new_product.to_message_data(), signing_key\n)\n# - Assumes that RabbitMQSender has already been configured...\n#   it would be slightly more involved if this were the first time \n#   it was used...\nsender = RabbitMQSender()\nsender.send_message(new_product_message)\n```", "```py\ndef create_product(self, properties:(dict,)) -> None:\n    self.info('%s.create_product called' % self.__class__.__name__)\n    if type(properties) != dict:\n        raise TypeError(\n            '%s.create_product expects a dict of Product '\n            'properties, but was passed \"%s\" (%s)' % \n            (\n                self.__class__.__name__, properties, \n                type(properties).__name__\n            )\n        )\n    self.debug('properties ... %s:' % (type(properties)))\n    self.debug(str(properties))\n    # - Create the new object...\n    new_object = Product.from_data_dict(properties)\n    self.debug('New object created successfully')\n    #   ...and save it.\n    new_object.save()\n    self.info(\n        'New Product %s created successfully' % new_object.oid\n    )\n```", "```py\ndef to_message_data(self) -> (dict,):\n    \"\"\"\nCreates and returns a dictionary representation of the instance \nthat is safe to be passed to a DaemonMessage instance during or \nafter creation as the data of that message.\n\"\"\"\n    return {\n        'oid':str(self.oid),\n        # - Properties from BaseProduct:\n        'store_available':self.store_available,\n        # - Date/time values, since we may well want/need to \n        #   keep those in sync across environments\n        'modified':datetime.strftime(\n            self.modified, self.__class__._data_time_string\n        ),\n    }\n```", "```py\nproduct_message = DaemonMessage(\n    'update', product_to_activate.to_message_data(), signing_key\n)\nsender = RabbitMQSender()\nsender.send_message(product_message)\n```", "```py\ndef update_product(self, properties:(dict,)) -> None:\n    self.info('%s.update_product called' % self.__class__.__name__)\n    if type(properties) != dict:\n        raise TypeError(\n            '%s.update_product expects a dict of Product '\n            'properties, but was passed \"%s\" (%s)' % \n            (\n                self.__class__.__name__, properties, \n                type(properties).__name__\n            )\n        )\n    self.debug('properties ... %s:' % (type(properties)))\n    self.debug(str(properties))\n    # - Retrieve the existing object, and get its data-dict \n    #   representation\n    existing_object = Product.get(properties['oid'])\n    self.debug(\n        'Product %s retrieved successfully' % existing_object.oid\n    )\n    data_dict = existing_object.to_data_dict()\n    # - Update the data-dict with the values from properties\n    data_dict.update(properties)\n    # - Make sure it's flagged as dirty, so that save will \n    #   *update* instead of *create* the instance-record, \n    #   for data-stores where that applies\n    data_dict['is_dirty'] = True\n    # - Create a new instance of the class with the revised \n    #   data-dict...\n    new_object = Product.from_data_dict(data_dict)\n    #   ...and save it.\n    new_object.save()\n    self.info('Product %s updated successfully' % new_object.oid)\n```", "```py\ndef to_message_data(self) -> (dict,):\n    \"\"\"\nCreates and returns a dictionary representation of the instance \nthat is safe to be passed to a DaemonMessage instance during or \nafter creation as the data of that message.\n\"\"\"\n    return {\n        'oid':str(self.oid),\n        # - Properties from BaseProduct:\n        'description':self.description,\n        'name':self.name,\n        'store_available':self.store_available,\n        'summary':self.summary,\n        # - Date/time values, since we may well want/need to \n        #   keep those in sync across environments\n        'modified':datetime.strftime(\n            self.modified, self.__class__._data_time_string\n        ),\n    }\n```", "```py\nproduct_message = DaemonMessage(\n    'update', product_to_update.to_message_data(), signing_key\n)\nsender = RabbitMQSender()\nsender.send_message(product_message)\n```", "```py\nproduct_message = DaemonMessage(\n    'delete', product_to_delete.to_message_data(), signing_key\n)\nsender = RabbitMQSender()\nsender.send_message(product_message)\n```", "```py\nmessage_data = {\n    'oid':str(product_to_delete.oid)\n}\nproduct_message = DaemonMessage('delete',message_data, signing_key)\nsender = RabbitMQSender()\nsender.send_message(product_message)\n```", "```py\ndef delete_product(self, properties:(dict,)) -> None:\n    self.info('%s.delete_product called' % self.__class__.__name__)\n    self.debug(str(properties))\n    # - Delete the instance-record for the specified object\n    Product.delete(properties['oid'])\n    self.debug(\n        'Product %s deleted successfully' % properties['oid']\n    )\n```", "```py\n# - Typical create-object message-creation and -transmission\ncreate_message = DaemonMessage(\n    'create', object_to_create.to_message_data(), signing_key\n)\nsender = RabbitMQSender()\nsender.send_message(create_message)\n\n# - Typical update-object message-creation and -transmission\nupdate_message = DaemonMessage(\n    'update', object_to_update.to_message_data(), signing_key\n)\nsender = RabbitMQSender()\nsender.send_message(update_message)\n```", "```py\n# - Transmit the full object-data-set as the delete-message\ndelete_message = DaemonMessage(\n    'delete', object_to_delete.to_message_data(), signing_key\n)\nsender = RabbitMQSender()\nsender.send_message(delete_message)\n\n# - Transmit *only* the required oid as the delete-message:\nmessage_data = {\n    'oid':str(product_to_delete.oid)\n}\ndelete_message = DaemonMessage('delete', message_data, signing_key)\nsender = RabbitMQSender()\nsender.send_message(delete_message)\n```", "```py\ndef update_artisan(self, properties:(dict,)) -> None:\n    self.info('%s.update_artisan called' % self.__class__.__name__)\n    if type(properties) != dict:\n        raise TypeError(\n            '%s.update_artisan expects a dict of Artisan '\n            'properties, but was passed \"%s\" (%s)' % \n            (\n                self.__class__.__name__, properties, \n                type(properties).__name__\n            )\n        )\n    self.debug('properties ... %s:' % (type(properties)))\n    self.debug(str(properties))\n    # - Retrieve the existing object, and get its data-dict \n    #   representation\n    existing_object = Artisan.get(properties['oid'])\n    self.debug(\n        'Artisan %s retrieved successfully' % existing_object.oid\n    )\n    data_dict = existing_object.to_data_dict()\n    # - Update the data-dict with the values from properties\n    data_dict.update(properties)\n    # - Make sure it's flagged as dirty, so that save will \n    #   *update* instead of *create* the instance-record, \n    #   for data-stores where that applies\n    data_dict['is_dirty'] = True\n    # - Create a new instance of the class with the revised \n    #   data-dict...\n    new_object = Artisan.from_data_dict(data_dict)\n    #   ...and save it.\n    new_object.save()\n    self.info('Artisan %s updated successfully' % new_object.oid)\n```", "```py\ndef to_message_data(self) -> (dict,):\n    \"\"\"\nCreates and returns a dictionary representation of the instance \nthat is safe to be passed to a DaemonMessage instance during or \nafter creation as the data of that message.\n\"\"\"\n    return {\n        'oid':str(self.oid),\n        # - BaseArtisan-derived items\n        'address':self.address.to_dict() if self.address else None,\n        'company_name':self.company_name,\n        'contact_email':self.contact_email,\n        'contact_name':self.contact_name,\n        'website':self.website, \n        # - BaseDataObject-derived items\n        'created':datetime.strftime(\n            self.created, self.__class__._data_time_string\n        ),\n        'modified':datetime.strftime(\n            self.modified, self.__class__._data_time_string\n        ),\n        # Queue- and signing-key values\n        'queue_id':self.queue_id,\n        'signing_key':self.signing_key.hex(),\n    }\n```", "```py\n    def to_message_data(self) -> (dict,):\n        \"\"\"\nCreates and returns a dictionary representation of the instance \nthat is safe to be passed to a DaemonMessage instance during or \nafter creation as the data of that message.\n\"\"\"\n        return {\n            'oid':str(self.oid),\n            # - BaseArtisan-derived items\n            'address':self.address.to_dict() if self.address else None,\n            'company_name':self.company_name,\n            'contact_email':self.contact_email,\n            'contact_name':self.contact_name,\n            'website':self.website, \n            # - BaseDataObject-derived items\n            'created':datetime.strftime(\n                self.created, self.__class__._data_time_string\n            ),\n            'modified':datetime.strftime(\n                self.modified, self.__class__._data_time_string\n            )\n        }\n```", "```py\ndef create_order_from_store(\n    cls, customer:(BaseCustomer,str,dict), **order_items\n):\n    \"\"\"\nCreates and returns a new order-instance, whose state is populated \nwith data from the     \n\ncustomer .......... (Type TBD, required) The customer that placed \n                    the order\norder_items ....... (dict [oid:quantity], required) The items and \n                    their quantities in the order\n\"\"\"\n```", "```py\n    # - Get all the products and quantities identified by the \n    #   incoming oid-values in order_items\n    products = {\n        product:order_items[str(product.oid)] \n        for product in Product.get()\n```", "```py\n        if str(product.oid) in order_items.keys()\n    ]\n```", "```py\n# TODO: Determine how customer-data is going to be #provided \n# (probably a key/value string, could be a JSON packet \n# that could be converted to a dict), and find or create \n# a customer object if/as needed. In the interim, for \n# testing purposes, accept a BaseCustomer-derived object.\n  if not isinstance(customer, BaseCustomer):\n      raise NotImplementedError(\n          \"%s.create_order_from_store doesn't yet accept \"\n          \"customer arguments that aren't BaseCustomer-\"\n          \"derived objects, sorry\" % (cls.__name__)\n      )\n```", "```py\n# - Create the order-instance, making sure it's tagged \n#   as new and not dirty so that the save process will \n#   call _create\nnew_order = cls(\n    customer, is_dirty=False, is_new=True, *products\n)\n# - Save it and return it\nnew_order.save()\nreturn new_order\n```", "```py\ndef to_message_data(self) -> (dict,):\n    \"\"\"\nCreates and returns a dictionary representation of the instance \nthat is safe to be passed to a DaemonMessage instance during or \nafter creation as the data of that message.\n\"\"\"\n    return {\n        # - Local properties\n        'name':self.name,\n        'street_address':self.street_address,\n        'building_address':self.building_address,\n        'city':self.city,\n        'region':self.region,\n        'postal_code':self.postal_code,\n        'country':self.country,\n        # - Generate a string:int dict from the UUID:int dict\n        'items':{\n            str(key):int(self.items[key]) \n            for key in self.items.keys()\n        },\n        # - Properties from BaseDataObject (through \n        #   HMSMongoDataObject)\n        'modified':datetime.strftime(\n            self.modified, self.__class__._data_time_string\n        ),\n        'oid':str(self.oid),\n    }\n```", "```py\ndef create_order(self, properties:(dict,)) -> None:\n    self.info('%s.create_order called' % self.__class__.__name__)\n    if type(properties) != dict:\n        raise TypeError(\n            '%s.create_order expects a dict of Order '\n            'properties, but was passed \"%s\" (%s)' % \n            (\n                self.__class__.__name__, properties, \n                type(properties).__name__\n            )\n        )\n    self.debug('properties ... %s:' % (type(properties)))\n    self.debug(str(properties))\n# - Create the new object...\n    new_order = Order.create_order_from_store(properties)\n    self.info(\n        'New Order %s created successfully' % new_order.oid\n    )\n```", "```py\n{\n    'oid':<UUID>,\n    'name':<str>,\n    # - Shipping-address properties\n    'street_address':<str>,\n    'building_address':<str> or None,\n    'city':<str>,\n    'region':<str>,\n    'postal_code':<str>,\n    'country':<str> or None,\n    # - order-items\n    'items':{\n        <Product object #1>:<int>,\n        <Product object #2>:<int>,\n        <Product object #3>:<int>,\n    },\n}\n```", "```py\n    artisan_orders = {}\n    # - Get all the artisans\n    all_artisans = Artisan.get()\n    # - Sort out which artisan is associated with each item \n    #   in the order, and create or add to a list of \n    #   products:quantities for each\n    for product in new_order.products:\n        try:\n            artisan = [\n                candidate for candidate in all_artisans\n                if product.oid in [\n                    p.oid for p in candidate.products\n                ]\n            ][0]\n```", "```py\nitem_data = {\n  str(oid):new_order.products[product]\n}\nif artisan_orders.get(artisan):\n   artisan_orders[artisan].append(item_data)\nelse:\n   artisan_orders[artisan] = [item_data]\nif artisan_orders.get(artisan):\n   artisan_orders[artisan].append(product)\nelse:\n   artisan_orders[artisan] = [product]\n```", "```py\nexcept IndexError:\n   self.error(\n       '%s.create_order could not find an '\n       'artisan-match for the product %s' % \n       (product.oid)\n   )\nself.debug('All artisan/product associations handled')\n```", "```py\n{\n    <Artisan #1>:{\n        <str<UUID>>:<int>,\n        <str<UUID>>:<int>,\n    },\n    <Artisan ...>:{\n        <str<UUID>>:<int>,\n    },\n    <Artisan #{whatever}>:{\n        <str<UUID>>:<int>,\n        <str<UUID>>:<int>,\n    },\n}\n```", "```py\nsender = RabbitMQSender()\nself.info('Sending order-messages to artisans:')\nfor artisan in artisan_orders:\n# Get the products that this artisan needs to be concerned #with\nitems = artisan_orders[artisan]\n# - Create a message-structure that \n#   artisan_objects.Order.from_message_dict can handle\nnew_order_data = {\n    'target':'order',\n    'properties':{\n        'name':new_order.name,\n        'street_address':new_order.street_address,\n                'building_address':new_order.building_address,\n                'city':new_order.city,\n                'region':new_order.region,\n                'postal_code':new_order.postal_code,\n                'country':new_order.country,\n                'items':items,\n                'oid':str(new_order.oid),\n            },\n        }\n        # - Create the signed message\n        order_message = DaemonMessage(\n            'create', new_order_data, artisan.signing_key\n        )\n```", "```py\n# - Send the message to the artisan\nsender.send_message(order_message, artisan.queue_id)\nself.info(\n    '+- Sent order-message with %d products to '\n    'Artisan %s' % (len(items), artisan.oid)\n)\n```", "```py\ndef send_message(self, message:(DaemonMessage), \n        # Added queue_name\n        queue_name:(str,None)=None\n    ):\n    if type(message) != DaemonMessage:\n        raise TypeError(\n            '%s.send_message expects a DaemonMessage instance '\n            'as its message argument, but was passed \"%s\" (%s)' % \n            (\n                self.__class__.__name__, message, \n                type(message).__name__\n            )\n        )\n # Using the optional queue_name to override the default\n    if not queue_name:\n        queue_name = self.queue_name\n # - Note that exchange is blank -- we're just using the \n #   default exchange at this point\u2026\n # - Also note that we're using queue_name instead of the \n #   original self.queue_name default...\n    self.channel.basic_publish(\n        exchange='', routing_key=queue_name, \n        body=message.to_message_json()\n  )\n```", "```py\ndef fulfill_items(self, oid:(UUID,str), quantity:(int,)):\n    \"\"\"\nAssigns a number of items fulfilled to a given item-oid, and sets the \nis_dirty state of the instance to True\n\"\"\"\n```", "```py\nif type(oid) not in (UUID,str):\n   raise TypeError() # Expecting a UUID or str-UUID value\nif type(oid) != UUID:\n   try:\n      oid = UUID(oid)\n   except:\n      raise ValueError() # Could not convert a str value to a UUID\nif type(quantity) != int:\n   raise TypeError()\nif quantity < 0:\n   raise ValueError() # Should not fulfill a negative quantity\n```", "```py\nif oid not in self._items:\n   raise RuntimeError(\n       '%s.fulfill_item was asked to fulfill an item '\n       '(%s) that doesn\\'t exist in the order-items' % \n       (self.__class__.__name__, oid)\n)\n```", "```py\nif quantity > self._items[oid]:\n   raise RuntimeError(\n         '%s.fulfill_item was asked to fulfill an item '\n         '(%s) in a higher quantity (%d) than was '\n         'ordered (%d)' % \n         (\n            self.__class__.__name__, oid, quantity, \n            self._items[oid]\n         )\n   )\n# If everything checks out, then update the quantity, etc.\nself._fulfilled_items[oid] = quantity\nself._set_is_dirty(True)\n```", "```py\ndef save(self, origin:(str,)):\n    \"\"\"\nSaves the instance's state-data to the back-end data-store by \ncreating it if the instance is new, or updating it if the \ninstance is dirty\n\"\"\"\n    # - Perform the data-save process as it currently exists\n    if self.is_new and origin != 'artisan':\n        # - Send \"create\" message\n    elif self.is_dirty and origin != 'artisan':\n        # - Send \"update\" message\n    self._set_is_new(False)\n    self._set_is_dirty(False)\n```", "```py\n{\n    'operation':'update',\n    'origin':'artisan',\n    'data': {\n        'target':'product',\n        'properties':{\n            'oid':str(new_order.oid),\n            'name':'Revised Product Name',\n            # - Other product-data skipped for brevity\n        },\n    },\n    'signature':'signature hex-string'\n}\n```", "```py\n# self.message_origin is an attribute containing 'gateway'\n# - message is the incoming DaemonMessage instance\n# - message.origin is 'artisan'\n# - artisan is the relevant Artisan object\nif message.origin == self.message_origin:\n    sender = RabbitMQSender()\n    outbound_message = DaemonMessage(\n        operation=message.operation,\n        origin=self.message_origin,\n        data=message.data,\n        signing_key=self.signing_key\n    )\n    sender.send_message(order_message, artisan.queue_id)\n```", "```py\ndef _handle_message(self, message:(DaemonMessage,)) -> None:\n    self.info(\n        '%s._handle_message called:' % self.__class__.__name__\n    )\n    target = message.data.get('target')\n    self.debug('+- target ....... (%s) %s' % (\n        type(target).__name__, target)\n    )\n    self.debug('+- operation .... (%s) %s' % (\n        type(message.operation).__name__, message.operation)\n    )\n    if message.operation == 'create':\n        if target == 'artisan':\n            self.create_artisan(message)\n\n# ... removed for brevity\n\n    elif message.operation == 'update':\n        if target == 'artisan':\n            self.update_artisan(message)\n        elif target == 'customer':\n            self.update_customer(message)\n        elif target == 'order':\n            self.update_order(message)\n        elif target == 'product':\n            self.update_product(message)\n        else:\n            raise RuntimeError(\n                '%s error: \"%s\" (%s) is not a recognized '\n                'object-type/target' % \n                (\n                    self.__class__.__name__, target, \n                    type(target).__name__\n                )\n            )\n\n    # ... removed for brevity\n\n    else:\n        raise RuntimeError(\n            '%s error: \"%s\" (%s) is not a recognized '\n            'operation' % \n            (\n                self.__class__.__name__, message.operation, \n                type(message.operation).__name__\n            )\n        )\n```", "```py\ndef update_product(self, message:(DaemonMessage,)) -> None:\n    self.info('%s.update_product called' % self.__class__.__name__)\n      if type(message) != DaemonMessage:\n         raise TypeError(\n             '%s.update_product expects a DaemonMessage '\n             'instance, but was passed \"%s\" (%s)' % \n             (\n                self.__class__.__name__, message, \n                type(message).__name__\n             )\n         )\n```", "```py\nproperties = message.data.get('properties')\nself.debug('properties ... %s:' % (type(properties)))\nself.debug(str(properties))\n```", "```py\n#   ... and save it.\nnew_object.save()\nself.info('Product %s updated successfully' % new_object.oid)\n```", "```py\nif message.origin == self.message_origin:\n  # - Acquire the Artisan whose Product this is\n  artisan = self.get_artisan_from_product(new_object)\n  sender = RabbitMQSender()\n  outbound_message = DaemonMessage(\n       operation=message.operation,\n       origin=message.origin,\n       data=message.data,\n       signing_key=self.signing_key\n   )\n   sender.send_message(order_message, artisan.queue_id)\n```", "```py\ndef get_artisan_from_product(\n       self, product:(UUID,str,BaseProduct)\n    ) -> (Artisan):\n    # TODO: Add artisan (owner) to Product classes, and use \n    #       that instead. For now, use this approach\n    all_artisans = Artisan.get()\n    if isinstance(product, BaseProduct):\n       product = product.oid\n    elif type(product) == str:\n       product = UUID(product)\n    for artisan in all_artisans:\n        if product in [p.oid for p in artisan.products]:\n           return artisan\n```"]