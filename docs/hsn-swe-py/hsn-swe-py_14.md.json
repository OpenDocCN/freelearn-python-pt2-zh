["```py\ndef test_file_store_dir(self):\n    self.assertEqual(\n        JSONFileDataObject._file_store_dir, None, \n        'JSONFileDataObject._file_store_dir is expected to provide '\n        'a None default value that must be overridden by derived '\n        'classes, but it is set to \"%s\" (%s)' % \n        (\n            JSONFileDataObject._file_store_dir, \n            type(JSONFileDataObject._file_store_dir).__name__\n        )\n    )\n```", "```py\nclass testJSONFileDataObject(unittest.TestCase):\n\n    ###################################\n    # Tests of class methods          #\n    ###################################\n\n    def test__init__(self):\n        # Tests the __init__ method of the JSONFileDataObject class\n        # - All we need to do here is prove that the various \n        #   setter- and deleter-method calls are operating as \n        #   expected -- same as BaseDataObject\n        # - deleters first\n        test_object = JSONFileDataObjectDerived()\n        self.assertEquals(test_object._created, None)\n        self.assertEquals(test_object._is_active, True)\n        self.assertEquals(test_object._is_deleted, False)\n        self.assertEquals(test_object._is_dirty, False)\n        self.assertEquals(test_object._is_new, True)\n        self.assertEquals(test_object._modified, None)\n        self.assertEquals(test_object._oid, None)\n        # - setters\n        oid = uuid4()\n        created = GoodDateTimes[0]\n        modified = GoodDateTimes[1]\n        is_active = False\n        is_deleted = True\n        is_dirty = True\n        is_new = False\n        test_object = JSONFileDataObjectDerived(\n            oid, created, modified, is_active, is_deleted, \n            is_dirty, is_new\n        )\n        self.assertEquals(test_object.oid, oid)\n        self.assertEquals(test_object.created, created)\n        self.assertEquals(test_object.is_active, is_active)\n        self.assertEquals(test_object.is_deleted, is_deleted)\n        self.assertEquals(test_object.is_dirty, is_dirty)\n        self.assertEquals(test_object.is_new, is_new)\n        self.assertEquals(test_object.modified, modified)\n```", "```py\ndef test_create(self):\n   # Tests the _create method of the JSONFileDataObject class\n     test_object = JSONFileDataObjectDerived()\n       try:\n         test_object._create()\n         self.fail(\n           'JSONFileDataObject is not expected to raise '\n            'NotImplementedError on a call to _create'\n          )\n        except NotImplementedError:\n            pass\n        except Exception as error:\n            self.fail(\n                'JSONFileDataObject is not expected to raise '\n                'NotImplementedError on a call to _create, but %s '\n                'was raised instead:\\n - %s' %\n                (error.__class__.__name__, error)\n            )\n\ndef test_update(self):\n   # Tests the _update method of the JSONFileDataObject class\n   test_object = JSONFileDataObjectDerived()\n     try:\n         test_object._update()\n         self.fail(\n            'JSONFileDataObject is not expected to raise '\n            'NotImplementedError on a call to _update'\n          )\n      except NotImplementedError:\n         pass\n      except Exception as error:\n         self.fail(\n             'JSONFileDataObject is not expected to raise '\n             'NotImplementedError on a call to _update, but %s '\n             'was raised instead:\\n - %s' %\n             (error.__class__.__name__, error)\n          )\n```", "```py\n@unittest.skip(\n    'Since the file-load process provided by _load_objects is '\n    'used by many of the CRUD operations, it is tested  as part of '\n    'testCRUDOperations'\n  )\ndef test_load_objects(self):\n    # Tests the _load_objects method of the JSONFileDataObject class\n      self.fail('test_load_objects is not yet implemented')\n\n@unittest.skip(\n    'Since deleting a data-file is part of the CRUD operations, '\n    'it is tested as part of testCRUDOperations'\n  )\ndef testdelete(self):\n    # Tests the delete method of the JSONFileDataObject class\n      self.fail('testdelete is not yet implemented')\n\n@unittest.skip(\n    'Since reading data-files is part of the CRUD operations, '\n    'it is tested as part of testCRUDOperations'\n  )\ndef testget(self):\n    # Tests the get method of the JSONFileDataObject class\n    self.fail('testget is not yet implemented')\n\n@unittest.skip(\n    'Since creating a data-file is part of the CRUD operations, '\n    'it is tested as part of testCRUDOperations'\n  )\ndef testsave(self):\n     # Tests the save method of the JSONFileDataObject class\n     self.fail('testsave is not yet implemented')\n```", "```py\nclass JSONFileDataObjectDerived(JSONFileDataObject):\n```", "```py\n_file_store_dir = '/tmp/hms_artisan_test'\n```", "```py\ndef matches(self, **criteria) -> (bool,):\n   return BaseDataObject.matches(self, **criteria)\n\n@classmethod\ndef from_data_dict(cls, data_dict:(dict,)):\n   return cls(**data_dict)\n```", "```py\ndef to_data_dict(self):\n   return {\n        'created':datetime.strftime(\n         self.created, self.__class__._data_time_string\n         ),\n         'is_active':self.is_active,\n         'is_deleted':self.is_deleted,\n         'modified':datetime.strftime(\n             self.modified, self.__class__._data_time_string\n          ),\n          'oid':str(self.oid),\n        }\n```", "```py\ndef testCRUDOperations(self):\n   # - First, assure that the class-level data-object collection \n   #   (in JSONFileDataObjectDerived._loaded_objects) is None, \n   #   and that the file-repository does not exist.\n   JSONFileDataObjectDerived._loaded_objects = None\n   if os.path.exists(JSONFileDataObjectDerived._file_store_dir):\n      rmtree(JSONFileDataObjectDerived._file_store_dir)\n```", "```py\n# - Next, create an item and save it\nfirst_object = JSONFileDataObjectDerived()\nfirst_object.save()\n# - Verify that the file exists where we're expecting it\nself.assertTrue(\n    os.path.exists(\n         '/tmp/hms_artisan_test/JSONFileDataObjectDerived-'\n         'data/%s.json' % first_object.oid\n       )\n    )\n# - and that it exists in the in-memory cache\n    self.assertNotEqual(\n          JSONFileDataObjectDerived._loaded_objects.get(\n            str(first_object.oid)\n          ), None\n    )\n```", "```py\n# - Verify that the item can be retrieved, and has the same \n#   data\nfirst_object_get = JSONFileDataObjectDerived.get()[0]\nself.assertTrue(\n      first_object.matches(**first_object_get.to_data_dict())\n)\nself.assertEqual(\n      first_object.is_dirty, first_object_get.is_dirty\n)\nself.assertEqual(\n      first_object.is_new, first_object_get.is_new\n)\n```", "```py\n# - Create and save two more items\nsecond_object = JSONFileDataObjectDerived()\nsecond_object.save()\nthird_object = JSONFileDataObjectDerived()\nthird_object.save()\n# - Verify that all three items can be retrieved, and that \n#   they are the expected objects, at least by their oids: \n#   Those, as part of the file-names, *will* be unique and \n#   distinct...\nall_objects = JSONFileDataObjectDerived.get()\nexpected = set(\n     [o.oid for o in [first_object, second_object, third_object]]\n)\nactual = set([o.oid for o in all_objects])\nself.assertEqual(expected, actual)\n```", "```py\n# - Verify that the file for the second item exists, so the \n#   verification later of its deletion is a valid test\nself.assertTrue(\n    os.path.exists(\n        '/tmp/hms_artisan_test/JSONFileDataObjectDerived-'\n        'data/%s.json' % second_object.oid\n     )\n)\n```", "```py\n# - Delete the second item\nJSONFileDataObjectDerived.delete(second_object.oid)\n# - Verify that the item has been removed from the loaded-\n#   object store and from the filesystem\nself.assertEqual(\n            JSONFileDataObjectDerived._loaded_objects.get(second_object.oid), \n            None\n)\nself.assertFalse(\nos.path.exists(\n        '/tmp/hms_artisan_test/JSONFileDataObjectDerived-'\n        'data/%s.json' % second_object.oid\n     )\n )\n```", "```py\n# - Update the last object created, and save it\nthird_object._set_is_active(False)\nthird_object._set_is_deleted(True)\nthird_object.save()\n# - Read the updated object and verify that the changes made \n#   were saved to the file.\nthird_object_get = JSONFileDataObjectDerived.get(third_object.oid)[0]\nself.assertEqual(\n       third_object.to_data_dict(),\n       third_object_get.to_data_dict()\n     )\nself.assertTrue(\n       third_object.matches(**third_object_get.to_data_dict())\n     )\nself.assertEqual(\n       third_object.is_dirty, third_object_get.is_dirty\n     )\nself.assertEqual(\n       third_object.is_new, third_object_get.is_new\n     )\n```", "```py\n# - Since other test-methods down the line might need to start \n#   with empty object- and file-sets, re-clear them both\nJSONFileDataObjectDerived._loaded_objects = None\nif os.path.exists(JSONFileDataObjectDerived._file_store_dir):\n   rmtree(JSONFileDataObjectDerived._file_store_dir)\nself.fail('testCRUDOperations is not complete')\n```", "```py\n###################################\n# Tests of class properties       #\n###################################\n\ndef test_file_store_dir(self):\n  self.assertEqual(\n      JSONFileDataObject._file_store_dir, None, \n      'JSONFileDataObject._file_store_dir is expected to provide '\n      'a None default value that must be overridden by derived '\n      'classes, but it is set to \"%s\" (%s)' % \n      (\n           JSONFileDataObject._file_store_dir, \n           type(JSONFileDataObject._file_store_dir).__name__\n      )\n    )\n    try:\n       test_object = NoFileStoreDir()\n       self.fail(\n           'Classes derived from JSONFileDataObject are expected '\n           'to define a _file_store_dir class-attribute, or cause '\n           'instantiation of objects from classes that don\\'t '\n           'have one defined to fail with an AttributeError'\n       )\n     except AttributeError:\n         pass\n```", "```py\ndef testcontact_name(self):\n    # Tests the contact_name property of the Artisan class\n    # - Assert that the getter is correct:\n    self.assertEqual(\n        BaseArtisan.contact_name.fget, \n        Artisan._get_contact_name, \n        'Artisan.contact_name is expected to use the '\n        'BaseArtisan._get_contact_name method as its getter-method'\n    )\n    # - Assert that the setter is correct:\n    self.assertEqual(\n        Artisan.contact_name.fset, \n        Artisan._set_contact_name, \n        'Artisan.contact_name is expected to use the '\n        '_set_contact_name method as its setter-method'\n    )\n    # - Assert that the deleter is correct:\n    self.assertEqual(\n        Artisan.contact_name.fdel, \n        Artisan._del_contact_name, \n        'Artisan.contact_name is expected to use the '\n        '_del_contact_name method as its deleter-method'\n    )\n```", "```py\ndef testmetadata(self):\n    # Tests the metadata property of the Product class\n    # - Assert that the getter is correct:\n    self.assertEqual(\n        Product.metadata.fget, \n        BaseProduct._get_metadata, \n        'Product.metadata is expected to use the '\n        'BaseProduct._get_metadata method as its getter-method'\n    )\n    # - Assert that the setter is correct:\n    self.assertEqual(\n        Product.metadata.fset, \n        None, \n        'Product.metadata is expected to be read-only, with no setter'\n    )\n    # - Assert that the deleter is correct:\n    self.assertEqual(\n        Product.metadata.fdel, \n        None, \n        'Product.metadata is expected to be read-only, with no deleter'\n    )\n```", "```py\ndef test_del_address(self):\n    # Tests the _del_address method of the Artisan class\n    test_object = Artisan('name', 'me@email.com', GoodAddress)\n    self.assertEqual(test_object.is_dirty, False, \n        'A newly-created instance of an Artisan should '\n        'have is_dirty of False'\n    )\n    test_object._del_address()\n    self.assertEqual(test_object.is_dirty, True, \n        'The deletion of an Artisan address should set '\n        'is_dirty to True'\n    )\n\n# ...\n\ndef test_set_address(self):\n    # Tests the _set_address method of the Artisan class\n    test_object = Artisan('name', 'me@email.com', GoodAddress)\n    self.assertEqual(test_object.is_dirty, False, \n        'A newly-created instance of an Artisan should '\n        'have is_dirty of False'\n    )\n    test_object._set_address(GoodAddresses[0])\n    self.assertEqual(test_object.is_dirty, True, \n        'Setting an Artisan address should set '\n        'is_dirty to True'\n    )\n```", "```py\ndef testto_data_dict(self):\n    # Tests the to_data_dict method of the Order class\n    for name in GoodStandardRequiredTextLines[0:2]:\n        for street_address in GoodStandardRequiredTextLines[0:2]:\n            for city in GoodStandardRequiredTextLines[0:2]:\n                # - At this point, we have all the required \n                #   arguments, so we can start testing with \n                #   partial expected dict-values\n                test_object = Order(\n                    name, street_address, city,\n                )\n                expected = {\n                    'name':name,\n                    'street_address':street_address,\n                    'city':city,\n                    # - The balance are default values...\n                    'building_address':None,\n                    'region':None,\n                    'postal_code':None,\n                    'country':None,\n                    'items':{},\n                    # - We also need to include the data-object \n                    #   items that should appear!\n                    'created':datetime.strftime(\n                            test_object.created, \n                            test_object._data_time_string\n                        ),\n                    'modified':datetime.strftime(\n                            test_object.modified, \n                            test_object._data_time_string\n                        ),\n                    'oid':str(test_object.oid),\n                    'is_active':test_object.is_active,\n                    'is_deleted':test_object.is_deleted,\n                }\n                self.assertEqual(\n                    test_object.to_data_dict(), expected\n                )\n```", "```py\nfor items in GoodOrderItems:\n  test_object = Order(\n       name, street_address, city,\n       items=items,\n  )\n```", "```py\nexpected = {\n    'name':name,\n    'street_address':street_address,\n    'city':city,\n    'building_address':None,\n    'region':None,\n    'postal_code':None,\n    'country':None,\n    'items':items,\n    'created':datetime.strftime(\n         test_object.created, \n         test_object._data_time_string\n     ),\n    'modified':datetime.strftime(\n         test_object.modified, \n         test_object._data_time_string\n     ),\n     'oid':str(test_object.oid),\n     'is_active':test_object.is_active,\n     'is_deleted':test_object.is_deleted,\n}\n```", "```py\nself.assertEqual(\n     test_object.to_data_dict(), expected\n)\n```", "```py\nfor building_address in GoodStandardOptionalTextLines[0:2]:\n    for region in GoodStandardOptionalTextLines[0:2]:\n        for postal_code in GoodStandardOptionalTextLines[0:2]:\n            for country in GoodStandardOptionalTextLines[0:2]:\n                pass\n```", "```py\nself.fail('testto_data_dict is not complete')\n```", "```py\ndef testfrom_data_dict(self):\n    # Tests the from_data_dict method of the Order class\n```", "```py\ndefaults = {\n   'building_address':None,\n   'region':None,\n   'postal_code':None,\n   'country':None,\n   'items':{},\n}\n```", "```py\nfor name in GoodStandardRequiredTextLines[0:2]:\n    for street_address in GoodStandardRequiredTextLines[0:2]:\n        for city in GoodStandardRequiredTextLines[0:2]:\n```", "```py\n# - At this point, we have all the required \n#   arguments, so we can start testing with \n#   partial expected dict-values\n    data_dict = {\n        'name':name,\n        'street_address':street_address,\n        'city':city,\n    }\n    test_object = Order.from_data_dict(data_dict)\n```", "```py\nactual = test_object.to_data_dict()\n```", "```py\n# - Create a copy of the defaults as a starting-point\nexpected = dict(defaults)\ninstance_values = {\n    'created':datetime.strftime(\n           test_object.created, \n           test_object._data_time_string\n         ),\n     'modified':datetime.strftime(\n           test_object.modified, \n           test_object._data_time_string\n         ),\n     'oid':str(test_object.oid),\n     'is_active':test_object.is_active,\n     'is_deleted':test_object.is_deleted,\n   }\n```", "```py\nexpected.update(instance_values)\nexpected.update(data_dict)\nself.assertEqual(expected, actual)\n```", "```py\nfor items in GoodOrderItems:\n   # - Same structure as above, but adding items\n   data_dict = {\n        'name':name,\n        'street_address':street_address,\n        'city':city,\n        'items':items,\n    }\n    test_object = Order.from_data_dict(data_dict)\n    actual = test_object.to_data_dict()\n    expected = dict(defaults)\n    instance_values = {\n        'created':datetime.strftime(\n                 test_object.created, \n                 test_object._data_time_string\n               ),\n        'modified':datetime.strftime(\n                 test_object.modified, \n                 test_object._data_time_string\n               ),\n         'oid':str(test_object.oid),\n         'is_active':test_object.is_active,\n         'is_deleted':test_object.is_deleted,\n    }\n    expected.update(instance_values)\n    expected.update(data_dict)\n    self.assertEqual(expected, actual)\n    for building_address in GoodStandardOptionalTextLines[0:2]:\n    for region in GoodStandardOptionalTextLines[0:2]:\n    for postal_code in GoodStandardOptionalTextLines[0:2]:\n    for country in GoodStandardOptionalTextLines[0:2]:\n        pass\nself.fail('testfrom_data_dict is not complete')\n```", "```py\ndef testmatches(self):\n    # Tests the matches method of the Order class\n    # - First, create an object to test against, with as complete \n    #   a data-set as we can manage\n    test_object = Order(\n        name = GoodStandardRequiredTextLines[0],\n        street_address = GoodStandardRequiredTextLines[0],\n        city = GoodStandardRequiredTextLines[0],\n        building_address = GoodStandardOptionalTextLines[0],\n        region = GoodStandardOptionalTextLines[0],\n        postal_code = GoodStandardOptionalTextLines[0],\n        country = GoodStandardOptionalTextLines[0],\n    )\n```", "```py\n# - Then we'll iterate over some \"good\" values, create criteria\nfor name_num in range(0,2):\n   name = GoodStandardRequiredTextLines[name_num]\n   criteria = {'name':name}\n   expected = (name == test_object.name)\n   self.assertEqual(expected, test_object.matches(**criteria))\n```", "```py\nfor str_addr_num in range(0,2):\n    street_address = GoodStandardRequiredTextLines[str_addr_num]\n    criteria['street_address'] = street_address\n    expected = (expected and street_address == test_object.street_address)\n    self.assertEqual(expected, test_object.matches(**criteria))\n```", "```py\nfor city_num in range(0,2):\n   city = GoodStandardRequiredTextLines[city_num]\n   criteria['city'] = city\n   expected = (expected and city == test_object.city)\n   self.assertEqual(expected, test_object.matches(**criteria))\n   for bldg_addr_num in range(0,2):\n       building_address = GoodStandardOptionalTextLines[bldg_addr_num]\n       criteria['building_address'] = building_address\n         expected = (\n             expected and \n             building_address == test_object.building_address\n            )\n            self.assertEqual(expected, test_object.matches(**criteria))\n            for region_num in range(0,2):\n                for pc_num in range(0,2):\n                    for cntry_num in range(0,2):\n                        country=GoodStandardOptionalTextLines[cntry_num]\nself.fail('testmatches is not complete')\n```", "```py\n@classmethod\ndef _load_objects(cls, force_load=False):\n    return JSONFileDataObject._load_objects(cls, force_load)\n```", "```py\ndef test_load_objects(self):\n    # Tests the _load_objects method of the Order class\n    # - First, forcibly change Order._file_store_dir to a disposable \n    #   temp-directory, and clear the in-memory and on-disk stores\n    Order._file_store_dir = '/tmp/test_artisan_objects/'\n    Order._loaded_objects = None\n    if os.path.exists(Order._file_store_dir):\n        rmtree(Order._file_store_dir)\n    self.assertEqual(Order._loaded_objects, None)\n```", "```py\n# - Iterate through some objects, creating them and saving them.\n    for name in GoodStandardRequiredTextLines[0:2]:\n       for street_address in GoodStandardRequiredTextLines[0:2]:\n          for city in GoodStandardRequiredTextLines[0:2]:\n```", "```py\n              test_object = Order(name, street_address, city)\n              test_object.save()\n```", "```py\n# - Verify that the object exists\n#   - in memory\nself.assertNotEqual(\n    Order._loaded_objects.get(str(test_object.oid)), \n    None\n)\n#   - on disk\nfile_path = '%s/Order-data/%s.json' % (\n    Order._file_store_dir, test_object.oid\n)\nself.assertTrue(\n    os.path.exists(file_path), \n    'The file was not written at %s' % file_path\n)\n```", "```py\n# - Make a copy of the OIDs to check with after clearing \n#   the in-memory copy:\noids_before = sorted([str(key) for key in Order._loaded_objects.keys()])\n# - Clear the in-memory copy and verify all the oids \n#   exist after a _load_objects is called\nOrder._loaded_objects = None\nOrder._load_objects()\noids_after = sorted(\n    [str(key) for key in Order._loaded_objects.keys()]\n)\nself.assertEqual(oids_before, oids_after)\n```", "```py\n# - Delete items at random and verify deletion and load after each\ninstances = list(Order._loaded_objects.values())\nwhile instances:\n   target = choice(instances)\n   Order.delete(target.oid)\n   # - Verify that the object no longer exists\n   #   - in memory\n   self.assertEqual(\n       Order._loaded_objects.get(str(test_object.oid)), \n       None\n   )\n   #   - on disk\n   file_path = '%s/Order-data/%s.json' % (\n       Order._file_store_dir, target.oid\n   )\n   self.assertFalse(\n        os.path.exists(file_path), \n        'File at %s was not deleted' % file_path\n   )\n   # - Make a copy of the OIDs to check with after clearing \n   #   the in-memory copy:\n   oids_before = sorted(\n        [str(key) for key in Order._loaded_objects.keys()]\n   )\n   # - Clear the in-memory copy and verify all the oids \n   #   exist after a _load_objects is called\n   Order._loaded_objects = None\n   Order._load_objects()\n   oids_after = sorted([str(key) for key in Order._loaded_objects.keys()])\n   self.assertEqual(oids_before, oids_after)\n```", "```py\ninstances.remove(target)\n```", "```py\n# - Clean up any remaining in-memory and on-disk store items\nOrder._loaded_objects = None\nif os.path.exists(Order._file_store_dir):\n    rmtree(Order._file_store_dir)\n```", "```py\n@unittest.skip(\n    'Sort will be implemented once there\\'s a need for it, '\n    'and tested as part of that implementation'\n)\ndef testsort(self):\n    # Tests the sort method of the Artisan class\n    # - Test all permutations of \"good\" argument-values:\n    # - Test all permutations of each \"bad\" argument-value \n    #   set against \"good\" values for the other arguments:\n    self.fail('testsort is not yet implemented')\n```", "```py\ndef testadd_product(self):\n    # Tests the add_product method of the Artisan class\n    test_object = Artisan('name', 'me@email.com', GoodAddress)\n    self.assertEqual(test_object.products, ())\n    check_list = []\n    for product in Goodproducts[0]:\n        test_object.add_product(product)\n        check_list.append(product)\n        self.assertEqual(test_object.products, tuple(check_list))\n    test_object = Artisan('name', 'me@email.com', GoodAddress)\n    for product in Badproducts:\n        try:\n            test_object.add_product(product)\n            self.fail(\n                'Artisan.add_product should not allow the '\n                'addition of \"%s\" (%s) as a product-item, but '\n                'it was allowed' % (product, type(product).__name__)\n            )\n        except (TypeError, ValueError):\n            pass\n```", "```py\ndef testremove_product(self):\n    # Tests the remove_product method of the Artisan class\n    test_object = Artisan('name', 'me@email.com', GoodAddress)\n    self.assertEqual(test_object.products, ())\n    for product in Goodproducts[0]:\n        test_object.add_product(product)\n    check_list = list(test_object.products)\n    while test_object.products:\n        product = test_object.products[0]\n        check_list.remove(product)\n        test_object.remove_product(product)\n        self.assertEqual(test_object.products, tuple(check_list))\n```", "```py\ndef test_del_building_address(self):\n    # Tests the _del_building_address method of the Order class\n    test_object = Order('name', 'street_address', 'city')\n    self.assertEqual(\n        test_object.building_address, None, \n        'An Order object is expected to have None as its default '\n        'building_address value if no value was provided'\n    )\n    # - Hard-set the storage-property's value, call the \n    #   deleter-method, and assert that it's what's expected \n    #   afterwards:\n    test_object._set_is_dirty(False)\n    test_object._building_address = 'a test value'\n    test_object._del_building_address()\n    self.assertEqual(\n        test_object.building_address, None, \n        'An Order object is expected to have None as its '\n        'building_address value after the deleter is called'\n    )\n    self.assertTrue(test_object.is_dirty,\n        'Deleting Order.building_address should set is_dirty to True'\n    )\n\n# ...\n\ndef test_set_building_address(self):\n    # Tests the _set_building_address method of the Order class\n    # - Create an object to test with:\n    test_object = Order('name', 'street_address', 'city')\n    # - Test all permutations of \"good\" argument-values:\n    for expected in GoodStandardOptionalTextLines:\n        test_object._set_building_address(expected)\n        actual = test_object._get_building_address()\n        self.assertEqual(\n            expected, actual, \n            'Order expects a building_address value set to '\n            '\"%s\" (%s) to be retrieved with a corresponding '\n            'getter-method call, but \"%s\" (%s) was returned '\n            'instead' % \n            (\n                expected, type(expected).__name__, \n                actual, type(actual).__name__, \n            )\n        )\n    # - Test is_dirty after a set\n    test_object._set_is_dirty(False)\n    test_object._set_building_address(GoodStandardOptionalTextLines[1])\n    self.assertTrue(test_object.is_dirty,\n        'Setting a new value in Order.business_address should '\n        'also set the instance\\'s is_dirty to True'\n    )\n    # - Test all permutations of \"bad\" argument-values:\n    for value in BadStandardOptionalTextLines:\n        try:\n            test_object._set_building_address(value)\n            # - If this setter-call succeeds, that's a \n            #   test-failure!\n            self.fail(\n                'Order._set_business_address should raise '\n                'TypeError or ValueError if passed \"%s\" (%s), '\n                'but it was allowed to be set instead.' % \n                (value, type(value).__name__)\n            )\n        except (TypeError, ValueError):\n            # - This is expected, so it passes\n            pass\n        except Exception as error:\n            self.fail(\n                'Order._set_business_address should raise '\n                'TypeError or ValueError if passed an invalid '\n                'value, but %s was raised instead: %s.' % \n                (error.__class__.__name__, error)\n            )\n```", "```py\n# - Test all permutations of \"good\" argument-values:\nconfig_file = '/tmp/datastore-test.json'\nfor database in good_databases:\n    for host in good_hosts:\n        for password in good_passwords:\n            for port in good_ports:\n                for user in good_users:\n                    config = {\n                        'database':database,\n                        'host':host,\n                        'password':password,\n                        'port':port,\n                        'user':user,\n                    }\n```", "```py\nfp = open('/tmp/datastore-test.json', 'w')\njson.dump(config, fp)\nfp.close()\n```", "```py\ntest_object = DatastoreConfig.from_config(config_file)\nself.assertEqual(test_object.database, database)\nself.assertEqual(test_object.host, host)\nself.assertEqual(test_object.password, password)\nself.assertEqual(test_object.port, port)\nself.assertEqual(test_object.user, user)\nos.unlink(config_file)\n```", "```py\n# - Test all permutations of each \"bad\" argument-value \n#   set against \"good\" values for the other arguments:\n# - database\nhost = good_hosts[0]\npassword = good_passwords[0]\nport = good_ports[0]\nuser = good_users[0]\nfor database in bad_databases:\n    config = {\n        'database':database,\n        'host':host,\n        'password':password,\n        'port':port,\n        'user':user,\n    }\n    fp = open('/tmp/datastore-test.json', 'w')\n    json.dump(config, fp)\n    fp.close()\n    try:\n        test_object = DatastoreConfig.from_config(config_file)\n        self.fail(\n            'DatastoreConfig.from_config should not '\n            'accept \"%s\" (%s) as a valid database config-'\n            'value, but it was allowed to create an '\n            'instance' % (database, type(database).__name__)\n        )\n    except (RuntimeError, TypeError, ValueError):\n        pass\n```", "```py\ndef test_get_connection(self):\n    # Tests the _get_connection method of the HMSMongoDataObject class\n    # - Test that lazy instantiation on a new instance returns the \n    #   class-attribute value (_connection)\n    test_object =  HMSMongoDataObjectDerived()\n    self.assertEqual(\n        test_object._get_connection(), \n        HMSMongoDataObjectDerived._connection\n    )\n    # - Test that deleting the current connection and re-aquiring it \n    #   works as expected\n    test_object._del_connection()\n    self.assertEqual(\n        test_object._get_connection(), \n        HMSMongoDataObjectDerived._connection\n    )\n    # - There may be more to test later, but this suffices for now...\n```", "```py\ndef setUp(self):\n    # - Since we need a database to test certain methods, \n    #   create one here\n    HMSMongoDataObject.configure(self.__class__.config)\n```", "```py\ndef tearDown(self):\n    # - delete the database after we're done with it, so that we \n    #   don't have data persisting that could bollix up subsequent \n    #   test-runs\n    from pymongo import MongoClient\n    client = MongoClient()\n    client.drop_database(self.__class__.config.database)\n```", "```py\n@unittest.skip(\n    'The fact that the configuration works in setUp is sufficient'\n)\ndef test_get_configuration(self):\n    # Tests the _get_configuration method of the HMSMongoDataObject class\n    # - Test all permutations of \"good\" argument-values:\n    # - Test all permutations of each \"bad\" argument-value \n    #   set against \"good\" values for the other arguments:\n    self.fail('test_get_configuration is not yet implemented')\n\n@unittest.skip(\n    'The fact that the configuration works in setUp is sufficient'\n)\ndef testconfigure(self):\n    # Tests the configure method of the HMSMongoDataObject class\n    self.fail('testconfigure is not yet implemented')\n```", "```py\nclass HMSMongoDataObjectDerived(HMSMongoDataObject):\n\n    _data_dict_keys = (\n        'name', 'description', 'cost', 'oid', 'created', 'modified', \n        'is_active', 'is_deleted'\n    )\n```", "```py\ndef __init__(self, name=None, description=None, cost=0, \n    oid=None, created=None, modified=None, is_active=None, \n    is_deleted=None, is_dirty=None, is_new=None\n  ):\n    HMSMongoDataObject.__init__(\n    self, oid, created, modified, is_active, is_deleted, \n    is_dirty, is_new\n  )\n    self.name = name\n    self.description = description\n    self.cost = cost\n\ndef to_data_dict(self):\n    return {\n         # - \"local\" properties\n         'name':self.name,\n         'description':self.description,\n         'cost':self.cost,\n         # - standard items from HMSMongoDataObject/BaseDataObject\n         'created':self.created.strftime(self.__class__._data_time_string),\n         'is_active':self.is_active,\n         'is_deleted':self.is_deleted,\n         'modified':self.modified.strftime(self.__class__._data_time_string),\n         'oid':str(self.oid),\n        }\n\ndef matches(self, **criteria):\n    return HMSMongoDataObject.matches(self, **criteria)\n```", "```py\ndef testdelete(self):\n    # Tests the delete method of the HMSMongoDataObject class\n    # - In order to really test get, we need some objects to test \n    #   against, so create a couple dozen:\n    names = ['Alice', 'Bob', 'Carl', 'Doug']\n    costs = [1, 2, 3]\n    descriptions = [None, 'Description']\n    all_oids = []\n    for name in names:\n        for description in descriptions:\n            for cost in costs:\n                item = HMSMongoDataObjectDerived(\n                    name=name, description=description, cost=cost\n                )\n                item.save()\n                all_oids.append(item.oid)\n```", "```py\n# - Delete varying-sized sets of items by oid, and verify that \n#   the deleted oids are gone afterwards...\nwhile all_oids:\n     try:\n        oids = all_oids[len(all_oids)/2:]\n        all_oids = [o for o in all_oids if o not in oids]\n     except:\n        oids = all_oids\n        all_oids = []\n     HMSMongoDataObjectDerived.delete(*oids)\n     items = HMSMongoDataObjectDerived.get(*oids)\n     self.assertEqual(len(items), 0)\n# - Verify that *no* items exist after they've all been deleted\nitems = HMSMongoDataObjectDerived.get()\nself.assertEqual(items, [])\n```", "```py\ndef testget(self):\n   # Tests the get method of the HMSMongoDataObject class\n   # - In order to really test get, we need some objects to test \n   #   against, so create a couple dozen:\n   names = ['Alice', 'Bob', 'Carl', 'Doug']\n   costs = [1, 2, 3]\n   descriptions = [None, 'Description']\n   for name in names:\n      for description in descriptions:\n         for cost in costs:\n             HMSMongoDataObjectDerived(\n                  name=name, description=description, cost=cost\n             ).save()\n```", "```py\n# - Now we should be able to try various permutations of get \n#   and get verifiable results. These tests will fail if the \n#   _data_dict_keys class-attribute isn't accurate...\nfor name in names:\n    criteria = {\n        'name':name,\n    }\n    items = HMSMongoDataObjectDerived.get(**criteria)\n    actual = len(items)\n    expected = len(costs) * len(descriptions)\n    self.assertEqual(actual, expected, \n        'Expected %d items returned (all matching name=\"%s\"), '\n        'but %d were returned' % \n        (expected, name, actual)\n    )\n    for item in items:\n        self.assertEqual(item.name, name)\n```", "```py\nfor cost in costs:\n    criteria = {\n         'name':name,\n         'cost':cost,\n    }\n    items = HMSMongoDataObjectDerived.get(**criteria)\n    actual = len(items)\n    expected = len(descriptions)\n    self.assertEqual(actual, expected, \n         'Expected %d items returned (all matching '\n         'name=\"%s\" and cost=%d), but %d were returned' % \n         (expected, name, cost, actual)\n   )\n   for item in items:\n       self.assertEqual(item.name, name)\n       self.assertEqual(item.cost, cost)\n```", "```py\n# - Noteworthy because save/get rather than save/pymongo-query.\n#   another option would be to do a \"real\" pymongo query, but that \n#   test-code would look like the code in get anyway...?\ndef testsave(self):\n   # Tests the save method of the HMSMongoDataObject class\n   # - Testing save without using get is somewhat cumbersome, and \n   #   perhaps too simple...?\n   test_object = HMSMongoDataObjectDerived()\n   test_object.save()\n   expected = test_object.to_data_dict()\n   results = HMSMongoDataObjectDerived.get(str(test_object.oid))\n   actual = results[0].to_data_dict()\n   self.assertEqual(actual, expected)\n```", "```py\n#!/usr/bin/env python\n\nimport sys\nsys.path.append('../standards')\nsys.path.append('tests/test_hms_core') # <-- This path\n```", "```py\nsetup(\n    name='HMS-Core',\n    version='0.1.dev0',\n    author='Brian D. Allbee',\n    description='',\n    package_dir={\n        '':'src',\n    },\n    packages=[\n        'hms_core',\n    ],\n    test_suite='tests.test_hms_core',\n)\n```", "```py\nHMSMongoDataObject.configure(\n    DatastoreConfig(database='demo_data')\n)\n\nprint('Creating data-objects to demo with')\nnames = ['Alice', 'Bob', 'Carl', 'Doug']\ncosts = [1, 2, 3]\ndescriptions = [None, 'Description']\nfor name in names:\n    for description in descriptions:\n        for cost in costs:\n            item = ExampleObject(\n                name=name, description=description, cost=cost\n            )\n            item.save()\n```"]