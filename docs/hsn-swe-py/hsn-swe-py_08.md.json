["```py\nclass Address:\n    \"\"\"\nRepresents a physical mailing-address/location\n\"\"\"\n    ###################################\n    # Class attributes/constants      #\n    ###################################\n\n# ... removed for brevity\n\n    ###################################\n    # Instance property definitions   #\n    ###################################\n\n    building_address = property(\n        _get_building_address, _set_building_address, \n        _del_building_address, \n        'Gets, sets or deletes the building_address (str|None) '\n        'of the instance'\n    )\n    city = property(\n        _get_city, _set_city, _del_city, \n        'Gets, sets or deletes the city (str) of the instance'\n    )\n    country = property(\n        _get_country, _set_country, _del_country, \n        'Gets, sets or deletes the country (str|None) of the '\n        'instance'\n    )\n    region = property(\n        _get_region, _set_region, _del_region, \n        'Gets, sets or deletes the region (str|None) of the '\n        'instance'\n    )\n    postal_code = property(\n        _get_postal_code, _set_postal_code, _del_postal_code, \n        'Gets, sets or deletes the postal_code (str|None) of '\n        'the instance'\n    )\n    street_address = property(\n        _get_street_address, _set_street_address, \n        _del_street_address, \n        'Gets, sets or deletes the street_address (str) of the '\n        'instance'\n    )\n```", "```py\n    ###################################\n    # Property-getter methods         #\n    ###################################\n\n    def _get_building_address(self) -> (str,None):\n        return self._building_address\n\n    def _get_city(self) -> str:\n        return self._city\n\n    def _get_country(self) -> (str,None):\n        return self._country\n\n    def _get_region(self) -> (str,None):\n        return self._region\n\n    def _get_postal_code(self) -> (str,None):\n        return self._postal_code\n\n    def _get_street_address(self) -> str:\n        return self._street_address\n```", "```py\n    def _set_street_address(self, value:str) -> None:\n        # - Type-check: This is a required str value\n        if type(value) != str:\n            raise TypeError(\n                '%s.street_address expects a single-line, '\n                'non-empty str value, with no whitespace '\n                'other than spaces, but was passed '\n                '\"%s\" (%s)' % \n                (\n                    self.__class__.__name__, value, \n                    type(value).__name__\n                )\n            )\n        # - Value-check: no whitespace other than \" \"\n        bad_chars = ('\\n', '\\r', '\\t')\n        is_valid = True\n        for bad_char in bad_chars:\n            if bad_char in value:\n                is_valid = False\n                break\n        # - If it's empty or otherwise not valid, raise error\n        if not value.strip() or not is_valid:\n            raise ValueError(\n                '%s.street_address expects a single-line, '\n                'non-empty str value, with no whitespace '\n                'other than spaces, but was passed '\n                '\"%s\" (%s)' % \n                (\n                    self.__class__.__name__, value, \n                    type(value).__name__\n                )\n            )\n        # - Everything checks out, so set the attribute\n        self._street_address = value\n```", "```py\n    def _set_building_address(self, value:(str,None)) -> None:\n        if value != None:\n            # - Type-check: If the value isn't None, then it has to \n            #   be a non-empty, single-line string without tabs\n            if type(value) != str:\n                raise TypeError(\n                    '%s.building_address expects a single-line, '\n                    'non-empty str value, with no whitespace '\n                    'other than spaces or None, but was passed '\n                    '\"%s\" (%s)' % \n                    (\n                        self.__class__.__name__, value, \n                        type(value).__name__\n                    )\n                )\n            # - Value-check: no whitespace other than \" \"\n            bad_chars = ('\\n', '\\r', '\\t')\n            is_valid = True\n            for bad_char in bad_chars:\n                if bad_char in value:\n                    is_valid = False\n                    break\n            # - If it's empty or otherwise not valid, raise error\n            if not value.strip() or not is_valid:\n                raise ValueError(\n                    '%s.building_address expects a single-line, '\n                    'non-empty str value, with no whitespace '\n                    'other than spaces or None, but was passed '\n                    '\"%s\" (%s)' % \n                    (\n                        self.__class__.__name__, value, \n                        type(value).__name__\n                    )\n                )\n            # - If this point is reached without error, then the \n            #   string-value is valid, so we can just exit the if\n        self._building_address = value\n```", "```py\n    def _del_building_address(self) -> None:\n        self._building_address = None\n\n    def _del_city(self) -> None:\n        self._city = None\n\n    def _del_country(self) -> None:\n        self._country = None\n\n    def _del_region(self) -> None:\n        self._region = None\n\n    def _del_postal_code(self) -> None:\n        self._postal_code = None\n\n    def _del_street_address(self) -> None:\n        self._street_address = None\n```", "```py\n    def __init__(self, \n        street_address,                  # 1234 Main Street\n        building_address,                # Apartment 3.14\n        city, region, postal_code,       # Some Town, ST, 00000\n        country                          # Country. Maybe.\n        ):\n```", "```py\n    def __init__(self, \n        street_address,                  # 1234 Main Street\n        city,                            # Some Town\n        building_address=None,           # Apartment 3.14\n        region=None, postal_code=None,   # ST, 00000\n        country=None                     # Country\n        ):\n```", "```py\n    @classmethod\n    def standard_address(cls, \n            street_address:(str,), building_address:(str,None), \n            city:(str,), region:(str,None), postal_code:(str,None), \n            country:(str,None)\n        ):\n        return cls(\n            street_address, city, building_address, \n            region, postal_code, country\n        )\n```", "```py\ndef __init__(self, \n    street_address:(str,), city:(str,), \n    building_address:(str,None)=None, region:(str,None)=None, \n    postal_code:(str,None)=None, country:(str,None)=None\n    ):\n    \"\"\"\nObject initialization.\n\nself .............. (Address instance, required) The instance to \n                    execute against\nstreet_address .... (str, required) The base street-address of the \n                    location the instance represents\ncity .............. (str, required) The city portion of the street-\n                    address that the instance represents\nbuilding_address .. (str, optional, defaults to None) The second \n                    line of the street address the instance represents, \n                    if applicable\nregion ............ (str, optional, defaults to None) The region \n                    (state, territory, etc.) portion of the street-\n                    address that the instance represents\npostal_code ....... (str, optional, defaults to None) The postal-code \n                    portion of the street-address that the instance \n                    represents\ncountry ........... (str, optional, defaults to None) The country \n                    portion of the street-address that the instance \n                    represents\n\"\"\"\n    # - Set default instance property-values using _del_... methods\n    self._del_building_address()\n    self._del_city()\n    self._del_country()\n    self._del_postal_code()\n    self._del_region()\n    self._del_street_address()\n    # - Set instance property-values from arguments using \n    #   _set_... methods\n    self._set_street_address(street_address)\n    self._set_city(city)\n    if building_address:\n        self._set_building_address(building_address)\n    if region:\n        self._set_region(region)\n    if postal_code:\n        self._set_postal_code(postal_code)\n    if country:\n        self._set_country(country)\n```", "```py\n# TODO: Consider whether Address needs some sort of #validation \n#       mechanism that can leverage pycountry to assure #that \n#       county/region combinations are kosher.\n#       pycountry.countries\u2014collection of countries\n#       pycountry.subdivisions\u2014collection of regions by #country\n# TODO: Maybe we need some sort of export-mechanism? Or a \n#       label-ready output?\n# TODO: Consider what can/should happen if a non-default #property-\n#       value is deleted in an instance. If a required #value is \n#       deleted, the instance is no longer well-formed...\nclass Address:\n    \"\"\"\n#Represents a physical mailing-address/location\n\"\"\"\n```", "```py\nclass Root:\n    def method(self, arg, *args, **kwargs):\n        print('Root.method(%s, %s, %s)' % (arg, str(args), kwargs))\n\nclass Left(Root):\n    def method(self, arg, *args, **kwargs):\n        print('Left.method(%s, %s, %s)' % (arg, str(args), kwargs))\n\nclass Right(Root):\n    def method(self, arg, *args, **kwargs):\n        print('Right.method(%s, %s, %s)' % (arg, str(args), kwargs))\n\nclass Bottom(Left, Right):\n    pass\n\nb = Bottom()\n```", "```py\nb.method('arg', 'args1', 'args2', keyword='value')\n```", "```py\n# Outputs \"Left.method(arg, ('args1', 'args2'), {'keyword': 'value'})\"\n```", "```py\nclass BaseArtisan(metaclass=abc.ABCMeta):\n    \"\"\"\nProvides baseline functionality, interface requirements, and \ntype-identity for objects that can represent an Artisan in \nthe context of the HMS system.\n\"\"\"\n```", "```py\n    ###################################\n    # Instance property definitions   #\n    ###################################\n\n    address = property(\n        _get_address, _set_address, _del_address, \n        'Gets, sets or deletes the physical address (Address) '\n        'associated with the Artisan that the instance represents'\n    )\n    company_name = property(\n        _get_company_name, _set_company_name, _del_company_name, \n        'Gets, sets or deletes the company name (str) associated '\n        'with the Artisan that the instance represents'\n    )\n    contact_email = property(\n        _get_contact_email, _set_contact_email, _del_contact_email, \n        'Gets, sets or deletes the email address (str) of the '\n        'named contact associated with the Artisan that the '\n        'instance represents'\n    )\n    contact_name = property(\n        _get_contact_name, _set_contact_name, _del_contact_name, \n        'Gets, sets or deletes the name of the contact (str) '\n        'associated with the Artisan that the instance represents'\n    )\n    products = property(\n        _get_products, None, None, \n        'Gets the collection of products (BaseProduct) associated '\n        'with the Artisan that the instance represents'\n    )\n    website = property(\n        _get_website, _set_website, _del_website, \n        'Gets, sets or deletes the URL of the website (str) '\n        'associated with the Artisan that the instance represents'\n    )\n```", "```py\n    def _get_address(self) -> (Address,):\n        return self._address\n\n    def _del_address(self) -> None:\n        self._address = None\n\n    def _get_company_name(self) -> (str,None):\n        return self._company_name\n\n    def _del_company_name(self) -> None:\n        self._company_name = None\n\n    def _get_contact_email(self) -> (str,None):\n        return self._contact_email\n\n    def _del_contact_email(self) -> None:\n        self._contact_email = None\n```", "```py\n    def _set_address(self, value:Address) -> None:\n        if not isinstance(value, Address):\n            raise TypeError(\n                '%s.address expects an Address object or an object '\n                'derived from Address, but was passed \"%s\" (%s) '\n                'instead, which is not.' %\n                (value, type(value).__name__)\n            )\n        self._address = value\n```", "```py\n#######################################\n# Standard library imports needed     #\n#######################################\n\nimport abc # This was already present\nimport re\n\nfrom email.utils import parseaddr\n```", "```py\nEMAIL_CHECK = re.compile(\n    r'(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$)'\n)\n```", "```py\n    def _set_contact_email(self, value:str) -> None:\n        # - Type-check: This is a required str value\n        if type(value) != str:\n            raise TypeError(\n                '%s.contact_email expects a str value that is a '\n                'well-formed email address, but was passed '\n                '\"%s\" (%s)' % \n                (\n                    self.__class__.__name__, value, \n                    type(value).__name__\n                )\n            )\n        # - Since we know it's a string, we can start by parsing value \n        #   with email.utils.parseaddr, and using the second item of \n        #   that result to check for well-formed-ness\n        check_value = parseaddr(value)[1]\n        # - If value is not empty, then there was *something* that was\n        #   recognized as being an email address\n        valid = (check_value != '')\n        if valid:\n            # - Try removing an entire well-formed email address, as \n            #   defined by EMAIL_CHECK, from the value. If it works, \n            #   there will either be a remnant or not. If there is \n            #   a remnant, it's considered badly-formed.\n            remnant = EMAIL_CHECK.sub('', check_value)\n            if remnant != '' or not value:\n                valid = False\n        if not check_value or not valid:\n            raise TypeError(\n                '%s.contact_email expects a str value that is a '\n                'well-formed email address, but was passed '\n                '\"%s\" (%s)' % \n                (\n                    self.__class__.__name__, value, \n                    type(value).__name__\n                )\n            )\n        self._contact_email = value\n```", "```py\nURL_CHECK = re.compile(\n    r'(^https?://[A-Za-z0-9][-_A-Za-z0-9]*\\.[A-Za-z0-9][-_A-Za-z0-9\\.]*$)'\n)\n```", "```py\n    def _set_website(self, value:(str,None)) -> None:\n        # - Type-check: This is an optional required str value\n        if value != None:\n            if type(value) != str:\n                raise TypeError(\n                    '%s.website expects a str value that is a '\n                    'well-formed URL, but was passed '\n                    '\"%s\" (%s)' % \n                    (\n                        self.__class__.__name__, value, \n                        type(value).__name__\n                    )\n                )\n            remnant = URL_CHECK.sub('', value)\n            if remnant != '' or not value:\n                raise TypeError(\n                    '%s.website expects a str value that is a '\n                    'well-formed URL, but was passed '\n                    '\"%s\" (%s)' % \n                    (\n                        self.__class__.__name__, value, \n                        type(value).__name__\n                    )\n                )\n        self._website = value\n```", "```py\n    products = property(\n        _get_products, None, None, \n        'Gets the collection of products (BaseProduct) associated '\n        'with the Artisan that the instance represents'\n    )\n```", "```py\n# Given artisan = Artisan(...whatever initialization\u2026)\nartisan.products = 'Not a product collection anymore!'\n```", "```py\nartisan.products.append('This is not a product!')\nartisan.products[0] = 'This is also not a product!'\n```", "```py\n# - Create a class to demonstrate with\nclass Example:\n    pass\n\n# -  Create a list of instances of the class\nexample_list = [\n    Example(), Example(), Example(), Example()\n]\n\nprint('Items in the original list (at %s):' % hex(id(example_list)))\nfor item in example_list:\n    print(item)\n\n# Items in the original list (at 0x7f9cd9ed6a48):\n# <__main__.Example object at 0x7f9cd9eed550>\n# <__main__.Example object at 0x7f9cd9eed5c0>\n# <__main__.Example object at 0x7f9cd9eed5f8>\n# <__main__.Example object at 0x7f9cd9eed630>\n```", "```py\nnew_list = list(example_list)\nprint('Items in the new list (at %s):' % hex(id(new_list)))\nfor item in new_list:\n    print(item)\n\n# Items in the new list (at 0x7f9cd89dca88):\n# <__main__.Example object at 0x7f9cd9eed550>\n# <__main__.Example object at 0x7f9cd9eed5c0>\n# <__main__.Example object at 0x7f9cd9eed5f8>\n# <__main__.Example object at 0x7f9cd9eed630>\n```", "```py\nnew_tuple = tuple(example_list)\nprint('Items in the new tuple (at %s):' % hex(id(new_tuple)))\nfor item in new_tuple:\n    print(item)\n\n# Items in the new tuple (at 0x7f9cd9edd4a8):\n# <__main__.Example object at 0x7f9cd9eed550>\n# <__main__.Example object at 0x7f9cd9eed5c0>\n# <__main__.Example object at 0x7f9cd9eed5f8>\n# <__main__.Example object at 0x7f9cd9eed630>\n```", "```py\ndef _get_products(self) -> (tuple,):\n  return tuple(self._products)\n```", "```py\ndef _del_products(self) -> None:\n  self._products = []\n```", "```py\n    def _set_products(self, value:(list, tuple)) -> None:\n        # - Check first that the value is an iterable - list or \n        #   tuple, it doesn't really matter which, just so long \n        #   as it's a sequence-type collection of some kind.\n        if type(value) not in (list, tuple):\n            raise TypeError(\n                '%s.products expects a list or tuple of BaseProduct '\n                'objects, but was passed a %s instead' % \n                (self.__class__.__name__, type(value).__name__)\n            )\n        # - Start with a new, empty list\n        new_items = []\n        # - Iterate over the items in value, check each one, and \n        #   append them if they're OK\n        bad_items = []\n        for item in value:\n            # - We're going to assume that all products will derive \n            #   from BaseProduct - that's why it's defined, after all\n            if isinstance(item, BaseProduct):\n                new_items.append(item)\n            else:\n                bad_items.append(item)\n        # - If there are any bad items, then do NOT commit the \n        #   changes -- raise an error instead!\n        if bad_items:\n            raise TypeError(\n                '%s.products expects a list or tuple of BaseProduct '\n                'objects, but the value passed included %d items '\n                'that are not of the right type: (%s)' % \n                (\n                    self.__class__.__name__, len(bad_items), \n                    ', '.join([str(bi) for bi in bad_items])\n                )\n            )\n        self._products = value\n```", "```py\n @abc.abstractmethod\n def add_product(self, product:BaseProduct):\n    pass\n\n @abc.abstractmethod\n def remove_product(self, product:BaseProduct):\n    pass\n```", "```py\n    @abc.abstractmethod\n    def add_product(self, product:BaseProduct):\n        \"\"\"\nAdds a product to the instance's collection of products.\n\nReturns the product added.\n\nself ....... (BaseArtisan instance, required) The instance to \n             execute against\nproduct ...  (BaseProduct, required) The product to add to the \n             instance's collection of products\n\nRaises TypeError if the product specified is not a BaseProduct-\n  derived instance\n\nMay be implemented in derived classes by simply calling\n    return BaseArtisan.add_product(self, product)\n\"\"\"\n        # - Make sure the product passed in is a BaseProduct\n        if not isinstance(product, BaseProduct):\n            raise TypeError(\n                '%s.add_product expects an instance of '\n                'BaseProduct to be passed in its product '\n                'argument, but \"%s\" (%s) was passed instead' % \n                (\n                    self.__class__.__name__, value, \n                    type(value).__name__\n                )\n            )\n        # - Append it to the internal _products list\n        self._products.append(product)\n        # - Return it\n        return product\n```", "```py\n    def add_product(self, product:BaseProduct):\n        # - Add any additional checking or processing that might \n        #   need to happen BEFORE adding the product here\n\n        # - Call the parent add_product to perform the actual \n        #   addition\n        result = BaseArtisan.add_product(self, product)\n\n        # - Add any additional checking or processing that might \n        #   need to happen AFTER adding the product here\n\n        # - Return the product\n        return result\n```", "```py\n    @abc.abstractmethod\n    def remove_product(self, product:BaseProduct):\n        \"\"\"\nRemoves a product from the instance's collection of products.\n\nReturns the product removed.\n\nself ....... (BaseArtisan instance, required) The instance to \n             execute against\nproduct ...  (BaseProduct, required) The product to remove from \n             the instance's collection of products\n\nRaises TypeError if the product specified is not a BaseProduct-\n  derived instance\nRaises ValueError if the product specified is not a member of the \n  instance's products collection\n\nMay be implemented in derived classes by simply calling\n    return BaseArtisan.remove_product(self, product)\n\"\"\"\n        # - Make sure the product passed in is a BaseProduct.\n        #   Technically this may not be necessary, since type \n        #   is enforced in add_product, but it does no harm to \n        #   re-check here...\n        if not isinstance(product, BaseProduct):\n            raise TypeError(\n                '%s.add_product expects an instance of '\n                'BaseProduct to be passed in its product '\n                'argument, but \"%s\" (%s) was passed instead' % \n                (\n                    self.__class__.__name__, value, \n                    type(value).__name__\n                )\n            )\n        try:\n            self._products.remove(product)\n            return product\n        except ValueError:\n            raise ValueError(\n                '%s.remove_product could not remove %s from its '\n                'products collection because it was not a member '\n                'of that collection' % \n                (self.__class__.__name__, product)\n            )\n```", "```py\n    def __init__(self, \n        contact_name:str, contact_email:str, \n        address:Address, company_name:str=None, \n        **products\n        ):\n        \"\"\"\nObject initialization.\n\nself .............. (BaseArtisan instance, required) The instance to \n                    execute against\ncontact_name ...... (str, required) The name of the primary contact \n                    for the Artisan that the instance represents\ncontact_email ..... (str [email address], required) The email address \n                    of the primary contact for the Artisan that the \n                    instance represents\naddress ........... (Address, required) The mailing/shipping address \n                    for the Artisan that the instance represents\ncompany_name ...... (str, optional, defaults to None) The company-\n                    name for the Artisan that the instance represents\nproducts .......... (BaseProduct collection) The products associated \n                    with the Artisan that the instance represents\n\"\"\"\n        # - Call parent initializers if needed\n        # - Set default instance property-values using _del_... methods\n        self._del_address()\n        self._del_company_name()\n        self._del_contact_email()\n        self._del_contact_name()\n        self._del_products()\n        # - Set instance property-values from arguments using \n        #   _set_... methods\n        self._set_contact_name(contact_name)\n        self._set_contact_email(contact_email)\n        self._set_address(address)\n        if company_name:\n            self._set_company_name(company_name)\n        if products:\n            self._set_products(products)\n        # - Perform any other initialization needed\n```", "```py\n    def __init__(self, \n        name:str, billing_address:Address, \n        shipping_address(Address,None)=None\n    ):\n        \"\"\"\nObject initialization.\n\nself .............. (BaseCustomer instance, required) The instance to \n                    execute against\nname .............. (str, required) The name of the customer.\nbilling_address ... (Address, required) The billing address of the \n                    customer\nshipping_address .. (Address, optional, defaults to None) The shipping \n                    address of the customer.\n\"\"\"\n        # - Call parent initializers if needed\n        # - Set default instance property-values using _del_... methods\n        self._del_billing_address()\n        self._del_name()\n        self._del_shipping_address()\n        # - Set instance property-values from arguments using \n        #   _set_... methods\n        self._set_name(name)\n        self._set_billing_address(billing_address)\n        if shipping_address:\n            self._set_shipping_address(shipping_address)\n        # - Perform any other initialization needed\n```", "```py\n# These lines aren't needed for description\n# - Value-check: no whitespace other than \" \"\nbad_chars = ('\\n', '\\r', '\\t')\nfor bad_char in bad_chars:\n    if bad_char in value:\n       is_valid = False\n       break\n```", "```py\ndef _set_shipping_weight(self, value:(int,)):\n  if type(value) != int:\n    raise TypeError(\n      '%s.shipping_weight expects a positive integer '\n      'value, but was passed \"%s\" (%s)' % \n      (\n         self.__class__.__name__, \n         value, type(value).__name__\n       )\n    )\n   if value <= 0:\n    raise ValueError(\n      '%s.shipping_weight expects a positive integer '\n       'value, but was passed \"%s\" (%s)' % \n       (\n          self.__class__.__name__, \n          value, type(value).__name__\n       )\n    )\n   self._shipping_weight = value\n```", "```py\ndef _set_available(self, value:(bool,int)):\n   if value not in (True, False, 1, 0):\n      raise ValueError(\n        '%s.available expects either a boolean value '\n         '(True|False) or a direct int-value equivalent '\n         '(1|0), but was passed \"%s\" (%s)' % \n          (self.__class__.__name__, value, type(value).__name__)\n          )\n   if value:\n      self._available = True\n        else:\n          self._available = False\n```", "```py\n    ###################################\n    # Property-getter methods         #\n    ###################################\n\n    # ... \n\n    def _get_metadata(self) -> (dict,):\n        return self._metadata\n\n    # ... \n\n    ###################################\n    # Property-deleter methods        #\n    ###################################\n\n    # ... \n\n    def _del_metadata(self) -> None:\n        self._metadata = {}\n```", "```py\n    ###################################\n    # Property-setter methods         #\n    ###################################\n# ... \n\ndef _set_metadata(self, value:(dict,)):\n if type(value) != dict:\n  raise TypeError(\n   '%s.metadata expects a dictionary of metadata keys '\n    '(strings) and values (also strings), but was passed '\n         '\"%s\" (%s)' % \n    (self.__class__.__name__, value, type(value).__name__)\n         )\n```", "```py\nbadvalues = []\nself._del_metadata()\n```", "```py\nif value: # Checking because value could be an empty dict: {}\n  for name in value:\n     try:\n       # - Since set_metadata will do all the type- and \n       #   value-checking we need, we'll just call that \n       #   for each item handed off to us here...\n           self.set_metadata(name, value[name])\n     except Exception:\n       # - If an error was raised,then we want to capture \n       #   the key/value pair that caused it...\n             badvalues.append((name, value[name]))\n```", "```py\nif badvalues:\n   # - Oops... Something's not right...\n    raise ValueError(\n      '%s.metadata expects a dictionary of metadata keys '\n      '(strings) and values, but was passed a dict with '\n      'values that aren\\'t allowed: %s' % \n         (self.__class__.__name__, str(badvalues))\n       )\n```", "```py\ndef set_metadata(self, key:(str,), value:(str,)):\n   \"\"\"\nSets the value of a specified metadata-key associated with the product \nthat the instance represents.\n\nself .............. (BaseProduct instance, required) The instance to \n                    execute against\nkey ............... (str, required) The metadata key to associate a \n                    value with\nvalue ............. (str, required) The value to associate with the \n                    metadata key\n\"\"\"\n```", "```py\nif type(key) != str:\n  raise TypeError(\n    '%s.metadata expects a single-line, '\n     'non-empty str key, with no whitespace '\n     'other than spaces, but was passed \"%s\" (%s)' % \n     (\n        self.__class__.__name__, key, \n        type(key).__name__\n      )\n    )\n   # - Value-check of key: no whitespace other than \" \"\n        bad_chars = ('\\n', '\\r', '\\t')\n        is_valid = True\n        for bad_char in bad_chars:\n            if bad_char in key:\n                is_valid = False\n                break\n   # - If it's empty or otherwise not valid, raise error\n    if not key.strip() or not is_valid:\n       raise ValueError(\n         '%s.metadata expects a single-line, '\n         'non-empty str key, with no whitespace '\n         'other than spaces, but was passed \"%s\" (%s)' % \n          (\n            self.__class__.__name__, key, \n            type(key).__name__\n          )\n       )\n```", "```py\nif type(value) != str:\n  raise TypeError(\n    '%s.metadata expects a single-line, '\n    'non-empty str value, with no whitespace '\n    'other than spaces, but was passed \"%s\" (%s)' % \n    (\n       self.__class__.__name__, value, \n       type(value).__name__\n    )\n  )\n  # - Value-check of value: no whitespace other than \" \"\n     bad_chars = ('\\n', '\\r', '\\t')\n     is_valid = True\n     for bad_char in bad_chars:\n        if bad_char in value:\n          is_valid = False\n          break\n  # - If it's empty or otherwise not valid, raise error\n      if not value.strip() or not is_valid:\n        raise ValueError(\n          '%s.metadata expects a single-line, '\n          'non-empty str value, with no whitespace '\n          'other than spaces, but was passed \"%s\" (%s)' % \n            (\n               self.__class__.__name__, value, \n               type(value).__name__\n            )\n         )\n     self._metadata[key] = value\n```", "```py\ndef remove_metadata(self, key):\n        \"\"\"\nRemoves the specified metadata associated with the product that the \ninstance represents, identified by the key\n\nself .............. (BaseProduct instance, required) The instance to \n                    execute against\nkey ............... (str, required) The key that identifies the \n                    metadata value to remove\n\"\"\"\n        try:\n            del self._metadata[key]\n        except KeyError:\n            pass\n```", "```py\nclass HasProducts(metaclass=abc.ABCMeta):\n    \"\"\"\nProvides baseline functionality, interface requirements, and \ntype-identity for objects that can have a common products \nproperty whose membership is stored and handled in the same \nway.\n\"\"\"\n```", "```py\n###################################\n# Property-getter methods         #\n###################################\n\ndef _get_products(self) -> (tuple,):\n   return tuple(self._products)\n\n###################################\n# Property-setter methods         #\n###################################\n\ndef _set_products(self, value:(list, tuple)) -> None:\n# - Check first that the value is an iterable - list or \n#   tuple, it doesn't really matter which, just so long \n#   as it's a sequence-type collection of some kind.\n\n if type(value) not in (list, tuple):\n   raise TypeError(\n     '%s.products expects a list or tuple of BaseProduct '\n     'objects, but was passed a %s instead' % \n     (self.__class__.__name__, type(value).__name__)\n            )\n  # - Start with a new, empty list\n  new_items = []\n  # - Iterate over the items in value, check each one, and \n  #   append them if they're OK\n bad_items = []\nfor item in value:\n # - We're going to assume that all products will derive \n #   from BaseProduct - That's why it's defined, after all\n      if isinstance(item, BaseProduct):\n         new_items.append(item)\n      else:\n         bad_items.append(item)\n # - If there are any bad items, then do NOT commit the \n #   changes -- raise an error instead!\n     if bad_items:\n      raise TypeError(\n      '%s.products expects a list or tuple of BaseProduct'\n      'objects, but the value passed included %d items '\n      'that are not of the right type: (%s)' % \n      (\n         self.__class__.__name__, len(bad_items), \n         ', '.join([str(bi) for bi in bad_items])\n      )\n   )\n   self._products = value\n\n###################################\n# Property-deleter methods        #\n###################################\n\n  def _del_products(self) -> None:\n    self._products = []\n```", "```py\n###################################\n# Instance property definitions   #\n###################################\n\nproducts = property(\n_get_products, None, None,\n'Gets the products (BaseProduct) of the instance'\n)\n```", "```py\n###################################\n# Object initialization           #\n###################################\n\ndef __init__(self, *products):\n        \"\"\"\nObject initialization.\n\nself .............. (HasProducts instance, required) The instance to \n                    execute against\nproducts .......... (list or tuple of BaseProduct instances) The \n                    products that were ordered\n\"\"\"\n        # - Call parent initializers if needed\n        # - Set default instance property-values using _del_... methods\n        self._del_products()\n        # - Set instance property-values from arguments using \n        #   _set_... methods\n        if products:\n            self._set_products(products)\n        # - Perform any other initialization needed\n\n###################################\n# Abstract methods                #\n###################################\n```", "```py\n    @abc.abstractmethod\n    def add_product(self, product:BaseProduct) -> BaseProduct:\n        \"\"\"\nAdds a product to the instance's collection of products.\n\nReturns the product added.\n\nself ....... (HasProducts instance, required) The instance to \n             execute against\nproduct ...  (BaseProduct, required) The product to add to the \n             instance's collection of products\n\nRaises TypeError if the product specified is not a BaseProduct-\n  derived instance\n\nMay be implemented in derived classes by simply calling\n    return HasProducts.add_product(self, product)\n\"\"\"\n        # - Make sure the product passed in is a BaseProduct\n        if not isinstance(product, BaseProduct):\n            raise TypeError(\n                '%s.add_product expects an instance of '\n                'BaseProduct to be passed in its product '\n                'argument, but \"%s\" (%s) was passed instead' % \n                (\n                    self.__class__.__name__, value, \n                    type(value).__name__\n                )\n            )\n        # - Append it to the internal _products list\n        self._products.append(product)\n        # - Return it\n        return product\n\n    @abc.abstractmethod\n    def remove_product(self, product:BaseProduct):\n        \"\"\"\nRemoves a product from the instance's collection of products.\n\nReturns the product removed.\n\nself ....... (HasProducts instance, required) The instance to \n             execute against\nproduct ...  (BaseProduct, required) The product to remove from \n             the instance's collection of products\n\nRaises TypeError if the product specified is not a BaseProduct-\n  derived instance\nRaises ValueError if the product specified is not a member of the \n  instance's products collection\n\nMay be implemented in derived classes by simply calling\n    return HasProducts.remove_product(self, product)\n\"\"\"\n        # - Make sure the product passed in is a BaseProduct.\n        #   Technically this may not be necessary, since type \n        #   is enforced in add_product, but it does no harm to \n        #   re-check here...\n        if not isinstance(product, BaseProduct):\n            raise TypeError(\n                '%s.add_product expects an instance of '\n                'BaseProduct to be passed in its product '\n                'argument, but \"%s\" (%s) was passed instead' % \n                (\n                    self.__class__.__name__, value, \n                    type(value).__name__\n                )\n            )\n        try:\n            self._products.remove(product)\n            return product\n        except ValueError:\n            raise ValueError(\n                '%s.remove_product could not remove %s from its '\n                'products collection because it was not a member '\n                'of that collection' % \n                (self.__class__.__name__, product)\n            )\n```", "```py\nclass BaseArtisan(HasProducts, metaclass=abc.ABCMeta):\n    \"\"\"\nProvides baseline functionality, interface requirements, and \ntype-identity for objects that can represent an Artisan in \nthe context of the HMS system.\n\"\"\"\n```", "```py\ndef __init__(self, \n  contact_name:str, contact_email:str, \n  address:Address, company_name:str=None, \n  **products\n  ):\n    \"\"\"\nObject initialization.\n\"\"\"\n   # - Call parent initializers if needed\n# This is all that's needed to perform the initialization defined \n# in HasProducts\n        HasProducts.__init__(self, *products)\n```", "```py\n        # - Set default instance property-values using _del_... methods\n        self._del_address()\n        self._del_company_name()\n        self._del_contact_email()\n        self._del_contact_name()\n# This can be deleted, or just commented out.\n#        self._del_products()\n     # - Set instance property-values from arguments using \n        #   _set_... methods\n        self._set_contact_name(contact_name)\n        self._set_contact_email(contact_email)\n        self._set_address(address)\n        if company_name:\n            self._set_company_name(company_name)\n# This also can be deleted, or just commented out.\n#        if products:\n#            self._set_products(products)\n```", "```py\n# This also can be deleted, or just commented out.\n#    products = property(\n#         _get_products, None, None,\n#         'Gets the products (BaseProduct) of the instance'\n#    )\n```"]