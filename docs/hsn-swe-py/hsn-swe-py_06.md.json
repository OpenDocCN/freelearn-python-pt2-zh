["```py\n#!/usr/bin/env python\n\"\"\"\nTODO: Document the module.\nProvides classes and functionality for SOME_PURPOSE\n\"\"\"\n\n#######################################\n# Any needed from __future__ imports  #\n# Create an \"__all__\" list to support #\n#   \"from module import member\" use   #\n#######################################\n\n__all__ = [\n    # Constants\n    # Exceptions\n    # Functions\n    # ABC \"interface\" classes\n    # ABC abstract classes\n    # Concrete classes\n]\n\n#######################################\n# Module metadata/dunder-names        #\n#######################################\n\n__author__ = 'Brian D. Allbee'\n__copyright__ = 'Copyright 2018, all rights reserved'\n__status__ = 'Development'\n\n#######################################\n# Standard library imports needed     #\n#######################################\n\n# Uncomment this if there are abstract classes or \"interfaces\" \n#   defined in the module...\n# import abc\n\n#######################################\n# Third-party imports needed          #\n#######################################\n\n#######################################\n# Local imports needed                #\n#######################################\n\n#######################################\n# Initialization needed before member #\n#   definition can take place         #\n#######################################\n\n#######################################\n# Module-level Constants              #\n#######################################\n\n#######################################\n# Custom Exceptions                   #\n#######################################\n\n#######################################\n# Module functions                    #\n#######################################\n\n#######################################\n# ABC \"interface\" classes             #\n#######################################\n\n#######################################\n# Abstract classes                    #\n#######################################\n\n#######################################\n# Concrete classes                    #\n#######################################\n\n#######################################\n# Initialization needed after member  #\n#   definition is complete            #\n#######################################\n\n#######################################\n# Imports needed after member         #\n#   definition (to resolve circular   #\n#   dependencies - avoid if at all    #\n#   possible                          #\n#######################################\n\n#######################################\n# Code to execute if the module is    #\n#   called directly                   #\n#######################################\n\nif __name__ == '__main__':\n    pass\n```", "```py\n#!/usr/bin/env python\n\"\"\"\nTODO: Document the package.\nPackage-header for the PACKAGE_NAMESPACE namespace. \nProvides classes and functionality for SOME_PURPOSE \"\"\"\n\n#######################################\n# Any needed from __future__ imports  #\n# Create an \"__all__\" list to support #\n#   \"from module import member\" use   #\n#######################################\n\n__all__ = [\n    # Constants\n    # Exceptions\n    # Functions\n    # ABC \"interface\" classes\n    # ABC abstract classes\n    # Concrete classes\n # Child packages and modules ]\n\n#######################################\n# Module metadata/dunder-names        #\n#######################################\n\n# ...the balance of the template-file is as shown above...\n```", "```py\n# Blank line in the template, helps with PEP-8's space-before-and-after rule\nclass ClassName:\n    \"\"\"TODO: Document the class.\nRepresents a WHATEVER\n\"\"\"\n    ###################################\n    # Class attributes/constants      #\n    ###################################\n\n    ###################################\n    # Property-getter methods         #\n    ###################################\n\n#     def _get_property_name(self) -> str:\n#         return self._property_name\n\n    ###################################\n    # Property-setter methods         #\n    ###################################\n\n#     def _set_property_name(self, value:str) -> None:\n#         # TODO: Type- and/or value-check the value argument of the \n#         #       setter-method, unless it's deemed unnecessary.\n#         self._property_name = value\n\n    ###################################\n    # Property-deleter methods        #\n    ###################################\n\n#     def _del_property_name(self) -> None:\n#         self._property_name = None\n\n    ###################################\n    # Instance property definitions   #\n    ###################################\n\n#     property_name = property(\n#         # TODO: Remove setter and deleter if access is not needed\n#         _get_property_name, _set_property_name, _del_property_name, \n#         'Gets, sets or deletes the property_name (str) of the instance'\n#     )\n\n    ###################################\n    # Object initialization           #\n    ###################################\n\n    # TODO: Add and document arguments if/as needed\n    def __init__(self):\n        \"\"\"\nObject initialization.\n\nself .............. (ClassName instance, required) The instance to \n                    execute against\n\"\"\"\n        # - Call parent initializers if needed\n        # - Set default instance property-values using _del_... methods\n        # - Set instance property-values from arguments using \n        #   _set_... methods\n        # - Perform any other initialization needed\n        pass # Remove this line \n\n    ###################################\n    # Object deletion                 #\n    ###################################\n\n    ###################################\n    # Instance methods                #\n    ###################################\n\n#     def instance_method(self, arg:str, *args, **kwargs):\n#         \"\"\"TODO: Document method\n# DOES_WHATEVER\n# \n# self .............. (ClassName instance, required) The instance to \n#                     execute against\n# arg ............... (str, required) The string argument\n# *args ............. (object*, optional) The arglist\n# **kwargs .......... (dict, optional) keyword-args, accepts:\n#  - kwd_arg ........ (type, optional, defaults to SOMETHING) The SOMETHING \n#                     to apply\n# \"\"\"\n#         pass\n\n    ###################################\n    # Overrides of built-in methods   #\n    ###################################\n\n    ###################################\n    # Class methods                   #\n    ###################################\n\n    ###################################\n    # Static methods                  #\n    ###################################\n# Blank line in the template, helps with PEP-8's space-before-and-after rule\n```", "```py\n# Remember to import abc!\n# Blank line in the template, helps with PEP-8's space-before-and-after rule\nclass AbstractClassName(metaclass=abc.ABCMeta):\n    \"\"\"TODO: Document the class.\nProvides baseline functionality, interface requirements, and \ntype-identity for objects that can REPRESENT_SOMETHING\n\"\"\"\n    ###################################\n    # Class attributes/constants      #\n    ###################################\n\n    # ... Identical to above ...\n\n    ###################################\n    # Instance property definitions   #\n    ###################################\n\n#     abstract_property = abc.abstractproperty()\n\n#     property_name = property(\n\n    # ... Identical to above ...\n\n    ###################################\n    # Abstract methods                #\n    ###################################\n\n#     @abc.abstractmethod\n#     def instance_method(self, arg:str, *args, **kwargs):\n#         \"\"\"TODO: Document method\n# DOES_WHATEVER\n# \n# self .............. (AbstractClassName instance, required) The \n#                     instance to execute against\n# arg ............... (str, required) The string argument\n# *args ............. (object*, optional) The arglist\n# **kwargs .......... (dict, optional) keyword-args, accepts:\n#  - kwd_arg ........ (type, optional, defaults to SOMETHING) The SOMETHING \n#                     to apply\n# \"\"\"\n#         pass\n\n    ###################################\n    # Instance methods                #\n    ###################################\n\n    # ... Identical to above ...\n\n    ###################################\n    # Static methods                  #\n    ###################################\n# Blank line in the template, helps with PEP-8's space-before-and-after rule\n```", "```py\n# Remember to import abc!\n# Blank line in the template, helps with PEP-8's space-before-and-after rule\nclass InterfaceName(metaclass=abc.ABCMeta):\n    \"\"\"TODO: Document the class.\nProvides interface requirements, and type-identity for objects that \ncan REPRESENT_SOMETHING\n\"\"\"\n    ###################################\n    # Class attributes/constants      #\n    ###################################\n\n    ###################################\n    # Instance property definitions   #\n    ###################################\n\n#     abstract_property = abc.abstractproperty()\n\n    ###################################\n    # Object initialization           #\n    ###################################\n\n    # TODO: Add and document arguments if/as needed\n    def __init__(self):\n        \"\"\"\nObject initialization.\n\nself .............. (InterfaceName instance, required) The instance to \n                    execute against\n\"\"\"\n        # - Call parent initializers if needed\n        # - Perform any other initialization needed\n        pass # Remove this line \n\n    ###################################\n    # Object deletion                 #\n    ###################################\n\n    ###################################\n    # Abstract methods                #\n    ###################################\n\n#     @abc.abstractmethod\n#     def instance_method(self, arg:str, *args, **kwargs):\n#         \"\"\"TODO: Document method\n# DOES_WHATEVER\n# \n# self .............. (InterfaceName instance, required) The \n#                     instance to execute against\n# arg ............... (str, required) The string argument\n# *args ............. (object*, optional) The arglist\n# **kwargs .......... (dict, optional) keyword-args, accepts:\n#  - kwd_arg ........ (type, optional, defaults to SOMETHING) The SOMETHING \n#                     to apply\n# \"\"\"\n#         pass\n\n    ###################################\n    # Class methods                   #\n    ###################################\n\n    ###################################\n    # Static methods                  #\n    ###################################\n# Blank line in the template, helps with PEP-8's space-before-and-after rule\n```", "```py\ndef _get_property_name(self) -> str:\n\ndef _set_property_name(self, value:str) -> None:\n\ndef _del_property_name(self) -> None:\n\ndef instance_method(self, arg:str, *args, **kwargs):\n```", "```py\ndef my_function(name, price, description=None):\n    \"\"\"\nA fairly standard Python function that accepts name, description and \nprice values, formats them, and returns that value.\n\"\"\"\n    result = \"\"\"\nname .......... %s\ndescription ... %s\nprice ......... %0.2f\n\"\"\" % (name, description, price)\n    return result\n\nif __name__ == '__main__':\n    print(\n        my_function(\n            'Product #1', 12.95, 'Description of the product'\n        )\n    )\n    print(\n        my_function(\n            'Product #2', 10\n        )\n    )\n```", "```py\ndef my_function(name:str, price:(float,int), description:(str,None)=None) -> str:\n    \"\"\"\nA fairly standard Python function that accepts name, description and \nprice values, formats them, and returns that value.\n\"\"\"\n    result = \"\"\"\nname .......... %s\ndescription ... %s\nprice ......... %0.2f\n\"\"\" % (name, description, price)\n    return result\n\nif __name__ == '__main__':\n    print(\n        my_function(\n            'Product #1', 12.95, 'Description of the product'\n        )\n    )\n    print(\n        my_function(\n            'Product #2', 10\n        )\n    )\n\n # - Print the __annotations__ of my_function\n    print(my_function.__annotations__)\n```", "```py\nmy_function(name:str, price:(float,int), description:(str,None)=None) -> str:\n```", "```py\n# - Generate a list of good values that should all pass for:\n#   * name\ngood_names = [\n    'Product', \n    'A Very Long Product Name That is Not Realistic, '\n        'But Is Still Allowable',\n    'None',  # NOT the actual None value, a string that says \"None\"\n]\n#   * price\ngood_prices = [\n    0, 0.0, # Free is legal, if unusual.\n    1, 1.0, \n    12.95, 13, \n]\n#   * description\ngood_descriptions = [\n    None, # Allowed, since it's the default value\n    '', # We'll assume empty is OK, since None is OK.\n    'Description',\n    'A long description. '*20,\n    'A multi-line\\n\\n description.'\n]\n```", "```py\n# - Test all possible good combinations:\ntest_count = 0\ntests_passed = 0\nfor name in good_names:\n    for price in good_prices:\n        for description in good_descriptions:\n            test_count += 1\n            try:\n                ignore_me = my_function(name, price, description)\n                tests_passed += 1\n            except Exception as error:\n                print(\n                    '%s raised calling my_function(%s, %s, %s)' % \n                    (error.__class__.__name__, name, price, description)\n                )\nif tests_passed == test_count:\n    print('All %d tests passed' % (test_count))\n```", "```py\n# - Generate a list of bad values that should all raise errors for:\n#   * name\nbad_names = [\n   None, -1, -1.0, True, False, object()\n]\n#   * price\nbad_prices = [\n    'string value', '', \n    None, \n    -1, -1.0, \n    -12.95, -13, \n]\n#   * description\nbad_description = [\n   -1, -1.0, True, False, object()\n]\n\n# ...\n\nfor name in bad_names:\n    try:\n        test_count += 1\n        ignore_me = my_function(name, good_price, good_description)\n        # Since these SHOULD fail, if we get here and it doesn't, \n        # we raise an error to be caught later...\n        raise RuntimeError()\n    except (TypeError, ValueError) as error:\n        # If we encounter either of these error-types, that's what \n        # we'd expect: The type is wrong, or the value is invalid...\n        tests_passed += 1\n    except Exception as error:\n        # Any OTHER error-type is a problem, so report it\n        print(\n            '%s raised calling my_function(%s, %s, %s)' % \n            (error.__class__.__name__, name, good_price, good_description)\n        )\n```", "```py\nfor price in bad_prices:\n    try:\n        test_count += 1\n        ignore_me = my_function(good_name, price, good_description)\n        # Since these SHOULD fail, if we get here and it doesn't, \n        # we raise an error to be caught later...\n        raise RuntimeError()\n    except (TypeError, ValueError) as error:\n        # If we encounter either of these error-types, that's what \n        # we'd expect: The type is wrong, or the value is invalid...\n        tests_passed += 1\n    except Exception as error:\n        # Any OTHER error-type is a problem, so report it\n        print(\n            '%s raised calling my_function(%s, %s, %s)' % \n            (error.__class__.__name__, good_name, price, good_description)\n        )\n\nfor description in bad_descriptions:\n    try:\n        test_count += 1\n        ignore_me = my_function(good_name, good_price, description)\n        # Since these SHOULD fail, if we get here and it doesn't, \n        # we raise an error to be caught later...\n        raise RuntimeError()\n    except (TypeError, ValueError) as error:\n        # If we encounter either of these error-types, that's what \n        # we'd expect: The type is wrong, or the value is invalid...\n        tests_passed += 1\n    except Exception as error:\n        # Any OTHER error-type is a problem, so report it\n        print(\n            '%s raised calling my_function(%s, %s, %s)' % \n            (error.__class__.__name__, good_name, good_price, description)\n        )\n```", "```py\n###################################\n# Property-getter methods         #\n###################################\n\ndef _get_property_name(self) -> str:\n    return self._property_name\n\n###################################\n# Property-setter methods         #\n###################################\n\ndef _set_property_name(self, value:(str, None)) -> None:\n    if value is not None and type(value) is not str:\n        raise TypeError(\n            '%s.property_name expects a string or None '\n            'value, but was passed \"%s\" (%s)' % (\n                self.__class__.__name__, value, \n                type(value).__name__\n            )\n        )\n    self._property_name = value\n\n###################################\n# Property-deleter methods        #\n###################################\n\ndef _del_property_name(self) -> None:\n    self._property_name = None\n\n###################################\n# Instance property definitions   #\n###################################\n\nproperty_name = property(\n    _get_property_name, _set_property_name, _del_property_name, \n    'Gets, sets or deletes the property_name (str|None) of the instance'\n)\n```", "```py\n#!/usr/bin/env python\n\"\"\"\nexample_setup.py\n\nA bare-bones setup.py example, showing all the arguments that are \nlikely to be needed for most build-/packaging-processes\n\"\"\"\n\nfrom setuptools import setup\n\n# The actual setup function call:\nsetup(\n    name='',\n    version='',\n    author='',\n    description='',\n    long_description='',\n    author_email='',\n    url='',\n    install_requires=[\n        'package~=version',\n        # ...\n    ],\n    package_dir={\n        'package_name':'project_root_directory',\n        # ...\n    },\n    # Can also be automatically generated using \n    #     setuptools.find_packages...\n    packages=[\n        'package_name',\n        # ...\n    ],\n    package_data={\n        'package_name':[\n            'file_name.ext',\n            # ...\n        ]\n    },\n    entry_points={\n        'console_scripts':[\n            'script_name = package.module:function',\n            # ...\n        ],\n    },\n)\n```", "```py\n# An example Makefile\n\nmain: test setup\n        # Doesn't (yet) do anything other than running the test and \n        # setup targets\n\nsetup:\n        # Calls the main setup.py to build a source-distribution\n        # python setup.py sdist\n\ntest:\n        # Executes the unit-tests for the package, allowing the build-\n        # process to die and stop the build if a test fails\n```", "```py\npython3 -m venv ~/py_envs/example_ve\n```", "```py\nsource ~/py_envs/example_ve/bin/activate\n```", "```py\ndeactivate\n```", "```py\nsource ~/py_envs/example_ve/bin/activate\n```", "```py\npip freeze\n```", "```py\npip install \u2013upgrade pip\n```", "```py\npip install pillow\n```", "```py\npip install -r requirements.txt\n```", "```py\npip uninstall pillow\n```"]