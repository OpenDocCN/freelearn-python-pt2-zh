["```py\nclass testBaseDaemon(unittest.TestCase):\n\n# ...\n\n    @classmethod\n    def setUpClass(cls):\n        # - Create a basic config-file that can be used to create\n        #   instances of BaseDaemonDerived.\n        config_data = \"\"\"logging:\n  format: \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n  name: example\n  console:\n    level: info\n  file:\n    level: debug\n    logfile: \"/tmp/example.log\"\n\"\"\"\n        cls._config_file = 'example.config'\n        with open(cls._config_file, 'w') as fp:\n            fp.write(config_data)\n\n    @classmethod\n    def tearDownClass(cls):\n        try:\n            os.unlink(cls._config_file)\n        except:\n            pass\n```", "```py\n    def testmethod(self):\n        # Tests the method method of the BaseDaemon class\n        test_object = BaseDaemonDerived(self._config_file)\n        # - Whatever assertions and other test-processes are needed...\n```", "```py\n#!/usr/bin/env python\n\"\"\"\nDefines end-to-end process-tests for the ArtisanGatewayDaemon\n\"\"\"\n\n#######################################\n# Standard library imports needed     #\n#######################################\n\nimport os\nimport sys\nimport unittest\n```", "```py\n#######################################\n# Local imports needed                #\n#######################################\n\nfrom idic.unit_testing import PrintTestResults, SaveTestReport\n```", "```py\n#######################################\n# Module-level Constants              #\n#######################################\n\nLocalSuite = unittest.TestSuite()\n\n#######################################\n# Imports needed for testing          #\n#######################################\n\nfrom hms_Gateway.daemons import ArtisanGatewayDaemon\n```", "```py\n#######################################\n# Test-cases in the module            #\n#######################################\n\nclass testArtisanProcesses(unittest.TestCase):\n\n    def testArtisanCreateFromCO(self):\n        self.fail('testArtisanCreateFromCO is not yet implemented')\n\n    def testArtisanUpdateFromCO(self):\n        self.fail('testArtisanUpdateFromCO is not yet implemented')\n\n    def testArtisanUpdateFromArtisan(self):\n        self.fail('testArtisanUpdateFromArtisan is not yet implemented')\n```", "```py\n    def testArtisanDeleteFromCO(self):\n        self.fail('testArtisanDeleteFromCO is not yet implemented')\n```", "```py\nLocalSuite.addTests(\n    unittest.TestLoader().loadTestsFromTestCase(\n        testArtisanProcesses\n    )\n)\n```", "```py\n#######################################\n# Code to execute if file is called   #\n# or run directly.                    #\n#######################################\n\nif __name__ == '__main__':\n    import time\n    results = unittest.TestResult()\n    testStartTime = time.time()\n    LocalSuite.run(results)\n    results.runTime = time.time() - testStartTime\n    PrintTestResults(results)\n    if not results.errors and not results.failures:\n        SaveTestReport(results, 'hms_Gateway.ModuleName',\n            'hms_Gateway.EndToEndProcesses.test-results')\n```", "```py\nclass NeedsArtisanGateway:\n\n    @classmethod\n    def setUpClass(cls):\n        \"\"\"\nCreates and starts an instance of the ArtisanGatewayDaemon that \ncan be used during execution of the tests.\n\"\"\"\n```", "```py\n        cls.Gateway_signing_key = os.urandom(64).hex()\n        cls.Gateway_queue_id = 'hms_ag_%s_process_test' % cls.queue_name\n        cls.Gateway_config_file = 'process_test.config'\n```", "```py\n        cls.Gateway_config_data=\"\"\"# Logging configuration\nlogging:\n  format: \"%%(asctime)s - %%(name)s - %%(levelname)s - %%(message)s\"\n  name: hms_ag_process_test\n  file:\n    level: debug\n    logfile: \"/tmp/hms_ag_process_test.log\"\nqueue:\n  type: rabbit\n  connection:\n    host: localhost\n    port: 5672\n    path: /\n  queue_name: \"%s\"\nsigning_key: \"%s\"\n\"\"\" % (cls.Gateway_queue_id, cls.Gateway_signing_key)\n```", "```py\nwith open(cls.Gateway_config_file, 'w') as fp:\n    fp.write(cls.Gateway_config_data)\n```", "```py\ncls.Gateway = ArtisanGatewayDaemon(cls.Gateway_config_file)\n```", "```py\ncls.Gateway_process = Process(target=cls.Gateway.start, daemon=True)\ncls.Gateway_process.start()\n```", "```py\n    @classmethod\n    def tearDownClass(cls):\n        # - Stop the service-instance\n        cls.Gateway_process.terminate()\n        # - Clean up (delete) the temp. config-file\n        os.unlink(cls.Gateway_config_file)\n        # - Add a short delay to allow the process-termination time \n        #   to complete before proceeding with the next item...\n        time.sleep(1)\n```", "```py\nclass testArtisanProcesses(NeedsArtisanGateway, unittest.TestCase):\n```", "```py\nqueue_name = 'artisan'\n```", "```py\ndef testArtisanCreateFromCO(self):\n    self.fail('testArtisanCreateFromCO is not yet implemented')\n\n# ...\n```", "```py\nfrom hms_core.data_storage import DatastoreConfig, HMSMongoDataObject\n\nconfig = DatastoreConfig(\n    database='hms_proc_tests',\n)\nHMSMongoDataObject.configure(config)\n```", "```py\nfrom hms_core.messaging import DaemonMessage, RabbitMQSender, \\\n    MESSAGE_ORIGINS\nRabbitMQSender.configure(\n    'hms_ag_process_test', 'localhost', 5672, '/'\n)\n```", "```py\nMESSAGE_ORIGINS = namedtuple(\n    'MESSAGE_ORIGINS', ['artisan', 'central_office']\n)(\n    artisan='artisan',\n    central_office='central-office',\n)\n```", "```py\nfrom hms_core.co_objects import Artisan as COArtisan\nfrom hms_artisan.artisan_objects import Artisan as ARArtisan\n```", "```py\ndef testArtisanCreateFromCO(self):\n    sender = RabbitMQSender()\n```", "```py\n    parameters = {\n        'contact_name':'contact-name',\n        'contact_email':'no-one@me.co',\n        'address':{\n            'street_address':'street-address',\n            'city':'city',\n        },\n        'queue_id':self.Gateway_queue_id,\n        'signing_key':self.Gateway_signing_key,\n    }\n    new_artisan = COArtisan.from_data_dict(parameters)\n```", "```py\n    message = DaemonMessage(\n        operation='create', \n        origin=MESSAGE_ORIGINS.central_office,\n        data={\n            'target':'artisan',\n            'properties':new_artisan.to_message_data(),\n        },\n        signing_key=self.Gateway_signing_key\n    )\n    sender.send_message(message, self.Gateway_queue_id)\n```", "```py\ntime.sleep(5)\n```", "```py\n    try:\n        verify_artisan = COArtisan.get(str(new_artisan.oid))[0]\n    except IndexError:\n        self.fail(\n            'Although the new artisan (oid: %s) was created, '\n            'it could not be retrieved' % (new_artisan.oid)\n        )\n```", "```py\n    self.assertEquals(\n        verify_artisan.to_data_dict(), new_artisan.to_data_dict()\n    )\n```", "```py\n    COArtisan.delete(str(new_artisan.oid))\n```", "```py\nunauthorized_message_data = message.to_message_dict()\nunauthorized_message_data['data']['properties']['website'] = \\\n    'http://some-bogus-website.com'\n```", "```py\nsender.channel.basic_publish(\n    exchange='', routing_key=self.Gateway_queue_id, \n    body=json.dumps(\n        unauthorized_message_data, sort_keys=True\n    )\n)\n```", "```py\n    try:\n        verify_artisan = COArtisan.get(str(new_artisan.oid))[0]\n        self.fail(\n            'An unauthorized message should not execute a data-'\n            'change'\n        )\n    except IndexError:\n        pass\n```", "```py\n    invalid_message_data = new_artisan.to_message_data()\n    # - Alter a data-value, like website\n    invalid_message_data['website'] = 12.345\n    invalid_message = DaemonMessage(\n        operation='create', \n        origin=MESSAGE_ORIGINS.central_office,\n        data={\n            'target':'artisan',\n            'properties':invalid_message_data,\n        },\n        signing_key=self.Gateway_signing_key\n    )\n    sender.send_message(invalid_message, self.Gateway_queue_id)\n    try:\n        verify_artisan = COArtisan.get(str(new_artisan.oid))[0]\n        self.fail(\n            'An unauthorized message should not execute a data-'\n            'change'\n        )\n    except IndexError:\n        pass\n```", "```py\ndef create_artisan(self, message:(DaemonMessage,)) -> None:\n    self.info('%s.create_artisan called' % self.__class__.__name__)\n\n    # ...\n\n    # - Assure that only the appropriate roles can execute this \n    #   method. First check against *all* valid origins (at a \n    #   minimum, this check should occur in *all* methods)\n    if message.origin not in MESSAGE_ORIGINS:\n        raise RuntimeError(\n            'Malformed message: \"%s\" is not an accepted '\n            'message-origin' % message.origin\n        )\n    # - Alternately, check against specific roles/origins instead, \n    #   if they are limited\n    if message.origin != MESSAGE_ORIGINS.central_office:\n        raise RuntimeError(\n            'Unauthorized Action: \"%s\" is not allowed to '\n            'execute this method' % message.origin\n        )\n```", "```py\nclass ArtisanapplicationMock:\n\n    # ... Properties and initialization would need to be fleshed \n    #   out, obviously...\n\n    # CRUD-operation methods to implement\n    def update_artisan(self, message:(DaemonMessage,)) -> (None,):\n        # TODO: Implement this method\n        pass\n\n    def create_order(self, message:(DaemonMessage,)) -> (None,):\n        # TODO: Implement this method\n        pass\n\n    def update_order(self, message:(DaemonMessage,)) -> (None,):\n        # TODO: Implement this method\n        pass\n\n    def delete_order(self, message:(DaemonMessage,)) -> (None,):\n        # TODO: Implement this method\n        pass\n\n    def update_product(self, message:(DaemonMessage,)) -> (None,):\n        # TODO: Implement this method\n        pass\n```", "```py\n    def _handle_message(self, message:(DaemonMessage,)) -> (None,):\n        # - This method would look very much like its counterpart \n        #   in hms_Gateway.daemons.ArtisanGatewayDaemon\n        # TODO: Implement this method\n        pass\n```", "```py\ndef handle_pending_messages(self) -> (None,):\n    # - Create a connection\n    connection = pika.BlockingConnection(\n        pika.ConnectionParameters(\n            self.connection_params['host'],\n            self.connection_params.get('port'),\n            self.connection_params.get('path'),\n        )\n    )\n    # - Create (or at least specify) a channel\n    channel = connection.channel()\n    # - Create or specify a queue\n    channel.queue_declare(queue=self.queue_name)\n    # - Get *all* pending messages, and execute against them\n    polling = True\n    while polling:\n        try:\n            # - Retrieve the next message from the queue, if \n            #   there is one, and handle it...\n            method_frame, header, body = channel.basic_get(self.queue_name)\n            if method_frame:\n                # - Any actual message, valid or not, will \n                #   generate a method_frame\n                message = DaemonMessage.from_message_json(\n                    body.decode(), self.signing_key\n                )\n                # - We've received the message, and will \n                #   process it, so acknowledge it on basic \n                #   principle\n                channel.basic_ack(method_frame.delivery_tag)\n                self._handle_message(message)\n            else:\n                polling = False\n        except InvalidMessageError as error:\n            # - If message-generation fails (bad signature), \n            #   we still need to send an acknowledgement in order \n            #   to clear the message from the queue\n            channel.basic_ack(method_frame.delivery_tag)\n```", "```py\n#!/usr/bin/env python\n\"\"\"\nA (partial) script that runs through the various processes we need \nto demo for the Artisan Gateway service.\n\"\"\"\n\n# - Imports needed for the demo-script\nimport unittest\nimport os\n\nfrom hms_core.co_objects import Artisan as COArtisan\nfrom hms_core.messaging import DaemonMessage, RabbitMQSender, \\\n    MESSAGE_ORIGINS\n```", "```py\nfrom test_hms_Gateway import LocalSuite\n\ndef demoUnitTests():\n    print(\n        '+== Showing that unit-tests run without error '.ljust(79,'=') + '+'\n    )\n    results = unittest.TestResult()\n    LocalSuite.run(results)\n    print('+== Unit-tests run complete '.ljust(79,'=') + '+\\n\\n')\n```", "```py\ndef demoArtisanCreateFromCO():\n    print(\n        '+== Central Office Creating Artisan '.ljust(79,'=') + '+'\n    )\n```", "```py\n    parameters = {\n        'contact_name':'contact-name',\n        'contact_email':'no-one@me.co',\n        'address':{\n            'street_address':'street-address',\n            'city':'city',\n        },\n        'queue_id':'bogus-queue-id',\n        'signing_key':os.urandom(64),\n    }\n    new_artisan = COArtisan.from_data_dict(parameters)\n```", "```py\n    initial_state = new_artisan.to_data_dict()\n    print('| Initial state:'.ljust(79, ' ') + '|')\n    for key in sorted(initial_state.keys()):\n        print(\n            (\n                ('| +- %s ' % key).ljust(24, '.') + ' %s' % initial_state[key]\n            )[0:78].ljust(79, ' ') + '|'\n        )\n    print('+' + '-'*78 + '+')\n```", "```py\n    sender = RabbitMQSender()\n    # - Send the new-COArtisan message to the service\n    message = DaemonMessage(\n        operation='create', \n        origin=MESSAGE_ORIGINS.central_office,\n        data={\n            'target':'artisan',\n            'properties':new_artisan.to_message_data(),\n        },\n        signing_key=parameters['signing_key']\n    )\n    sender.send_message(message, parameters['queue_id'])\n    # - The message has been sent, but we have to wait for \n    #   a bit before it is received and acted upon before we \n    #   can verify the creation happened\n    time.sleep(5)\n```", "```py\n    verify_artisan = COArtisan.get(str(new_artisan.oid))[0]\n    verify_state = new_artisan.to_data_dict()\n    print('| Saved state:'.ljust(79, ' ') + '|')\n    for key in sorted(verify_state.keys()):\n        print(\n            (\n                ('| +- %s ' % key).ljust(24, '.') + ' %s' % verify_state[key]\n            )[0:78].ljust(79, ' ') + '|'\n        )\n    print('+' + '='*78 + '+')\n```", "```py\n    print('\\n')\n    input('[Enter] to continue the demo')\n    print('\\n')\n```", "```py\nif __name__ == '__main__':\n    demoArtisanCreateFromCO()\n```", "```py\n# The actual setup function call:\nsetup(\n    name='HMS-Artisan-Gateway',\n    version='0.1.dev0',\n\n    # ...\n\n    packages=[\n        'hms_Gateway',\n        'hms_core',\n    ],\n\n    # ...\n\n)\n```", "```py\nfull_package:\n        # Create a temporary packaging directory to copy all the \n        # relevant files to\n        mkdir -p /tmp/Gateway-packaging\n        # Copy those files\n        cp -R src/hms_Gateway /tmp/Gateway-packaging\n        cp -R ../hms-core/src/hms_core /tmp/Gateway-packaging\n        # - Change to the temporary packaging directory, execute setup.py\n        cd /tmp/Gateway-packaging;python setup.py\n        # - Move the resulting package to somewhere outside the \n        #       temporary packaging directory, after assuring that the \n        #       location exists\n        mkdir -p ~/Desktop/HMS-Builds\n        mv /tmp/Gateway-packaging/dist/* ~/Desktop/HMS-Builds\n        # - Clean up the temporary directory\n        rm -fR /tmp/Gateway-packaging\n```", "```py\n# HMS Artisan Gateway Service Configuration\n# - Used by the hms_Gateway.daemons.ArtisanGatewayDaemon class\n#   to launch an active instance of the service\nlogging:\n  format: \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n  name: hms_Gateway\n# If console-logging is desired, uncomment these lines\n#  console:\n#    level: info\n  file:\n    level: error\n    logfile: \"/var/log/hms/hms_Gateway.log\"\nqueue:\n  type: rabbit\n  connection:\n    host: rabbitmq.hms.com\n    port: 5672\n    path: /\n  queue_name: \"central-office\"\n# Signing-key should be generated and added to configuration \n# during installation. It should be a 64-character, \n# bytes-type-compatible string-value, and will likely need to be \n# explicitly quoted\nsigning_key: \"\"\n\n```", "```py\nif __name__ == '__main__':\n    daemon = ArtisanGatewayDaemon('/etc/hms/hms_Gateway.conf')\n    daemon.start()\n```", "```py\n[Unit]\nDescription = Artisan Gateway Service\nAfter      = network-online.target \n[Service]\n# - Start-up process\nExecStart   = python -m hms_Gateway.daemons\n# - How to shut the service down\nExecStop    = pkill -f hms_Gateway.daemons\nExecRestart = pkill -f hms_Gateway.daemons;python -m hms_Gateway.daemons\n\n# - If it stops unexpectedly, do we want it to restart?\nRestart     = always\n\n[Install]\n# - This corresponds, at least roughly, to runlevel 3, after \n#   a complete system start\nWantedBy    = multi-user.target\n```"]