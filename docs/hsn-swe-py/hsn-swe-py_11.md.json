["```py\n###################################\n# Property-getter methods         #\n###################################\n\ndef _get_bool_prop(self) -> (bool,):\n    return self._bool_prop\n\n###################################\n# Property-setter methods         #\n###################################\n\ndef _set_bool_prop(self, value:(bool,int)):\n    if value not in (True, False, 1, 0):\n        raise ValueError(\n            '%s.bool_prop expects either a boolean value '\n            '(True|False) or a direct int-value equivalent '\n            '(1|0), but was passed \"%s\" (%s)' % \n            (self.__class__.__name__, value, type(value).__name__)\n        )\n    if value:\n        self._bool_prop = True\n    else:\n        self._bool_prop = False\n\n###################################\n# Property-deleter methods        #\n###################################\n\ndef _del_bool_prop(self) -> None:\n    self._bool_prop = False\n\n###################################\n# Instance property definitions   #\n###################################\n\nbool_prop = property(\n    _get_bool_prop, _set_bool_prop, _del_bool_prop, \n    'Gets sets or deletes the flag that indicates whether '\n    'the instance is in a particular state'\n)\n```", "```py\n###################################\n# Property-deleter methods        #\n###################################\n\ndef _del_is_active(self) -> None:\n    self._is_active = True\n\ndef _del_is_deleted(self) -> None:\n    self._is_deleted = False\n\ndef _del_is_dirty(self) -> None:\n    self._is_dirty = False\n\ndef _del_is_new(self) -> None:\n    self._is_new = True\n```", "```py\n###################################\n# Instance property definitions   #\n###################################\n\nis_active = property(\n    _get_is_active, _set_is_active, _del_is_active, \n    'Gets sets or deletes the flag that indicates whether '\n    'the instance is considered active/available'\n)\nis_deleted = property(\n    _get_is_deleted, _set_is_deleted, _del_is_deleted, \n    'Gets sets or deletes the flag that indicates whether '\n    'the instance is considered to be \"deleted,\" and thus '\n    'not generally available'\n)\nis_dirty = property(\n    _get_is_dirty, _set_is_dirty, _del_is_dirty, \n    'Gets sets or deletes the flag that indicates whether '\n    'the instance\\'s state-data has been changed such that '\n    'its record needs to be updated'\n)\nis_new = property(\n    _get_is_new, _set_is_new, _del_is_new, \n    'Gets sets or deletes the flag that indicates whether '\n    'the instance needs to have a state-data record created'\n)\n```", "```py\nclass BaseDataObject(metaclass=abc.ABCMeta):\n    \"\"\"\nProvides baseline functionality, interface requirements, and \ntype-identity for objects that can persist their state-data in \nany of several back-end data-stores.\n\"\"\"\n    ###################################\n    # Class attributes/constants      #\n    ###################################\n\n    _data_time_string = '%Y-%m-%d %H:%M:%S'\n```", "```py\ndef _set_created(self, value:(datetime,str,float,int)):\n    if type(value) not in (datetime,str,float,int):\n        raise TypeError(\n            '%s.created expects a datetime value, a numeric '\n            'value (float or int) that can be converted to '\n            'one, or a string value of the format \"%s\" that '\n            'can be parsed into one, but was passed '\n            '\"%s\" (%s)' % \n            (\n                self.__class__.__name__, \n                self.__class__._data_time_string, value, \n                type(value).__name__, \n            )\n        )\n```", "```py\n if type(value) in (int, float):\n   # - A numeric value was passed, so create a new \n   #   value from it\n      try:\n         value = datetime.fromtimestamp(value)\n      except Exception as error:\n         raise ValueError(\n             '%s.created could not create a valid datetime '\n             'object from the value provided, \"%s\" (%s) due '\n             'to an error - %s: %s' % \n             (\n                self.__class__.__name__, value, \n                type(value).__name__, \n                error.__class__.__name__, error\n              )\n           )\n```", "```py\n elif type(value) == str:\n    # - A string value was passed, so create a new value \n    #   by parsing it with the standard format\n      try:\n         value = datetime.strptime(\n         value, self.__class__._data_time_string\n         )\n       except Exception as error:\n          raise ValueError(\n            '%s.created could not parse a valid datetime '\n            'object using \"%s\" from the value provided, '\n            '\"%s\" (%s) due to an error - %s: %s' % \n             (\n                 self.__class__.__name__, \n                 self.__class__._data_time_string, \n                 value, type(value).__name__, \n                 error.__class__.__name__, error\n              )\n          )\n```", "```py\n# - If this point is reached without error,then we have a \n#   well-formed datetime object, so store it\nself._created = value\n```", "```py\ndef _get_created(self) -> datetime:\n    if self._created == None:\n        self.created = datetime.now()\n    return self._created\n```", "```py\ndef _del_created(self) -> None:\n    self._created = None\n```", "```py\n###################################\n# Instance property definitions   #\n###################################\n\ncreated = property(\n    _get_created, _set_created, None, \n    'Gets, sets or deletes the date-time that the state-data '\n    'record of the instance was created'\n)\n\n# ...\n\nmodified = property(\n    _get_modified, _set_modified, _del_modified, \n    'Gets, sets or deletes the date-time that the state-data '\n    'record of the instance was last modified'\n)\n```", "```py\ndef _get_oid(self) -> UUID:\n    if self._oid == None:\n        self._oid = uuid4()\n    return self._oid\n\n# ...\n\ndef _set_oid(self, value:(UUID,str)):\n    if type(value) not in (UUID,str):\n        raise TypeError(\n            '%s.oid expects a UUID value, or string '\n            'representation of one, but was passed \"%s\" (%s)' % \n            (self.__class__.__name__, value, type(value).__name__)\n        )\n    if type(value) == str:\n        try:\n            value = UUID(value)\n        except Exception as error:\n            raise ValueError(\n                '%s.oid could not create a valid UUID from '\n                'the provided string \"%s\" because of an error '\n                '%s: %s' % \n                (\n                    self.__class__.__name__, value, \n                    error.__class__.__name__, error\n                )\n            )\n    self._oid = value\n\n# ...\n\ndef _del_oid(self) -> None:\n    self._oid = None\n```", "```py\n    ###################################\n    # Abstract methods                #\n    ###################################\n\n    @abc.abstractmethod\n    def _create(self) -> None:\n        \"\"\"\nCreates a new state-data record for the instance in the back-end \ndata-store\n\"\"\"\n        raise NotImplementedError(\n            '%s has not implemented _create, as required by '\n            'BaseDataObject' % (self.__class__.__name__)\n        )\n\n    @abc.abstractmethod\n    def to_data_dict(self) -> (dict,):\n        \"\"\"\nReturns a dictionary representation of the instance which can \nbe used to generate data-store records, or for criteria-matching \nwith the matches method.\n\"\"\"\n        raise NotImplementedError(\n            '%s has not implemented _create, as required by '\n            'BaseDataObject' % (self.__class__.__name__)\n        )\n\n    @abc.abstractmethod\n    def _update(self) -> None:\n        \"\"\"\nUpdates an existing state-data record for the instance in the \nback-end data-store\n\"\"\"\n        raise NotImplementedError(\n            '%s has not implemented _update, as required by '\n            'BaseDataObject' % (self.__class__.__name__)\n        )\n\n    ###################################\n    # Class methods                   #\n    ###################################\n\n    @abc.abstractclassmethod\n    def delete(cls, *oids):\n        \"\"\"\nPerforms an ACTUAL record deletion from the back-end data-store \nof all records whose unique identifiers have been provided\n\"\"\"\n        raise NotImplementedError(\n            '%s.delete (a class method) has not been implemented, '\n            'as required by BaseDataObject' % (cls.__name__)\n        )\n\n    @abc.abstractclassmethod\n    def from_data_dict(cls, data_dict:(dict,)):\n        \"\"\"\nCreates and returns an instance of the class whose state-data has \nbeen populate with values from the provided data_dict\n\"\"\"\n        raise NotImplementedError(\n            '%s.from_data_dict (a class method) has not been '\n            'implemented, as required by BaseDataObject' % \n            (cls.__name__)\n        )\n\n    @abc.abstractclassmethod\n    def get(cls, *oids, **criteria):\n        \"\"\"\nFinds and returns all instances of the class from the back-end \ndata-store whose oids are provided and/or that match the supplied \ncriteria\n\"\"\"\n        raise NotImplementedError(\n            '%s.get (a class method) has not been implemented, '\n            'as required by BaseDataObject' % (cls.__name__)\n        )\n```", "```py\n###################################\n# Instance methods                #\n###################################\n\ndef matches(self, **criteria) -> (bool,):\n    \"\"\"\nCompares the supplied criteria with the state-data values of \nthe instance, and returns True if all instance properties \nspecified in the criteria exist and equal the values supplied.\n\"\"\"\n    # - First, if criteria is empty, we can save some time \n    #   and simply return True - If no criteria are specified, \n    #   then the object is considered to match the criteria.\n    if not criteria:\n        return True\n    # - Next, we need to check to see if all the criteria \n    #   specified even exist in the instance:\n    data_dict = self.to_data_dict()\n    data_keys = set(check_dict.keys())\n    criteria_keys = set(criteria.keys())\n    # - If all criteria_keys exist in data_keys, then the \n    #   intersection of the two will equal criteria_keys. \n    #   If that's not the case, at least one key-value won't \n    #   match (because it doesn't exist), so return False\n    if criteria_keys.intersection(data_keys) != criteria_keys:\n        return False\n    # - Next, we need to verify that values match for all \n    #   specified criteria\n    return all(\n        [\n            (data_dict[key] == criteria[key]) \n            for key in criteria_keys\n        ]\n    )\n```", "```py\n    def save(self):\n        \"\"\"\nSaves the instance's state-data to the back-end data-store by \ncreating it if the instance is new, or updating it if the \ninstance is dirty\n\"\"\"\n        if self.is_new:\n            self._create()\n            self._set_is_new = False\n            self._set_is_dirty = False\n```", "```py\n        elif self.is_dirty:\n            self._update()\n            self._set_is_dirty = False\n            self._set_is_new = False\n```", "```py\n    def __init__(self, \n        oid:(UUID,str,None)=None, \n        created:(datetime,str,float,int,None)=None, \n        modified:(datetime,str,float,int,None)=None,\n        is_active:(bool,int,None)=None, \n        is_deleted:(bool,int,None)=None,\n        is_dirty:(bool,int,None)=None, \n        is_new:(bool,int,None)=None,\n    ):\n```", "```py\n        # - Call parent initializers if needed\n        # - Set default instance property-values using _del_... methods\n\n        # ...\n\n        self._del_oid()\n        # - Set instance property-values from arguments using \n        #   _set_... methods\n        if oid != None:\n            self._set_oid(oid)\n\n        # ...\n\n        # - Perform any other initialization needed\n```", "```py\ndef __init__(self, \n    contact_name:str, contact_email:str, \n    address:Address, company_name:str=None, \n    website:(str,)=None, \n    *products\n    ):\n```", "```py\ndef __init__(self, \n    contact_name:str, contact_email:str, \n    address:Address, company_name:str=None, \n    website:(str,)=None, \n    oid:(UUID,str,None)=None, \n    created:(datetime,str,float,int,None)=None, \n    modified:(datetime,str,float,int,None)=None,\n    is_active:(bool,int,None)=None, \n    is_deleted:(bool,int,None)=None,\n    is_dirty:(bool,int,None)=None, \n    is_new:(bool,int,None)=None,\n    *products\n    ):\n```", "```py\nartisan = Artisan(\n    contact_name='John Doe', contact_email='john@doe.com', \n    address=my_address, oid='00000000-0000-0000-0000-000000000000', \n    created='2001-01-01 12:34:56', modified='2001-01-01 12:34:56'\n)\n```", "```py\nartisan_parameters = {\n    'contact_name':'John Doe',\n    'contact_email':'john@doe.com', \n    'address':my_address,\n    'oid':'00000000-0000-0000-0000-000000000000', \n    'created':'2001-01-01 12:34:56', \n    'modified':'2001-01-01 12:34:56'\n}\nartisan = Artisan(**artisan_parameters)\n```", "```py\n@classmethod\ndef from_data_dict(cls, data_dict):\n    return cls(**data_dict)\n```", "```py\n#######################################\n# Child-module test-cases to execute  #\n#######################################\n\nimport test_data_objects\nLocalSuite.addTests(test_data_objects.LocalSuite._tests)\n\n# import child_module\n# LocalSuite.addTests(child_module.LocalSuite._tests)\n```", "```py\ndef test_get_created(self):\n    # Tests the _get_created method of the BaseDataObject class\n    test_object = BaseDataObjectDerived()\n    expected = 'expected value'\n    test_object._created = expected\n    actual = test_object.created\n    self.assertEquals(actual, expected, \n        '_get_created was expected to return \"%s\" (%s), but '\n        'returned \"%s\" (%s) instead' % \n        (\n            expected, type(expected).__name__,\n            actual, type(actual).__name__\n        )\n    )\n```", "```py\n    test_object._created = None\n    self.assertEqual(type(test_object._get_created()), datetime, \n        'BaseDataObject._get_created should return a '\n        'datetime value if it\\'s retrieved from an instance '\n        'with an underlying None value'\n    )\n```", "```py\ndef test_set_created(self):\n    # Tests the _set_created method of the BaseDataObject class\n    test_object = BaseDataObjectDerived()\n    # - Test all \"good\" values\n    for created in GoodDateTimes:\n        if type(created) == datetime:\n            expected = created\n        elif type(created) in (int, float):\n            expected = datetime.fromtimestamp(created)\n        elif type(created) == str:\n            expected = datetime.strptime(\n                created, BaseDataObject._data_time_string\n            )\n        test_object._set_created(created)\n        actual = test_object.created\n        self.assertEqual(\n            actual, expected, \n            'Setting created to \"%s\" (%s) should return '\n            '\"%s\" (%s) through the property, but \"%s\" (%s) '\n            'was returned instead' % \n            (\n                created, type(created).__name__,\n                expected, type(expected).__name__, \n                actual, type(actual).__name__, \n            )\n        )\n    # - Test all \"bad\" values\n    for created in BadDateTimes:\n        try:\n            test_object._set_created(created)\n            self.fail(\n                'BaseDataObject objects should not accept \"%s\" '\n                '(%s) as created values, but it was allowed to '\n                'be set' % \n                (created, type(created).__name__)\n            )\n        except (TypeError, ValueError):\n            pass\n        except Exception as error:\n            self.fail(\n                'BaseDataObject objects should raise TypeError '\n                'or ValueError if passed a created value of '\n                '\"%s\" (%s), but %s was raised instead:\\n'\n                '    %s' % \n                (\n                    created, type(created).__name__, \n                    error.__class__.__name__, error\n                )\n            )\n```", "```py\ndef test_del_created(self):\n    # Tests the _del_created method of the BaseDataObject class\n    test_object = BaseDataObjectDerived()\n    test_object._created = 'unexpected value'\n    test_object._del_created()\n    self.assertEquals(\n        test_object._created, None,\n        'BaseDataObject._del_created should leave None in the '\n        'underlying storage attribute, but \"%s\" (%s) was '\n        'found instead' % \n        (\n            test_object._created, \n            type(test_object._created).__name__\n        )\n    )\n```", "```py\ndef test_get_oid(self):\n    # Tests the _get_oid method of the BaseDataObject class\n    test_object = BaseDataObjectDerived()\n    expected = 'expected value'\n    test_object._oid = expected\n    actual = test_object.oid\n    self.assertEquals(actual, expected, \n        '_get_oid was expected to return \"%s\" (%s), but '\n        'returned \"%s\" (%s) instead' % \n        (\n            expected, type(expected).__name__,\n            actual, type(actual).__name__\n        )\n    )\n    test_object._oid = None\n    self.assertEqual(type(test_object.oid), UUID, \n        'BaseDataObject._get_oid should return a UUID value '\n        'if it\\'s retrieved from an instance with an '\n        'underlying None value'\n    )\n```", "```py\n    def test_set_oid(self):\n        # Tests the _set_oid method of the BaseDataObject class\n        test_object = BaseDataObjectDerived()\n        # - Test all \"good\" values\n        for oid in GoodOIDs:\n            if type(oid) == UUID:\n                expected = oid\n            elif type(oid) == str:\n                expected = UUID(oid)\n            test_object._set_oid(oid)\n            actual = test_object.oid\n            self.assertEqual(\n                actual, expected, \n                'Setting oid to \"%s\" (%s) should return '\n                '\"%s\" (%s) through the property, but \"%s\" '\n                '(%s) was returned instead.' % \n                (\n                    oid, type(oid).__name__, \n                    expected, type(expected).__name__, \n                    actual, type(actual).__name__, \n                )\n            )\n        # - Test all \"bad\" values\n        for oid in BadOIDs:\n            try:\n                test_object._set_oid(oid)\n                self.fail(\n                    'BaseDatObject objects should not accept '\n                    '\"%s\" (%s) as a valid oid, but it was '\n                    'allowed to be set' % \n                    (oid, type(oid).__name__)\n                )\n            except (TypeError, ValueError):\n                pass\n            except Exception as error:\n                self.fail(\n                    'BaseDataObject objects should raise TypeError '\n                    'or ValueError if passed a value of \"%s\" (%s) '\n                    'as an oid, but %s was raised instead:\\n'\n                    '    %s' % \n                    (\n                        oid, type(oid).__name__, \n                        error.__class__.__name__, error\n                    )\n                )\n```", "```py\nfrom hms_core.business_objects import BaseArtisan\n```", "```py\nimport hms_core.business_objects\n```", "```py\nfrom hms_core.data_objects import BaseDataObject\n```", "```py\nimport hms_core.data_objects\n```"]