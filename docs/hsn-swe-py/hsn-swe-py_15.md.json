["```py\n#!/usr/bin/env python\n\"\"\"\nA simple daemon-like function that can be started from the command-line.\n\"\"\"\n    import syslog\n    from time import sleep\n\n    def main_program():\n        iterations = 0\n        syslog.syslog('Starting %s' % __file__)\n        while True:\n            # TODO: Perform whatever request-acquisition and response-\n            #       generation is needed here...\n            syslog.syslog('Event Loop (%d)' % iterations)\n            sleep(10)\n            iterations += 1\n        syslog.syslog('Exiting %s' % __file__)\n\n    if __name__ == '__main__':\n        main_program()\n```", "```py\n# - Evaluate the incoming request:\n    if request['path'].startswith('/product'):\n       return handle_product_request(request)\n    elif request['path'].startswith('/artisan'):\n       return handle_artisan_request(request)\n    elif request['path'].startswith('/customer'):\n       return handle_customer_request(request)\n    else:\n# - Invalid request, so return an error\n       return handle_invalid_request(request)\n```", "```py\n#!/usr/bin/env python\n\"\"\"\nA bare-bones daemon implementation.\n\"\"\"\n    import syslog\n    from daemon import DaemonContext\n    from time import sleep\n\n    def main_program():\n        iterations = 0\n        syslog.syslog('Starting %s' % __file__)\n        while True:\n        # TODO: Perform whatever request-acquisition and response-\n        #       generation is needed here...\n            syslog.syslog('Event Loop (%d)' % iterations)\n            sleep(10)\n            iterations += 1\n        syslog.syslog('Exiting %s' % __file__)\n\n    if __name__ == '__main__':\n        with DaemonContext():\n            main_program()\n```", "```py\n[DEFAULT]\n# This section handles settings-values that are available in other \n# sections.\n# - The minimum log-level that's in play\nlog_level:      INFO\nqueue_type:     rabbit\nqueue_check:    5\n\n[console_log]\n# Settings for logging of messages to the console\n# - Message-types to log to a console\ncapture:        INFO, WARNING\n\n[file_log]\n# Settings for file-logging\nlog_file:       /var/log/myservice/activity.log\n\n[rabbit_config]\n# Configuration for the RabbitMQ server, if queue_type is \"rabbit\"\nserver:         10.1.10.1\nport:           5672\nqueue_name:     my-queue\nuser:           username\npassword:       password\n```", "```py\n{\n    \"logging\": {\n        \"log_level\": \"INFO\",\n        \"console_capture\": [\"INFO\",\"WARNING\"],\n        \"log_file\": \"/var/log/myservice/activity.log\"\n    },\n    \"queue\": {\n        \"queue_type\": \"rabbit\",\n        \"queue_check\": 5,\n        \"server\": \"10.1.10.1\",\n        \"port\": 5672,\n        \"queue_name\": \"my-queue\",\n        \"user\": \"username\",\n        \"password\": \"password\"\n    }\n}\n```", "```py\n# Logging configuration\nlogging:\n    console_capture:\n        - INFO\n        - WARNING\n    log_file: /var/log/myservice/activity.log\n    log_level: INFO\n# Queue configuration\nqueue:\n    queue_type: rabbit\n    # Credentials\n    user: username\n    password: password\n    # Network\n    server: 10.1.10.1\n    port: 5672\n    # Queue settings\n    queue_name: my-queue\n    queue_check: 5\n```", "```py\nimport logging\n\n# - Define a format for log-output\nformatter = logging.Formatter(\n    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n# - Get a logger. Once defned anywhere, loggers (with all their \n#   settings and attached formats and handlers) can be retrieved \n#   elsewhere by getting a logger instance using the same name.\nlogger = logging.getLogger('logging-example')\nlogger.setLevel(logging.DEBUG)\n# - Create a file-handler to write log-messages to a file\nfile_handler = logging.FileHandler('example.log')\nfile_handler.setLevel(logging.DEBUG)\nfile_handler.setFormatter(formatter)\n# - Attach handler to logger\nlogger.addHandler(file_handler)\n\n# - Log some messages to show that it works:\nlogger.critical('This is a CRITICAL-level message')\nlogger.debug('This is a DEBUG-level message')\nlogger.error('This is an ERROR-level message')\nlogger.info('This is an INFO-level message')\nlogger.warn('This is a WARNING-level message')\n```", "```py\ndef some_function(*args, **kwargs):\n    logger.info('some_function(%s, %s) called' % (str(args), str(kwargs)))\n    if not args and not kwargs:\n        logger.warn(\n            'some_function was called with no arguments'\n        )\n    elif args:\n        logger.debug('*args exists: %s' % (str(args)))\n        try:\n            x, y = args[0:2]\n            logger.debug('x = %s, y = %s' % (x, y))\n            return x / y\n        except ValueError as error:\n            logger.error(\n                '%s: Could not get x and y values from '\n                'args %s' % \n                (error.__class__.__name__, str(args))\n            )\n        except Exception as error:\n            logger.error(\n                '%s in some_function: %s' % \n                (error.__class__.__name__, error)\n            )\n    logger.info('some_function complete')\n```", "```py\nclass BaseDaemon(metaclass=abc.ABCMeta):\n\"\"\"\nProvides baseline functionality, interface requirements, and type-identity for objects that can act as a daemon/service managed by facilities in the local OS \n(like systemd) or by third-party service-configurators (like NSSM)\n\"\"\"\n    ###################################\n    #   Class attributes/constants    #\n    ###################################\n\n    _handler_classes = {}\n    _handler_keys = []\n```", "```py\n# - Default logging information\n    _logging = {\n        'name':None,\n        'format':'%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        'file':{\n            'logfile':None,\n            'level':logging.INFO,\n        },\n        'console':{\n            'level':logging.ERROR,\n        }\n    }\n```", "```py\ndef _create_logger(self):\n    \"\"\"\nCreates the instance's logger object, sets up formatting for log-entries, and \nhandlers for various log-output destinations\n\"\"\"\n    if not self.__class__._logging.get('name'):\n        raise AttributeError(\n            '%s cannot establish a logging facility because no '\n            'logging-name value was set in the class itself, or '\n            'through configuration settings (in %s).' % \n            (self.__class__.__name__, self.config_file)\n        )\n```", "```py\n    try:\n        logging_settings = self.__class__._logging\n        # - Global log-format\n        formatter = logging.Formatter(logging_settings['format'])\n        # - The main logger\n        self._logger = logging.getLogger(\n            logging_settings['name']\n        )\n        # - By default, the top-level logger instance will accept anything. \n        #   We'll change that to the appropriate level after checking the \n        #   various log-level settings:\n        final_level = logging.DEBUG\n```", "```py\n        if logging_settings.get('file'):\n            # - We're logging *something* to a file, so create a handler \n            #   to that purpose:\n            if not self.__class__._logging['file'].get('logfile'):\n                raise AttributeError(\n                    '%s cannot establish a logging facility because no '\n                    'log-file value was set in the class itself, or '\n                    'through configuration settings (in %s).' % \n                    (self.__class__.__name__, self.config_file)\n                )\n            # - The actual file-handler\n            file_handler = logging.FileHandler(\n                logging_settings['file']['logfile']\n            )\n            # - Set the logging-level accordingly, and adjust final_level\n            file_handler.setLevel(logging_settings['file']['level'])\n            final_level = min(\n                [\n                     logging_settings['file']['level'],\n                     final_level\n                ]\n            )\n            # - Set formatting and attach it to the main logger:\n            file_handler.setFormatter(formatter)\n            self._logger.addHandler(file_handler)\n```", "```py\n    if logging_settings.get('console'):\n        # - We're logging *something* to the console, so create a \n        #   handler to that purpose:\n        # - The actual console-handler\n        console_handler = logging.StreamHandler()\n        # - Set the logging-level accordingly, and adjust final_level\n        console_handler.setLevel(\n            logging_settings['console']['level']\n        )\n        final_level = min(\n            [\n                 logging_settings['console']['level'],\n                 final_level\n            ]\n         )\n        # - Set formatting and attach it to the main logger:\n        console_handler.setFormatter(formatter)\n        self._logger.addHandler(console_handler)\n        # - For efficiency's sake, use the final_level at the logger itself. \n        #   That should (hopefully) allow logging to run (trivially) \n        #   faster, since it'll know to skip anything that isn't handled by \n        #   at least one handler...\n        self._logger.setLevel(final_level)\n```", "```py\nexcept Exception as error:\n    raise RuntimeError(\n        '%s could not complete the set-up of its logging '\n        'facilities because %s was raised: %s' % \n            (\n                self.__class__.__name__, error.__class__.__name__, \n                error\n            )\n    )\n# - Log the fact that we can log stuff now :-)\n    self.info(\n        'Logging started. Other messages may have been output to '\n        'stdout/terminal prior to now'\n    )\n```", "```py\n###################################\n#        Logging methods          #\n###################################\n\ndef critical(self, msg, *args, **kwargs):\n    if self.logger:\n        self.logger.critical(msg, *args, **kwargs)\n    else:\n        print('CRITICAL - %s' % msg)\n\ndef debug(self, msg, *args, **kwargs):\n    if self.logger:\n        self.logger.debug(msg, *args, **kwargs)\n    else:\n        print('DEBUG    - %s' % msg)\n```", "```py\n    ###################################\n    #  Instance property definitions  #\n    ###################################\n\n    config_file = property(\n        _get_config_file, None, None, \n        'Gets the configuration-file used to set up the instance'\n    )\n    logger = property(\n        _get_logger, None, None, \n        'Gets the logger for the instance'\n    )\n```", "```py\ndef _set_config_file(self, value:(str,)):\n    if type(value) != str:\n        raise TypeError(\n            '%s.config_file expects a string value that points '\n            'to a readable configuration-file on the local file-'\n            'system, but was passed \"%s\" (%s)' % \n            (self.__class__.__name__, value, type(value).__name__)\n        )\n    if not os.path.isfile(value):\n        if type(value) != str:\n            raise TypeError(\n                '%s.config_file expects a string value that '\n                'points to a readable configuration-file on the '\n                'local file-system, but was passed \"%s\" (%s), '\n                'which is not a file' % \n                (\n                    self.__class__.__name__, value, \n                    type(value).__name__\n                )\n            )\n    if not os.access(value, os.R_OK):\n        if type(value) != str:\n            raise TypeError(\n                '%s.config_file expects a string value that '\n                'points to a readable configuration-file on the '\n                'local file-system, but was passed \"%s\" (%s), '\n                'which is not a READABLE file' % \n                (\n                    self.__class__.__name__, value, \n                    type(value).__name__\n                )\n            )\n    self.debug(\n        '%s.config_file set to %s' % (self.__class__.__name__, value)\n    )\n    self._config_file = value\n```", "```py\ndef configure(self):\n    \"\"\"\nReads the instance's configuration-file, converts it to a dictionary of values, then hands the responsibility for actually configuring the instance off to its required _on_configuration_loaded method\n\"\"\"\n    try:\n        self.info('Loading configuration for %s' % self.__class__.__name__)\n    except RuntimeError:\n        # - This should only happen during start-up...\n        print('Loading configuration for %s' % self.__class__.__name__)\n    try:\n        fp = open(self.config_file, 'r')\n        config_data = yaml.load(fp)\n        fp.close()\n    except Exception as error:\n        raise RuntimeError(\n            '%s.config could not read configuration-data from '\n            '%s, %s was raised: %s' % \n            (\n                self.__class__.__name__, config_file, \n                error.__class__.__name__, error\n            )\n        )\n    # - With the configuration read, it's time to actually \n    #   configure the instance\n    self._on_configuration_loaded(**config_data)\n```", "```py\n@abc.abstractmethod\ndef _on_configuration_loaded(self, **config_data):\n    \"\"\"\nApplies the configuration to the instance. Since there are configuration values that may exist for any instance of the class, this method should be called by derived classes in addition to any local configuration.\n\"\"\"\n    if config_data.get('logging'):\n        # - Since the class' logging settings are just a dict, we can \n        #   just update that dict, at least to start with:\n        self.__class__._logging.update(config_data['logging'])\n        # - Once the update is complete, we do need to change any logging-\n        #   level items, though. We'll start with the file-logging:\n        file_logging = self.__class__._logging.get('file')\n        if file_logging:\n            file_level = file_logging.get('level')\n            if not file_level:\n                file_logging['level'] = logging.INFO\n            elif type(file_level) == str:\n                try:\n                    file_logging['level'] = getattr(\n                        logging, file_level.upper()\n                    )\n                except AttributeError:\n                    file_logging['level'] = logging.INFO\n        # - Similarly, console-logging\n        console_logging = self.__class__._logging.get('console')\n        if console_logging:\n            console_level = console_logging.get('level')\n            if not console_level:\n                console_logging['level'] = logging.INFO\n            elif type(console_level) == str:\n                try:\n                    console_logging['level'] = getattr(\n                        logging, console_level.upper()\n                    )\n                except AttributeError:\n                    console_logging['level'] = logging.INFO\n```", "```py\nlogging:\n    console:\n        level: error\n    file:\n        level: debug\n        logfile: /var/log/daemon-name.log\n    format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    name: daemon-name\n```", "```py\ndef __init__(self, config_file:(str,)):\n    \"\"\"\nObject initialization.\nself .............. (BaseDaemon instance, required) The instance to \n                    execute against\nconfig_file ....... (str, file-path, required) The location of the \n                    configuration-file to be used to configure the \n                    daemon instance\n\"\"\"\n    # - Call parent initializers if needed\n    # - Set default instance property-values using _del_... methods\n    self._del_config_file()\n    self._del_logger()\n    # - Set instance property-values from arguments using \n    #   _set_... methods\n    self._set_config_file(config_file)\n    # - Perform any other initialization needed\n    # - Read configuration and override items as needed\n    self.configure()\n    # - Set up logging\n    self._create_logger()\n    # - Set up handlers to allow graceful shut-down\n    signal.signal(signal.SIGINT, self.stop)\n    signal.signal(signal.SIGTERM, self.stop)\n    self.debug(\n        'SIGINT and SIGTERM handlers for %s created' % \n        (self.__class__.__name__)\n    )\n    # - Set up the local flag that indicates whether we're expected \n    #   to be running or not:\n    self._running = False\n```", "```py\n@abc.abstractmethod\ndef main(self):\n    \"\"\"\nThe main event-loop (or whatever is equivalent) for the service instance.\n\"\"\"\n    raise NotImplementedError(\n        '%s.main has not been implemented as required by '\n        'BaseDaemon' % (self.__class__.__name__)\n    )\n```", "```py\n    def cleanup(self):\n        \"\"\"\nPerforms whatever clean-up actions/activities need to be executed after the main process-loop terminates. Override this in your daemon-class if needed, otherwise it can be left alone.\n\"\"\"\n        self.info('%s.cleanup called' % (self.__class__.__name__))\n\n    def preflight(self):\n        \"\"\"\nPerforms whatever pre-flight actions/activities need to be executed before starting the main process. Override this in your daemon-class if needed, otherwise it can be left alone.\n\"\"\"\n        self.info('%s.preflight called' % (self.__class__.__name__))\n```", "```py\ndef start(self):\n    \"\"\"\nStarts the daemon/service that the instance provides.\n\"\"\"\n    if self._running:\n        self.info(\n            '%s instance is already running' %     (self.__class__.__name__)\n        )\n        return\n    self.preflight()\n    self.info('Starting %s.main' % self.__class__.__name__)\n    self.main()\n    self.cleanup()\n\ndef stop(self, signal_num:(int,None)=None, frame:(FrameType,None)=None):\n    \"\"\"\nStops the daemon-process. May be called by a signal event-handler, in which case the signal_num and frame values will be passed. Can also be called directly without those argument-values.\n\nsignal_num ........ (int, optional, defaults to None) The signal-number, if any, that prompted the shutdown.\nframe ............. (Stack-frame, optional, defaults to None) The associated stack-frame.\n\"\"\"\n    self.info('Stopping %s' % self.__class__.__name__)\n    self.debug('+- signal_num ... %s' % (signal_num))\n    self.debug('+- frame ........ %s' % (frame))\n    self._running = False\n\ndef restart(self):\n    \"\"\"\nRestarts the daemon-process by calling the instance's stop then start methods. This may not be directly accessible (at least not in any useful fashion) outside the running instance, but external daemon/service managers should be able to simply kill the running process and start it up again.\n\"\"\"\n    self.info('Restarting %s' % self.__class__.__name__)\n    self.stop()\n    self.start()\n```", "```py\n#######################################\n#   Standard library imports needed   #\n#######################################\n\nimport atexit\nimport logging\nimport os\nimport signal\nimport yaml\n\nfrom types import FrameType    # Used by the signal handlers \n```", "```py\nclass testdaemon(BaseDaemonizable):\n    def _on_configuration_loaded(self, **config_data):\n        try:\n            BaseDaemonizable._on_configuration_loaded(self, **config_data)\n            self.info('%s configuration has been loaded:' % \n                (self.__class__.__name__)\n            )\n        except Exception as error:\n            self.error(\u2018%s: %s' % (error.__class__.__name__, error))\n    def main(self):\n        iteration = 0\n        self._running = True\n        self.info('Starting main daemon event-loop')\n        while self._running:\n            iteration += 1\n            msg = 'Iteration %d' % iteration\n            self.info(msg)\n            sleep(10)\n        self.info('%s main loop terminated' % (self.__class__.__name__))\n```", "```py\n    @classmethod\n    def register_handler(cls, handler_class:(type,), *keys):\n        \"\"\"\nRegisters a BaseRequestHandler *class* as a candidate for handling \nrequests for the specified keys\n\"\"\"\n        if type(handler_class) != type \\\n            or not issubclass(handler_class, BaseRequestHandler):\n            raise TypeError(\n                '%s.register_handler expects a *class* derived from '\n                'BaseRequestHandler as its handler_class argument, but '\n                'was passed \"%s\" (%s), which is not such a class' % \n                (cls.__name__, value, type(value).__name__)\n            )\n        if not keys:\n            raise ValueError(\n                '%s.register_handler expects one or more keys, each '\n                'a string-value, to register the handler-class with, '\n                'but none were provided' % (cls.__name__)\n            )\n        # - Check for malformed keys\n        bad_keys = [\n            key for key in keys\n            if type(key) != str or '\\n' in key or '\\r' in key\n            or '\\t' in key or key.strip() != key or not key.strip()\n        ]\n        if bad_keys:\n            raise ValueError(\n                '%s.register_handler expects one or more keys, each a '\n                'single-line, non-empty string-value with no leading '\n                'or trailing white-space, and no white-space other '\n                'than spaces, but was passed a list including %s, '\n                'which do not meet these criteria' % \n                (cls.__name__, '\"' + '\", \"'.join(bad_keys) + '\"')\n            )\n        # - Check for keys already registered\n        existing_keys = [\n            key for key in keys if key in cls._handler_classes.keys()\n        ]\n        if existing_keys:\n            raise KeyError(\n                '%s.register_handler is not allowed to replace handler-'\n                'classes already registered, but is being asked to do '\n                'so for %s keys' % \n                (cls.__name__, '\"' + '\", \"'.join(existing_keys) + '\"')\n            )\n        # - If this point is reached, everything is hunky-dory, so add \n        #   the handler_class for each key:\n        for key in keys:\n            cls._handler_classes[key] = handler_class\n```", "```py\ndef find_request_handler(self, key:(str,)):\n    \"\"\"\nFinds a registered BaseRequestHandler class that is expected to be able \nto handle the request signified by the key value, creates an instance \nof the class, and returns it.\n\"\"\"\n    # - Set up the _handler_keys if it hasn't been defined yet. \n    #   The goal here is to have a list of registered keys, sorted from \n    #   longest to shortest so that we can match based on the \n    #   longest registered key/path/command-name/whatever that \n    #   matches the incoming value:\n    if not self.__class__._handler_keys:\n        self.__class__._handler_keys = sorted(\n            self.__class__._handler_classes.keys(),\n            key=lambda k: len(k), \n            reverse=True\n        )\n    # - Find the first (longest) key that matches the incoming key:\n    for candidate_key in self.__class__._handler_keys:\n        if candidate_key.startswith(key):\n        # - If we find a match, then create an instance of \n        #   the class and return it\n            result = self.__class__._handler_classes[candidate_key]\n            return result(self)\n    return None\n```", "```py\nclass callable_class:\n    def __init__(self, some_arg, some_other_arg):\n        self._some_arg = some_arg\n        self._some_other_arg = some_other_arg\n\n    def __call__(self, arg):\n        print('%s(%s) called:' % (self.__class__.__name__, arg))\n        print('+- self._some_arg ......... %s' % (self._some_arg))\n        print('+- self._some_other_arg ... %s' % (self._some_other_arg))\n```", "```py\ninstance1 = callable_class('instance 1', 'other arg')\ninstance1('calling instance 1')\n```", "```py\ninstance2 = callable_class('instance 2', 'yet other arg')\ninstance2('calling instance 2')\n```", "```py\nclass BaseRequestHandler(metaclass=abc.ABCMeta):\n    \"\"\"\nProvides baseline functionality, interface requirements, and \ntype-identity for objects that can process daemon/service requests, \ngenerating and returning a response, serialized to some string-based \nformat.\n\"\"\"\n```", "```py\n    ###################################\n    #    Class attributes/constants   #\n    ###################################\n\n    _default_formatter = None\n```", "```py\n    ###################################\n    #    Property-getter methods      #\n    ###################################\n\n    def _get_daemon(self) -> (BaseDaemon,):\n        return self._daemon\n    ###################################\n    #    Property-setter methods      #\n    ###################################\n\n    def _set_daemon(self, value:(BaseDaemon,)) -> None:\n        if not isinstance(value, BaseDaemon):\n            raise TypeError(\n                '%s.daemon expects an instance of a class derived '\n                'from BaseDaemon, but was passed \"%s\" (%s)' % \n                (self.__class__.__name__, value, type(value).__name__)\n            )\n        self._daemon = value\n\n    ###################################\n    #    Property-deleter methods     #\n    ###################################\n\n    def _del_daemon(self) -> None:\n        self._daemon = None\n\n    ###################################\n    #  Instance property definitions  #\n    ###################################\n\n    daemon = property(\n        _get_daemon, None, None, \n        'Gets, sets or deletes the daemon associated with the instance'\n    )\n```", "```py\n    ###################################\n    #     Object initialization       #\n    ###################################\n\n    def __init__(self, daemon:(BaseDaemon,)):\n        \"\"\"\nObject initialization.\nself .............. (BaseRequestHandler instance, required) The \n                    instance to execute against\ndaemon ............ (BaseDaemon instance, required) The daemon that the \n                    request to be handled originated with.\n\"\"\"\n# - Set default instance property-values using _del_... methods\n        self._del_daemon()\n# - Set instance property-values from arguments using \n#   _set_... methods\n        self._set_daemon(daemon)\n```", "```py\n    ###################################\n    #        Abstract methods         #\n    ###################################\n\n    @abc.abstractmethod\n    def __call__(self, request:(dict,), formatter=None) -> (str,):\n\"\"\"\nMakes the instance callable, providing a mechanism for processing the \nsupplied request, generating a data-structure containing the response \nfor the request, formatting that response, and returning it.\nself .............. (BaseRequestHandler instance, required) The instance to execute against\n```", "```py\nrequest ........... (dict, required) The request to be handled\nformatter ......... (BaseResponseFormatter instance, optional, if not \n\"\"\"\n        pass\n```", "```py\n    def _set_request_handler(self, value:(BaseRequestHandler,)) -> None:\n        if not isinstance(value, BaseRequestHandler):\n            raise TypeError(\n                '%s.request_handler expects an instance of a class '\n                'derived from BaseRequestHandler, but was passed '\n                '\"%s\" (%s)' % \n                (self.__class__.__name__, value, type(value).__name__)\n            )\n        self._request_handler = value\n```", "```py\n    def __init__(self, \n        daemon:(BaseDaemon,), \n        request_handler:(BaseRequestHandler,),\n    ):\n\"\"\"\nObject initialization.\n\nself .............. (BaseResponseFormatter instance, required) The \n                    instance to execute against\ndaemon ............ (BaseDaemon instance, required) The daemon that the \n                    request to be handled originated with.\nrequest_handler ... (BaseRequesthandler instance, required) The request-handler object associated with the instance.\n\"\"\"\n        # - Set default instance property-values using _del_... methods\n        self._del_daemon()\n        self._del_request_handler()\n        # - Set instance property-values from arguments using \n        #   _set_... methods\n        self._set_daemon(daemon)\n        self._set_request_handler(request_handler)\n```", "```py\n    @abc.abstractmethod\n    def __call__(self, response:(dict,)) -> (str,):\n        \"\"\"\nMakes the instance callable, providing a mechanism for formatting a \nstandard response-dictionary data-structure.\n\nself .............. (BaseRequestHandler instance, required) The \n                    instance to execute against\nresponse .......... (dict, required) The response to be formatted\n\"\"\"\n        pass\n```", "```py\n[Unit]\nDescription=testdaemon: a simple service example written in Python\n\n[Service]\nType=forking\nExecStart=/usr/bin/python /usr/local/bin/testdaemon.py\nExecStop=/usr/bin/pkill -f testdaemon.py\n```", "```py\n#!/usr/bin/env python\n\n# - Import the service-class\n    from some_package import testdaemon\n# - The location of the config-file\n    config_file = '/path/to/config.yaml'\n# - Create an instance of the service class\n    d = testdaemon(config_file)\n# - Start it.\n    d.start()\n```", "```py\nsystemctl start testdaemon.service\n\nsystemctl restart testdaemon.service\n\nsystemctl stop testdaemon.service\n```", "```py\nsystemctl enable testdaemon.service\n```", "```py\n...\nExecStop=/usr/bin/pkill -f testdaemon.py\n\n[Install]\nWantedBy=multi-user.target\n```", "```py\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n    <dict>\n        <key>Label</key>\n        <string>testdaemon</string>\n        <key>Program</key>\n        <string>/path/to/python</string>\n        <key>ProgramArguments</key>\n        <string>/path/to/testdaemon.py</string>\n        <key>RunAtLoad</key>\n        <true/>\n        <!-- \n            A very basic keep-alive directive. There may be better options:\n            See \"SuccessfulExit\" and \"Crashed\" subkeys\n        -->\n        <key>KeepAlive</key>\n        <true/>\n    </dict>\n</plist>\n```", "```py\nlaunchctl start testdaemon.service\n\nlaunchctl restart testdaemon.service\n\nlaunchctl stop testdaemon.service\n```", "```py\n#!/bin/sh\n\n# - The action we're concerned with appears as $1 in a standard \n#   bash-script\n    case $1 in\n        start)\n            echo \"Starting $0\"\n            /usr/bin/python /usr/local/bin/testdaemon.py\n            ;;\n        stop)\n            echo \"Stopping $0\"\n            /usr/bin/pkill -f testdaemon.py\n            ;;\n        restart)\n            echo \"Restarting $0\"\n            /usr/bin/pkill -f testdaemon.py\n            /usr/bin/python /usr/local/bin/testdaemon.py\n            ;;\n    esac\n```"]