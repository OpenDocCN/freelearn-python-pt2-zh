["```py\n{\n    \"oid\": \"a7393e5c-c30c-4ea4-8469-e9cd4287714f\", \n    \"modified\": \"2018-08-19 07:13:43\", \n    \"name\": \"Example Product\", \n    \"created\": \"2018-08-19 07:13:43\", \n    \"description\": \"Description  TBD\", \n    \"metadata\":{\n        \"wood\": \"Cherry, Oak\"\n    }, \n    \"available\": false, \n    \"dimensions\": \"2\u00bd\\\" x 4\\\" x \u00be\\\"\", \n    \"shipping_weight\": 0.5, \n    \"summary\": \"Summary TBD\", \n}\n```", "```py\n{\n    \"data\":{\n        \"oid\": \"a7393e5c-c30c-4ea4-8469-e9cd4287714f\", \n        \"modified\": \"2018-08-19 07:41:56\", \n        \"name\": \"Example Product\", \n        \"created\": \"2018-08-19 07:13:43\", \n        \"description\": \"Cherry and oak business-card holder\", \n        \"metadata\": {\n            \"wood\": \"Cherry, Oak\"\n        }, \n        \"available\": true, \n        \"dimensions\": \"2\u00bd\\\" x 4\\\" x \u00be\\\"\", \n        \"shipping_weight\": 0.5, \n        \"summary\": \"Cherry and oak business-card holder\", \n    },\n    \"operation\":\"update\",\n    \"signature\":\"{Hash hexdigest}\"\n}\n```", "```py\nclass DaemonMessage(object):\n    \"\"\"\nRepresents a *signed* message being sent to or received from a \nBaseDaemon instance.\n\"\"\"\n    ###################################\n    # Class attributes/constants      #\n    ###################################\n\n    # - class-constant encoding-type for signature processes\n    __encoding = 'utf-8'\n```", "```py\n    ###################################\n    # Property-getter methods         #\n    ###################################\n\n# ...\n\n    def _get_signature(self) -> str:\n        if not self.data:\n            raise RuntimeError(\n                '%s.signature cannot be calculated because there is '\n                'no data to sign' % (self.__class__.__name__)\n            )\n        if not self.signing_key:\n            raise RuntimeError(\n                '%s.signature cannot be calculated because there is '\n                'no key to sign data with' % (self.__class__.__name__)\n            )\n        return sha512(\n            bytes(\n                # - We're using json.dumps to assure a consistent \n                #   key-order here...\n                json.dumps(self.data, sort_keys=True), self.__encoding\n            ) + self.signing_key\n        ).hexdigest()\n```", "```py\n    ###################################\n    # Instance property definitions   #\n    ###################################\n\n    data = property(\n        _get_data, _set_data, _del_data, \n        'Gets, sets, or deletes the data/content of the message'\n    )\n    operation = property(\n        _get_operation, _set_operation, _del_operation, \n        'Gets, sets, or deletes the operation of the message'\n    )\n    signature = property(\n        _get_signature, None, None, \n        'Gets the signature of the message'\n    )\nsigning_key = property(\n        _get_signing_key, _set_signing_key, _del_signing_key, \n        'Gets, sets, or deletes the signing_key of the message'\n    )\n```", "```py\n    ###################################\n    # Object initialization           #\n    ###################################\n\n    def __init__(self, \n        operation:(str,None)=None, data:(dict,None)=None, \n        signing_key:(bytes,str,None)=None\n    ):\n        \"\"\"\nObject initialization.\n\nself .............. (DaemonMessage instance, required) The instance to \n                    execute against\noperation ......... (str, optional, defaults to None) The operation \n                    ('create', 'update', 'delete' or 'response') that \n                    the message is requesting\ndata .............. (dict, optional, defaults to None) The data of the \n                    message\nsigning_key ....... (bytes|str, optional, defaults to None) The raw \n                    data of the signing-key to be used to generate the \n                    message-signature.\n\"\"\"\n        # - Call parent initializers if needed\n        # - Set default instance property-values using _del_... methods\n        self._del_data()\n        self._del_operation()\n        self._del_signing_key()\n        # - Set instance property-values from arguments using \n        #   _set_... methods\n        if operation:\n            self.operation = operation\n        if data:\n            self.data = data\n        if signing_key:\n            self.signing_key = signing_key\n```", "```py\n    def to_message_dict(self):\n        return {\n            'data':self.data,\n            'operation':self.operation,\n            'signature':self.signature,\n        }\n\n    def to_message_json(self):\n        return json.dumps(self.to_message_dict())\n```", "```py\n    @classmethod\n    def from_message_dict(cls, \n        message_dict:(dict,), signing_key:(bytes,str)\n    ):\n        \"\"\"\nmessage_dict ...... (dict, required) The incoming message as a dict, \n                    that is expected to have the following structure:\n                    {\n                        'data':dict,\n                        'operation':str, # (create|update|delete|response)\n                        'signature':str # (hash hex-digest)\n                    }\nsigning_key ....... (bytes|str, optional, defaults to None) The raw \n                    data of the signing-key to be used to generate the \n                    message-signature.\n\"\"\"\n```", "```py\n        if type(message_dict) != dict:\n            raise TypeError(\n                '%s.from_message_dict expects a three-element '\n                'message_dict value ({\"data\":dict, \"signature\":str, '\n                '\"operation\":str}), but was passed \"%s\" (%s)' % \n                (cls.__name__, data, type(data).__name__)\n            )\n        if type(signing_key) not in (bytes,str):\n            raise TypeError(\n                '%s.from_message_dict expects a bytes or str signing_key '\n                'value, but was passed \"%s\" (%s)' % \n                (cls.__name__, signing_key, type(signing_key).__name__)\n            )\nif type(signing_key) == str:\n            signing_key = bytes(signing_key, cls.__encoding)\n```", "```py\n        _data = message_dict.get('data')\n        if not _data:\n            raise ValueError(\n                '%s.from_message_dict expects a three-element dict '\n                '({\"data\":dict, \"signature\":str, \"operation\":str}), '\n                'but was passed \"%s\" (%s) which did not include a '\n                '\"data\" key' % \n                (cls.__name__, data, type(data).__name__)\n            )\n        _signature = message_dict.get('signature')\n        if not _signature:\n            raise ValueError(\n                '%s.from_message_dict expects a three-element dict '\n                '({\"data\":dict, \"signature\":str, \"operation\":str}), '\n                'but was passed \"%s\" (%s) which did not include a '\n                '\"signature\" key' % \n                (cls.__name__, data, type(data).__name__)\n            )\n        _operation = message_dict.get('operation')\n        if not _operation:\n            raise ValueError(\n                '%s.from_message_dict expects a three-element dict '\n                '({\"data\":dict, \"operation\":str, \"operation\":str}), '\n                'but was passed \"%s\" (%s) which did not include a '\n                '\"operation\" key' % \n                (cls.__name__, data, type(data).__name__)\n            )\n        result = cls(_operation, _data, signing_key)\n```", "```py\n        if result.signature == _signature:\n            return result\n        raise InvalidMessageError(\n            'The message %s, with a signature of \"%s\" did not match '\n            'the expected signature. Message DENIED' % \n            (_data, result.signature)\n        )\n```", "```py\n    @classmethod\n    def from_message_json(cls, json_in:(str,), signing_key:(bytes,str)):\n        return cls.from_message_dict(json.loads(json_in), signing_key)\n```", "```py\nos.urandom(1024)\n```", "```py\nimport os\n\nexample_key = os.urandom(1024)\nprint(example_key)\n\nexample_key_hex = example_key.hex()\nprint(example_key_hex)\n\nexample_from_hex = bytes.fromhex(example_key_hex)\nprint(example_from_hex == example_key)\n\n# Yields:\n# b'!\\x0cW\\xe5\\x89\\x7fan ... a LOT more gibberish-looking characters...'\n# 210c57e5897f616ec9157f759617e7b4f ... a LOT more hexadecimal digits...\n# True\n```", "```py\n#!/usr/bin/env python\n# - scratch-space/rabbitmq-sender.py\n# - Derived from RabbitMQ - RabbitMQ tutorial - \"Hello world!\"\n#   https://www.rabbitmq.com/tutorials/tutorial-one-python.html\n\n# The pika library is for communicating with RabbitMQ\nimport pika\n\n# Use DaemonMessage to format our messages\nfrom hms_core.daemons import DaemonMessage\n```", "```py\n# Message-items\n# - Signing-key\nsigning_key = '!:iLL>S@]BN;h%\"h\\'<2cPGsaKA 3vbGJ'\n# - Message data (a dict)\n```", "```py\nmessage_data = {\n    'hello':'Hello from %s' % __file__,\n    'random_number':3, # not a random number yet\n}\n```", "```py\n# - The actual message to be sent\nmessage = DaemonMessage(\n    'response', message_data, signing_key\n)\n```", "```py\n# RabbitMQ connection and related items\n# - Create a connection\nconnection = pika.BlockingConnection(\n    pika.ConnectionParameters('localhost')\n)\n# - Create (or at least specify) a channel\nchannel = connection.channel()\n# - Create or specify a queue\nchannel.queue_declare(queue='hello')\n```", "```py\n# Send the message\nchannel.basic_publish(\n    exchange='', routing_key='hello', \n    body=message.to_message_json()\n)\n\n# Close the connection\nconnection.close()\n```", "```py\n# - Create or specify a queue\nchannel.queue_declare(queue='hello')\n\n# Send the message\nchannel.basic_publish(\n    exchange='', routing_key='hello', \n    body=message.to_message_json()\n)\n```", "```py\n# - Create or specify a queue\nchannel.queue_declare(queue='queue_name') # Changed here\n\n# Send the message\nchannel.basic_publish(\n    exchange='', routing_key='queue_name',  # Changed here also\n    body=message.to_message_json()\n)\n```", "```py\n#!/usr/bin/env python\n# - scratch-space/rabbitmq-receiver.py\n# - Derived from RabbitMQ - RabbitMQ tutorial - \"Hello world!\"\n#   https://www.rabbitmq.com/tutorials/tutorial-one-python.html\n\nimport pika\n\nfrom pprint import pprint\nfrom hms_core.daemons import DaemonMessage\n```", "```py\nsigning_key = '!:iLL>S@]BN;h%\"h\\'<2cPGsaKA 3vbGJ'\n```", "```py\n# - Define a message-handler function\ndef message_handler(ch, method, properties, body):\n    print('Handling a message:')\n    # - Some print-output removed to keep the listing here shorter\n```", "```py\n    try:\n        message = DaemonMessage.from_message_json(\n            body.decode(), signing_key\n        )\n        print(\n            '+- message ........ (%s) %r' % \n            (type(message).__name__, message)\n        )\n        print(\n            '   +- operation ... (%s) %r' % \n            (type(message.operation).__name__, message.operation)\n        )\n        print(\n            '   +- signature ... (%s) %r' % \n            (type(message.signature).__name__, message.signature)\n        )\n        print(\n            '   +- data ........ (%s)' % \n            (type(message.data).__name__)\n        )\n        print('-- Message-data '.ljust(80,'-'))\n        pprint(message.data)\n        print('='*80)\n    except Exception as error:\n        print('%s: %s' % (error.__class__.__name__, error))\n```", "```py\n# Create a connection\nconnection = pika.BlockingConnection(\n    pika.ConnectionParameters('localhost')\n)\n# - Create (or at least specify) a channel\nchannel = connection.channel()\n# - Create or specify a queue\nchannel.queue_declare(queue='hello')\n```", "```py\n# - Set up a consumer\nchannel.basic_consume(\n    message_handler, queue='hello', no_ack=True\n)\n```", "```py\n# - Listen for messages\nprint('Listening for messages:')\nprint('='*80)\nchannel.start_consuming()\n```", "```py\n#!/usr/bin/env python\n# - scratch-space/rabbitmq-bad-sender.py\n# - Derived from RabbitMQ - RabbitMQ tutorial - \"Hello world!\"\n#   https://www.rabbitmq.com/tutorials/tutorial-one-python.html\n\n# ... Interim script-code removed for brevity\n\n# Message-items\n# - Signing-key\nsigning_key = 'Invalid signing key'\n\n# ...\n```", "```py\nclass ArtisanGatewayDaemon(BaseDaemon):\n    \"\"\"\nProvides the main ArtisanGateway daemon/service.\n\"\"\"\n```", "```py\n    def _handle_message(self, message:(dict,)) -> None:\n        self.info(\n            '%s._handle_message called:' % self.__class__.__name__\n        )\n        self.info(str(message))\n```", "```py\n    def main(self):\n        \"\"\"\nThe main event-loop (or whatever is equivalent) for the service instance.\n\"\"\"\n```", "```py\n        signing_key = '!:iLL>S@]BN;h%\"h\\'<2cPGsaKA 3vbGJ'\n        connection = pika.BlockingConnection(\n            pika.ConnectionParameters('localhost')\n        )\n        channel = connection.channel()\n        channel.queue_declare(queue='hello')\n```", "```py\n    # - To start with, we're just going to use the same \n    #   parameters for our pika connection and channel as \n    #   were used in the rabbitmq-sender.py script.\n    connection = pika.BlockingConnection(\n        pika.ConnectionParameters(\n            self.connection_params['host'],\n            self.connection_params.get('port'),\n            self.connection_params.get('path'),\n        )\n    )\n    # - Create (or at least specify) a channel\n    channel = connection.channel()\n    # - Create or specify a queue\n    channel.queue_declare(queue=self.queue_name)\n```", "```py\n    # - Normal BaseDaemon main-loop start-up:\n    self._running = True\n    self.info('Starting main daemon event-loop')\n    # - Rather than use a channel-consumer (see the example in \n    #   rabbitmq-reciever.py), we're going to actively poll for \n    #   messages *ourselves*, in order to capture just the \n    #   message-body - that's what we really care about in \n    #   this case...\n    while self._running:\n        try:\n            # - Retrieve the next message from the queue, if \n            #   there is one, and handle it...\n            method_frame, header, body = channel.basic_get(self.queue_name)\n            if method_frame:\n                # - Any actual message, valid or not, will \n                #   generate a method_frame\n                self.debug('received message:')\n                message = DaemonMessage.from_message_json(\n                    body.decode(), self.signing_key\n                )\n                self.debug('+- %s' % message.data)\n                # - If we've received the message and processed \n                #   it, acknowledge it on basic principle\n                channel.basic_ack(method_frame.delivery_tag)\n                self._handle_message(message)\n        except InvalidMessageError as error:\n            # - If message-generation fails (bad signature), \n            #   we still need to send an acknowledgement in order \n            #   to clear the message from the queue\n            err = '%s: %s' % (error.__class__.__name__, error)\n            self.error(err)\n            channel.basic_ack(method_frame.delivery_tag)\n        except Exception as error:\n            # Otherwise, we just log the error and move on\n            err = '%s: %s' % (error.__class__.__name__, error)\n            self.error(err)\n            for line in traceback.format_exc().split('\\n'):\n                self.error(line)\n    self.info('%s main loop terminated' % (self.__class__.__name__))\n```", "```py\n# Logging configuration\n# scratch-space/hms_ag_conf.yaml\nlogging:\n  format: \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n  name: hms_ag\n  console:\n    level: info\n  file:\n    level: info\n    logfile: \"/tmp/hms_ag.log\"\n```", "```py\nqueue:\n  type: rabbit\n  connection:\n    host: localhost\n    port: 5672\n    path: /\n  queue_name: \"central-office\"\nsigning_key: \"0T*)B{Y#.C3yY8J>;1#<b\\\\q^:.@ZQjg2 tG~3(MJab_\"\n```", "```py\n    def _on_configuration_loaded(self, **config_data):\n        # - Call the BaseDaemon function directly to set up logging, \n        #   since that's provided entirely there...\n        BaseDaemon._on_configuration_loaded(self, **config_data)\n```", "```py\n        queue_config = config_data.get('queue')\n        if queue_config:\n            try:\n                if queue_config['type'] == 'rabbit':\n                    self._connection_params = queue_config['connection']\n                    self.info(\n                        'Connection-parameters: %s' % \n                        self.connection_params\n                        )\n                    self._queue_name = queue_config['queue_name']\n                    self.info(\n                        'Main queue-name: %s' % self.queue_name\n                        )\n                # If other queue-types are eventually to be supported, \n                # their configuration-load processes can happen here, \n                # following this pattern:\n                # elif queue_config['type'] == 'name':\n                #    # Configuration set-up for this queue-type...\n                else:\n                    raise RuntimeError(\n                        '%s could not be configured because the '\n                        'configuration supplied did not specify a '\n                        'valid queue-type (%s)' % \n                        (self.__class__.__name__, queue_config['type'])\n                    )\n            except Exception as error:\n                raise RuntimeError(\n                    '%s could not be configured because of an '\n                    'error -- %s: %s' % \n                    (\n                        self.__class__.__name__, \n                        error.__class__.__name__, error\n                    )\n                )\n        else:\n            raise RuntimeError(\n                '%s could not be configured because the configuration '\n                'supplied did not supply message-queue configuration' % \n                (self.__class__.__name__)\n            )\n```", "```py\n        # - The signing-key is also in configuration, so get it too\n        try:\n            self._signing_key = config_data['signing_key']\n        except Exception as error:\n            raise RuntimeError(\n                '%s could not be configured because of an error '\n                'retrieving the required signing_key value -- %s: %s' % \n                (\n                    self.__class__.__name__, \n                    error.__class__.__name__, error\n                )\n            )\n```", "```py\n{\n    \"data\":{\n        \"target\":\"artisan\",\n        \"properties\":{\n            \"address\":\"1234 Main Street, etc.\",\n            \"company_name\":\"Wirewerks\",\n            \"contact_email\":\"jsmith@wirewerks.com\",\n            \"contact_name\":\"John Smith\",\n            \"website\":\"http://wirewerks.com\",\n        }\n    },\n    \"operation\":\"create\",\n    \"signature\":\"A long hex-string\"\n}\n```", "```py\n{\n    \"data\":{\n        \"target\":\"artisan\",\n        \"properties\":{\n            \"address\":\"5432 West North Dr, etc.\",\n            \"modified\":\"2019-06-27 16:42:13\",\n            \"oid\":\"287db9e0-2fcc-4ff1-bd59-ff97a07f7989\",\n        }\n    },\n    \"operation\":\"update\",\n    \"signature\":\"A long hex-string\"\n}\n```", "```py\n{\n    \"data\":{\n        \"target\":\"artisan\",\n        \"properties\":{\n            \"oid\":\"287db9e0-2fcc-4ff1-bd59-ff97a07f7989\",\n        }\n    },\n    \"operation\":\"delete\",\n    \"signature\":\"A long hex-string\"\n}\n```", "```py\n{\n    \"data\":{\n        \"target\":\"artisan\",\n        \"properties\":{\n            \"oid\":\"287db9e0-2fcc-4ff1-bd59-ff97a07f7989\",\n        }\n    },\n    \"operation\":\"response\",\n    \"signature\":\"A long hex-string\"\n}\n```", "```py\ndef _handle_message(self, message:(dict,)) -> None:\n    self.info(\n        '%s._handle_message called:' % self.__class__.__name__\n    )\n```", "```py\n    target = message.data.get('target')\n    properties = message.data.get('properties')\n```", "```py\n    if message.operation == 'create':\n```", "```py\n        if target == 'artisan':\n            self.create_artisan(properties)\n        elif target == 'customer':\n            self.create_customer(properties)\n        elif target == 'order':\n            self.create_order(properties)\n        elif target == 'product':\n            self.create_product(properties)\n```", "```py\n        else:\n            raise RuntimeError(\n                '%s error: \"%s\" (%s) is not a recognized '\n                'object-type/target' % \n                (\n                    self.__class__.__name__, target, \n                    type(target).__name__\n                )\n            )\n```", "```py\n    elif message.operation == 'update':\n        if target == 'artisan':\n            self.update_artisan(properties)\n        elif target == 'customer':\n            self.update_customer(properties)\n        elif target == 'order':\n            self.update_order(properties)\n        elif target == 'product':\n            self.update_product(properties)\n        else:\n            raise RuntimeError(\n                '%s error: \"%s\" (%s) is not a recognized '\n                'object-type/target' % \n                (\n                    self.__class__.__name__, target, \n                    type(target).__name__\n                )\n            )\n```", "```py\n    else:\n        raise RuntimeError(\n            '%s error: \"%s\" (%s) is not a recognized '\n            'operation' % \n            (\n                self.__class__.__name__, operation, \n                type(operation).__name__\n            )\n        )\n```", "```py\ndef create_artisan(self, properties:(dict,)) -> None:\n    self.info('%s.create_artisan called' % self.__class__.__name__)\n    self.debug(str(properties))\n    # - Create the new object...\n    new_object = Artisan.from_data_dict(properties)\n    #   ...and save it.\n    new_object.save()\n```", "```py\ndef update_artisan(self, properties:(dict,)) -> None:\n    self.info('%s.update_artisan called' % self.__class__.__name__)\n    self.debug(str(properties))\n    # - Retrieve the existing object, and get its data-dict \n    #   representation\n    existing_object = Artisan.get(properties['oid'])\n    data_dict = existing_object.to_data_dict()\n    # - Update the data-dict with the values from properties\n    data_dict.update(properties)\n    # - Make sure it's flagged as dirty, so that save will \n    #   *update* instead of *create* the instance-record, \n    #   for data-stores where that applies\n    data_dict['is_dirty'] = True\n    # - Create a new instance of the class with the revised \n    #   data-dict...\n    new_object = Artisan.from_data_dict(data_dict)\n    #   ...and save it.\n    new_object.save()\n```", "```py\ndef delete_artisan(self, properties:(dict,)) -> None:\n    self.info('%s.delete_artisan called' % self.__class__.__name__)\n    self.debug(str(properties))\n    # - Delete the instance-record for the specified object\n    Artisan.delete(properties['oid'])\n```", "```py\ndef response_artisan(self, properties:(dict,)) -> dict:\n    self.info('%s.response_artisan called' % self.__class__.__name__)\n    self.debug(str(properties))\n    # - Since get allows both oids and criteria, separate those \n    #   out first:\n    oid = properties.get('oid')\n    criteria = {\n        item[0]:item[1] for item in properties.items()\n        if item[0] != 'oid'\n    }\n    return Artisan.get(oid, **criteria)\n```", "```py\ndef _set_queue_id(self, value:(str)) -> None:\n    if type(value) != str:\n        raise TypeError(\n            '%s.queue expects a single-line printable ASCII '\n            'string-value, but was passed \"%s\" (%s)' % \n            (\n                self.__class__.__name__, value, \n                type(value).__name__\n            )\n        )\n    badchars = [\n        c for c in value \n        if ord(c)<32 or ord(c) > 127 \n        or c in '\\n\\t\\r'\n    ]\n    if len(badchars) != 0:\n        raise ValueError(\n            '%s.queue expects a single-line printable ASCII '\n            'string-value, but was passed \"%s\" that contained '\n            'invalid characters: %s' % \n            (\n                self.__class__.__name__, value, \n                str(tuple(badchars))\n            )\n        )\n    self._queue_id = value\n```", "```py\nimport os\n\nraw_key=os.urandom(24)\nprint('raw_key (%s)' % type(raw_key).__name__)\nprint(raw_key)\nprint()\n\nserialized = raw_key.hex()\nprint('serialized (%s)' % type(serialized).__name__)\nprint(serialized)\nprint()\n\nunserialized = bytes.fromhex(serialized)\nprint('unserialized (%s)' % type(unserialized).__name__)\nprint(unserialized)\nprint()\n\nprint('unserialized == raw_key: %s' % (unserialized == raw_key))\n```", "```py\ndef _set_signing_key(self, value:(bytes,str)):\n    if type(value) not in (bytes,str):\n        raise TypeError(\n            '%s.signing_key expects a bytes-value of no less '\n            'than 64 bytes in length, or a hexadecimal string-'\n            'representation of one, but wa passed \"%s\" (%s)' % \n            (self.__class__.__name__, value, type(value).__name__)\n        )\n```", "```py\n    if type(value) == str:\n        try:\n            value = bytes.fromhex(value)\n        except:\n            raise ValueError(\n                '%s.signing_key expects a bytes-value of no '\n                'less than 64 bytes in length, or a hexadecimal '\n                'string-representation of one, but wa passed '\n                '\"%s\" (%s), which could not be converted from '\n                'hexadecimal into bytes' % \n                (\n                    self.__class__.__name__, value, \n                    type(value).__name__)\n                )\n            )\n```", "```py\n    if len(value) < 64:\n        raise ValueError(\n            '%s.signing_key expects a bytes-value of no less '\n            'than 64 bytes in length, or a hexadecimal string-'\n            'representation of one, but wa passed \"%s\" (%s), '\n            'which was only %d bytes in length after conversion' % \n            (\n                self.__class__.__name__, value, \n                type(value).__name__, len(value)\n            )\n        )\n    self._signing_key = value\n```", "```py\ndef to_data_dict(self) -> (dict,):\n    return {\n        # - BaseArtisan-derived items\n        'address':self.address.to_dict() if self.address else None,\n        'company_name':self.company_name,\n        'contact_email':self.contact_email,\n        'contact_name':self.contact_name,\n        'website':self.website, \n        # - BaseDataObject-derived items\n        'created':datetime.strftime(\n            self.created, self.__class__._data_time_string\n        ),\n        'is_active':self.is_active,\n        'is_deleted':self.is_deleted,\n        'modified':datetime.strftime(\n            self.modified, self.__class__._data_time_string\n        ),\n        'oid':str(self.oid),\n        # Queue- and signing-key values\n        'queue_id':self.queue_id,\n        'signing_key':self.signing_key.hex(),\n    }\n```", "```py\ndef __init__(self, \n    contact_name:str, contact_email:str, \n    address:Address, company_name:str=None, \n    queue_id:(str,None)=None, signing_key:(bytes,str,None)=None, \n    website:(str,None)=None\n    *products\n    ):\n    \"\"\"Doc-string omitted for brevity\"\"\"\n    # - Call parent initializers if needed\n    # ... omitted for brevity\n    # - Set instance property-values from arguments using \n    #   _set_... methods\n    self._set_contact_name(contact_name)\n    self._set_contact_email(contact_email)\n    self._set_address(address)\n    # New queue_id and signing_key properties\n    self._set_queue_id(queue_id)\n    self._set_signing_key(signing_key)\n    if company_name:\n        self._set_company_name(company_name)\n    if website:\n        self._set_website(website)\n```", "```py\ndef __init__(self,\n    contact_name:str, contact_email:str, \n    address:Address, company_name:str=None, \n# New queue_id and signing_key arguments\n    queue_id:(str,None)=None, \n    signing_key:(bytes,str,None)=None, \n    website:(str,None)=None\n    # - Arguments from HMSMongoDataObject\n    oid:(UUID,str,None)=None, \n    created:(datetime,str,float,int,None)=None, \n    modified:(datetime,str,float,int,None)=None,\n    is_active:(bool,int,None)=None, \n    is_deleted:(bool,int,None)=None,\n    is_dirty:(bool,int,None)=None, \n    is_new:(bool,int,None)=None,\n    *products\n):\n    \"\"\"Doc-string omitted for brevity\"\"\"\n    # - Call parent initializers if needed\n    BaseArtisan.__init__(self, \n        contact_name, contact_email, address, company_name, \n# New queue_id and signing_key arguments\n        queue_id, signing_key, \n        website\n    )\n    # ... other initialization omitted for brevity\n    # - Perform any other initialization needed\n```", "```py\nclass RabbitMQSender(object):\n    \"\"\"\nProvides baseline functionality, interface requirements, and \ntype-identity for objects that can send messages to a RabbitMQ \nmessage-queue that shares configuration across all derived \nclasses\n\"\"\"\n    ###################################\n    # Class attributes/constants      #\n    ###################################\n\n    # - Common RabbitMQ parameters\n    _host = None\n    _port = None\n    _queue_name = None\n    _virtual_host = None\n```", "```py\n    def _get_host(self):\n        return self._host\n\n    def _get_port(self):\n        return self._port\n\n    def _get_queue_name(self):\n        return self._queue_name\n\n    def _get_virtual_host(self):\n        return self._virtual_host\n```", "```py\n    host = property(\n        _get_host, None, None, \n        'Gets the host (FQDN or IP-address) of the RabbitMQ '\n        'server that derived objects will send messages to'\n    )\n    port = property(\n        _get_port, None, None, \n        'Gets the TCP/IP port on the RabbitMQ server that '\n        'derived objects will send messages to'\n    )\n    queue_name = property(\n        _get_queue_name, None, None, \n        'Gets the name of the queue on the RabbitMQ server that '\n        'derived objects will send messages to'\n    )\n    virtual_host = property(\n        _get_virtual_host, None, None, \n        'Gets the \"virtual_host\" on the RabbitMQ server that '\n        'derived objects will send messages to'\n    )\n```", "```py\n    def _get_channel(self):\n        try:\n            return self._channel\n        except AttributeError:\n            # - Create (or at least specify) a channel\n            self._channel = self.connection.channel()\n            # - Create or specify a queue\n            self._channel.queue_declare(queue=self._queue_name)\n            return self._channel\n\n    def _get_connection(self):\n        try:\n            return self._connection\n        except AttributeError:\n            self._connection = pika.BlockingConnection(\n                # Parameters \n                pika.ConnectionParameters(\n                    host=self._host,\n                    port=self.port,\n                    virtual_host=self.virtual_host\n                )\n            )\n            return self._connection\n# ...\n\n    channel = property(\n        _get_channel, None, None, \n        'Gets the channel that the instance will send messages to'\n    )\n```", "```py\n    connection = property(\n        _get_connection, None, None, \n        'Gets the connection that the instance will send messages '\n        'with/through'\n    )\n```", "```py\n    @classmethod\n    def configure(cls, \n        queue_name:(str), host:(str,), port:(int,None)=None, \n        virtual_host:(str,None)=None\n    ):\n        cls._queue_name = queue_name\n        cls._host = host\n        if port:\n            cls._port = port\n        if virtual_host:\n            cls._virtual_host = virtual_host\n```", "```py\nRabbitMQSender.configure(\n    queue_name = configuration['queue_name'],\n    host = configuration['host'],\n    port = configuration.get('port'),\n    virtual_host = configuration.get('virtual_host'),\n)\n```", "```py\n    def send_message(self, message:(DaemonMessage)):\n        \"\"\"\nSends the supplied message to the RabbitMG server common to \nall RabbitMQSender objects\n\nself .............. (RabbitMQSender instance, required) The \n                    instance to execute against\nmessage ........... (DaemonMessage, required) The message to send.\n\"\"\"\n        # - Note that exchange is blank -- we're just using the \n        #   default exchange at this point...\n        self.channel.basic_publish(\n            exchange='', routing_key=self.queue_name, \n            body=message.to_message_json()\n        )\n```"]