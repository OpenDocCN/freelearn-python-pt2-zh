["```py\n#!/usr/bin/env python\n\"\"\"\nDefines unit-tests for the module at hms_core.\n\"\"\"\n#######################################\n# Standard library imports needed     #\n#######################################\n\nimport os\nimport sys\nimport unittest\n\n#######################################\n# Local imports needed                #\n#######################################\n\nfrom idic.unit_testing import *\n\n#######################################\n# Module-level Constants              #\n#######################################\n\nLocalSuite = unittest.TestSuite()\n\n#######################################\n# Import the module being tested      #\n#######################################\n```", "```py\nimport hms_core as hms_core\n\n#######################################\n# Code-coverage test-case and         #\n# decorator-methods                   #\n#######################################\n\nclass testhms_coreCodeCoverage(ModuleCoverageTest):\n    # - Class constants that point to the namespace and module \n    #   being tested\n    _testNamespace = 'hms_core'\n    _testModule = hms_core\n\nLocalSuite.addTests(\n    unittest.TestLoader().loadTestsFromTestCase(\n        testhms_coreCodeCoverage\n    )\n)\n\n#######################################\n# Test-cases in the module            #\n#######################################\n\n#######################################\n# Code to execute if file is called   #\n# or run directly.                    #\n#######################################\n\nif __name__ == '__main__':\n    import time\n    results = unittest.TestResult()\n    testStartTime = time.time()\n    LocalSuite.run(results)\n    results.runTime = time.time() - testStartTime\n    PrintTestResults(results)\n    if not results.errors and not results.failures:\n        SaveTestReport(results, 'hms_core',\n            'hms_core.test-results')\n```", "```py\n#######################################\n# Test-cases in the module            #\n#######################################\n\n@testhms_coreCodeCoverage.AddMethodTesting\n@testhms_coreCodeCoverage.AddPropertyTesting\nclass testAddress(unittest.TestCase):\n    pass\nLocalSuite.addTests(\n    unittest.TestLoader().loadTestsFromTestCase(\n        testAddress\n    )\n)\n\n@testhms_coreCodeCoverage.AddMethodTesting\n@testhms_coreCodeCoverage.AddPropertyTesting\nclass testBaseArtisan(unittest.TestCase):\n    pass\nLocalSuite.addTests(\n    unittest.TestLoader().loadTestsFromTestCase(\n        testBaseArtisan\n    )\n)\n\n@testhms_coreCodeCoverage.AddMethodTesting\n@testhms_coreCodeCoverage.AddPropertyTesting\nclass testBaseCustomer(unittest.TestCase):\n    pass\nLocalSuite.addTests(\n    unittest.TestLoader().loadTestsFromTestCase(\n        testBaseCustomer\n    )\n)\n```", "```py\n@testhms_coreCodeCoverage.AddMethodTesting\n@testhms_coreCodeCoverage.AddPropertyTesting\nclass testBaseOrder(unittest.TestCase):\n    pass\nLocalSuite.addTests(\n    unittest.TestLoader().loadTestsFromTestCase(\n        testBaseOrder\n    )\n)\n@testhms_coreCodeCoverage.AddMethodTesting\n@testhms_coreCodeCoverage.AddPropertyTesting\nclass testBaseProduct(unittest.TestCase):\n    pass\nLocalSuite.addTests(\n    unittest.TestLoader().loadTestsFromTestCase(\n        testBaseProduct\n    )\n)\n\n@testhms_coreCodeCoverage.AddMethodTesting\n@testhms_coreCodeCoverage.AddPropertyTesting\nclass testHasProducts(unittest.TestCase):\n    pass\nLocalSuite.addTests(\n    unittest.TestLoader().loadTestsFromTestCase(\n        testHasProducts\n    )\n)\n```", "```py\ndef testproperty_name(self):\n   # Tests the property_name property of the Address class\n   # - Assert that the getter is correct:\n     self.assertEqual(\n         Address.property_name.fget, \n         Address._get_property_name, \n        'Address.property_name is expected to use the '\n        '_get_property_name method as its getter-method'\n     )\n      # - If property_name is not expected to be publicly                       # settable,\n      #   the second item here \n      #   (Address._set_property_name) should \n      #   be changed to None, and the failure message           #   adjusted \n      #   accordingly:\n           self.assertEqual(\n            Address.property_name.fset, \n            Address._set_property_name, \n           'Address.property_name is expected to use the '\n           '_set_property_name method as its setter-method'\n        )\n    #   If property_name is not expected to be publicly     #   deletable,\n    #   the second item here (Address._del_property_name)     #   should \n    #   be changed to None, and the failure message         #   adjusted \n     #   accordingly:\n       self.assertEqual(\n          Address.property_name.fdel, \n          Address._del_property_name, \n          'Address.property_name is expected to use the '\n          '_del_property_name method as its deleter-method'\n      )\n```", "```py\ndef testbuilding_address(self):\n# Tests the building_address property of the Address class\n# - Assert that the getter is correct:\n     self.assertEqual(\n        Address.building_address.fget, \n        Address._get_building_address, \n       'Address.building_address is expected to use the '\n       '_get_building_address method as its getter-method'\n     )\n# - Assert that the setter is correct:\n     self.assertEqual(\n        Address.building_address.fset, \n        Address._set_building_address, \n       'Address.building_address is expected to use the '\n       '_set_building_address method as its setter-method'\n     )\n# - Assert that the deleter is correct:\n       self.assertEqual(\n       Address.building_address.fdel, \n       Address._del_building_address, \n      'Address.building_address is expected to use the '\n      '_del_building_address method as its deleter-method'\n     )\n```", "```py\ndef test_del_building_address(self):\n# Tests the _del_building_address method of the Address \n# class\n   test_object = Address('street address', 'city')\n    self.assertEqual(\n       test_object.building_address, None, \n       'An Address object is expected to have None as its default '\n       'building_address value if no value was provided'\n    )\n# - Hard-set the storage-property's value, call the \n#   deleter-method, and assert that it's what's expected \n#   afterwards:\n    test_object._building_address = 'a test value'\n    test_object._del_building_address()\n    self.assertEqual(\n      test_object.building_address, None, \n      'An Address object is expected to have None as its '\n      'building_address value after the deleter is called'\n    )\n```", "```py\ndef test_get_building_address(self):\n# Tests the _get_building_address method of the Address \n# class\n  test_object = Address('street address', 'city')\n  expected = 'a test-value'\n  test_object._building_address = expected\n  actual = test_object._get_building_address()\n  self.assertEqual(\n    actual, expected, \n   'Address._get_building_address was expected to return '\n   '\"%s\" (%s), but returned \"%s\" (%s) instead' % \n   (\n       expected, type(expected).__name__,\n       actual, type(actual).__name__,\n   )\n)\n```", "```py\ndef test_del_city(self):\n   # Tests the _del_city method of the Address class\n   expected = 'city'\n   test_object = Address('street address', expected)\n   self.assertEqual(\n     test_object.city, expected, \n    'An Address object is expected to have \"%s\" (%s) as its '\n    'current city value, since that value was provided' % \n       (expected, type(expected).__name__)\n     )\n# - Since we have a value, just call the deleter-method, \n#   and \n#   assert that it's what's expected afterwards:\n     test_object._del_city()\n       self.assertEqual(\n         test_object.city, None, \n         'An Address object is expected to have None as its '\n         'city value after the deleter is called'\n     )\n```", "```py\ndef _set_building_address(self, value:(str,None)) -> None:\n    if value != None:\n # - Type-check: If the value isn't None, then it has to \n #   be a non-empty, single-line string without tabs\n    if type(value) != str:\n       raise TypeError(\n       '%s.building_address expects a single-line, '\n       'non-empty str value, with no whitespace '\n       'other than spaces or None, but was passed '\n       '\"%s\" (%s)' % \n          (\n             self.__class__.__name__, value, \n             type(value).__name__\n          )\n                )\n  # - Value-check: no whitespace other than \" \"\n         bad_chars = ('\\n', '\\r', '\\t')\n         is_valid = True\n         for bad_char in bad_chars:\n            if bad_char in value:\n               is_valid = False\n               break\n # - If it's empty or otherwise not valid, raise error\n     if not value.strip() or not is_valid:\n         raise ValueError(\n         '%s.building_address expects a single-line, '\n         'non-empty str value, with no whitespace '\n         'other than spaces or None, but was passed '\n         '\"%s\" (%s)' % \n           (\n              self.__class__.__name__, value, \n              type(value).__name__\n           )\n        )\n # - If this point is reached without error, then the \n #   string-value is valid, so we can just exit the if\n      self._building_address = value\n```", "```py\nGoodStandardOptionalTextLines = [\n    'word', 'hyphenated-word', 'short phrase', \n    'A complete sentence.', \n    'A short paragraph. This\\'s got some punctuation, '\n    'including \"quoted text.\"',\n    None # Because optional items are allowed to be None\n]\n```", "```py\n# - Create an object to test with:\ntest_object = Address('street address', 'street_address')\n# - Test all permutations of \"good\" argument-values:\n  for expected in GoodStandardOptionalTextLines:\n     test_object._set_building_address(expected)\n     actual = test_object._get_building_address()\n     self.assertEqual(\n        expected, actual, \n        'Address expects a building_address value set to '\n        '\"%s\" (%s) to be retrieved with a corresponding '\n        'getter-method call, but \"%s\" (%s) was returned '\n        'instead' % \n     (\n```", "```py\nexpected, type(expected).__name__, \n         actual, type(actual).__name__, \n     )\n  )\n```", "```py\nBadStandardOptionalTextLines = [\n    # Bad string values\n    'multiple\\nlines', 'also multiple\\rlines', \n    'text\\twith\\tabs',\n    # Values that aren't strings at all\n    1, True, 0, False, object(), \n    # empty and whitespace-only strings\n    '', '  ',\n]\n```", "```py\n# - Test all permutations of \"bad\" argument-values:\nfor value in BadStandardOptionalTextLines:\n   try:\n      test_object._set_building_address(value)\n     # - If this setter-call succeeds, that's a \n     #   test-failure!\n      self.fail(\n         'Address._set_business_address should raise '\n         'TypeError or ValueError if passed \"%s\" (%s), '\n         'but it was allowed to be set instead.' % \n                (value, type(value).__name__)\n        )\n    except (TypeError, ValueError):\n    # - This is expected, so it passes\n         pass\n    except Exception as error:\n        self.fail(\n          'Address._set_business_address should raise '\n          'TypeError or ValueError if passed an invalid '\n          'value, but %s was raised instead: %s.' % \n                (error.__class__.__name__, error)\n        )\n```", "```py\nGoodStandardRequiredTextLines = [\n    'word', 'hyphenated-word', 'short phrase', \n    'A complete sentence.', \n    'A short paragraph. This\\'s got some punctuation, '\n    'including \"quoted text.\"',\n]\nBadStandardRequiredTextLines = [\n    # Bad string values\n    'multiple\\nlines', 'also multiple\\rlines', \n    'text\\twith\\tabs',\n    # Values that aren't strings at all\n    1, True, 0, False, object(), \n    # empty and whitespace-only strings\n    '', '  ',\n    None # Because optional items are NOT allowed to be None\n]\n\n# ... \n\ndef test_set_city(self):\n    # Tests the _set_city method of the Address class\n    # - Create an object to test with:\n    test_object = Address('street address', 'street_address')\n    # - Test all permutations of \"good\" argument-values:\n    for expected in GoodStandardRequiredTextLines:\n        test_object._set_city(expected)\n        actual = test_object._get_city()\n        self.assertEqual(\n            expected, actual, \n            'Address expects a city value set to '\n            '\"%s\" (%s) to be retrieved with a corresponding '\n            'getter-method call, but \"%s\" (%s) was returned '\n            'instead' % \n            (\n                expected, type(expected).__name__, \n                actual, type(actual).__name__, \n            )\n        )\n    # - Test all permutations of \"bad\" argument-values:\n    for value in BadStandardRequiredTextLines:\n        try:\n            test_object._set_city(value)\n            # - If this setter-call succeeds, that's a \n            #   test-failure!\n            self.fail(\n                'Address._set_business_address should raise '\n                'TypeError or ValueError if passed \"%s\" (%s), '\n                'but it was allowed to be set instead.' % \n                (value, type(value).__name__)\n            )\n        except (TypeError, ValueError):\n            # - This is expected, so it passes\n            pass\n        except Exception as error:\n            self.fail(\n                'Address._set_business_address should raise '\n                'TypeError or ValueError if passed an invalid '\n                'value, but %s was raised instead: %s.' % \n                (error.__class__.__name__, error)\n            )\n```", "```py\ndef test__init__(self):\n  # Tests the __init__ method of the Address class\n  # - Test all permutations of \"good\" argument-values:\n  for building_address in GoodStandardOptionalTextLines:\n    for city in GoodStandardRequiredTextLines:\n      for country in GoodStandardOptionalTextLines:\n        for postal_code in GoodStandardOptionalTextLines:\n          for region in GoodStandardOptionalTextLines:\n            for street_address in GoodStandardRequiredTextLines:\n              test_object = Address(\n                street_address, city, building_address,\n                region, postal_code, country\n              )\n              self.assertEqual(test_object.street_address, street_address)\n              self.assertEqual(test_object.city, city)\n              self.assertEqual(test_object.building_address, building_address)\n              self.assertEqual(test_object.region, region)\n              self.assertEqual(test_object.postal_code, postal_code)\n              self.assertEqual(test_object.country, country)\n```", "```py\ndef teststandard_address(self):\n  # Tests the standard_address method of the Address class\n  # - Test all permutations of \"good\" argument-values:\n  for street_address in GoodStandardRequiredTextLines:\n    for building_address in GoodStandardOptionalTextLines:\n      for city in GoodStandardRequiredTextLines:\n        for region in GoodStandardOptionalTextLines:\n          for postal_code in GoodStandardOptionalTextLines:\n            for country in GoodStandardOptionalTextLines:\n              test_object = Address.standard_address(\n                street_address, building_address, \n                city, region, postal_code, \n                country\n              )\n              self.assertEqual(test_object.street_address, street_address)\n              self.assertEqual(test_object.building_address, building_address)\n              self.assertEqual(test_object.city, city)\n              self.assertEqual(test_object.region, region)\n              self.assertEqual(test_object.postal_code, postal_code)\n              self.assertEqual(test_object.country, country)\n```", "```py\ndef testproducts(self):\n    # Tests the products property of the HasProducts class\n    # - Assert that the getter is correct:\n    self.assertEqual(\n        HasProducts.products.fget, \n        HasProducts._get_products, \n        'HasProducts.products is expected to use the '\n        '_get_products method as its getter-method'\n    )\n    # - Assert that the setter is correct:\n    self.assertEqual(\n        HasProducts.products.fset, None, \n        'HasProducts.products is expected to be read-only, with '\n        'no associated setter-method'\n    )\n    # - Assert that the deleter is correct:\n    self.assertEqual(\n        HasProducts.products.fdel, None, \n        'HasProducts.products is expected to be read-only, with '\n        'no associated deleter-method'\n    )\n```", "```py\nclass HasProductsDerived(HasProducts):\n    def __init__(self, *products):\n        HasProducts.__init__(self, *products)\n# NOTE: These do NOT have to actually *do* anything, they\n# merely have to *exist* in order to allow an instance \n    #       to be created:\n    def add_product(self, product):\n        pass\n    def remove_product(self, product):\n        pass\n```", "```py\n#  Since we needed this class in order to generate good #  product-\n#   setter test-values, but it wasn't defined until now, #   we'll \n#   create the GoodProducts test-values here...\nGoodProducts = [\n    [\n        BaseProductDerived('test1', 'summary1', True, True),\n        BaseProductDerived('test2', 'summary2', True, True),\n    ],\n    (\n        BaseProductDerived('test3', 'summary3', True, True),\n        BaseProductDerived('test4', 'summary4', True, True),\n    ),\n]\nBadProducts = [\n    object(), 'string', 1, 1.0, True, None,\n    ['list','with','invalid','values'],\n    [\n        BaseProductDerived('test4', 'summary4', True, True), \n        'list','with','invalid','values'\n    ],\n    ('tuple','with','invalid','values'),\n    (\n        BaseProductDerived('test4', 'summary4', True, True), \n        'tuple','with','invalid','values'\n    ),\n]\n```", "```py\ndef test_del_products(self):\n# Tests the _del_products method of the HasProducts class\n   test_object = HasProductsDerived()\n   self.assertEqual(test_object.products, (),\n   'HasProducts-derived instances are expected to return '\n   'an empty tuple as a default/deleted value'\n   )\n# - Test all permutations of \"good\" argument-values:\n        test_object._set_products(GoodProducts[0])\n        self.assertNotEqual(test_object.products, ())\n        test_object._del_products()\n        self.assertEqual(test_object.products, ())\n\ndef test_get_products(self):\n # Tests the _get_products method of the HasProducts class\n        test_object = HasProductsDerived()\n # - Test all permutations of \"good\" argument-values:\n        expected = GoodProducts[1]\n        test_object._products = expected\n        self.assertEqual(test_object._get_products(), expected)\n\n    def test_set_products(self):\n# Tests the _set_products method of the HasProducts class\n        test_object = HasProductsDerived()\n# - Test all permutations of \"good\" argument-values:\n        for expected in GoodProducts:\n            test_object._set_products(expected)\n            if type(expected) != tuple:\n                expected = tuple(expected)\n            self.assertEqual(expected, test_object._get_products())\n# - Test all permutations of each \"bad\" argument-value \n#   set against \"good\" values for the other arguments:\n        for value in BadProducts:\n            try:\n                test_object._set_products(value)\n                self.fail(\n                    'HasProducts-derived classes should not allow '\n                    '\"%s\" (%s) as a valid products value, but it '\n                    'was allowed to be set.' % \n                    (str(value), type(value).__name__)\n                )\n            except (TypeError, ValueError):\n                pass\n```", "```py\ndef test__init__(self):\n  # Tests the __init__ method of the HasProducts class\n  # - Test all permutations of \"good\" argument-values:\n        for expected in GoodProducts:\n            test_object = HasProductsDerived(*expected)\n            if type(expected) != tuple:\n                expected = tuple(expected)\n            self.assertEqual(test_object.products, expected)\n```", "```py\ndef testset_metadata(self):\n # Tests the set_metadata method of the BaseProduct class\n  test_object = BaseProductDerived('name', 'summary', True, True)\n  expected = {}\n # - Test all permutations of \"good\" argument-values:\n  for key in GoodStandardRequiredTextLines:\n      value = '%s value'\n      expected[key] = value\n      test_object.set_metadata(key, value)\n      self.assertEqual(test_object.metadata, expected)\n```", "```py\n    # - Test all permutations of each \"bad\" argument-value \n    #   set against \"good\" values for the other arguments:\n    value = GoodStandardRequiredTextLines[0]\n    for key in BadStandardRequiredTextLines:\n        try:\n            test_object.set_metadata(key, value)\n            self.fail(\n              'BaseProduct.set_metadata should not allow '\n              '\"%s\" (%s) as a key, but it raised no error' \n                % (key, type(key).__name__)\n            )\n        except (TypeError,ValueError):\n            pass\n        except Exception as error:\n           self.fail(\n              'BaseProduct.set_metadata should raise TypeError '\n              'or ValueError if passed  \"%s\" (%s) as a key, '\n              'but %s was raised instead:\\n    %s' % \n                (\n                    key, type(key).__name__,\n                    error.__class__.__name__, error\n                )\n            )\n    key = GoodStandardRequiredTextLines[0]\n    for value in BadStandardRequiredTextLines:\n        try:\n            test_object.set_metadata(key, value)\n            self.fail(\n              'BaseProduct.set_metadata should not allow '\n              '\"%s\" (%s) as a value, but it raised no error' \n                % (value, type(value).__name__)\n            )\n        except (TypeError,ValueError):\n            pass\n        except Exception as error:\n            self.fail(\n                'BaseProduct.set_metadata should raise TypeError '\n                'or ValueError if passed  \"%s\" (%s) as a value, '\n                'but %s was raised instead:\\n    %s' % \n                (\n                    value, type(value).__name__,\n                    error.__class__.__name__, error\n                )\n            )\n```", "```py\ndef testremove_metadata(self):\n    # Tests the remove_metadata method of the BaseProduct class\n    # - First we need sopme meadata to remove\n    test_object = BaseProductDerived('name', 'summary', True, True)\n    expected = {\n        'materials':'wood',\n        'material-names':'cherry,oak',\n        'finish':'gloss'\n    }\n    for key in expected:\n        test_object.set_metadata(key, expected[key])\n    self.assertEqual(test_object.metadata, expected)\n    # - Test all permutations of \"good\" argument-values:\n    keys = list(expected.keys())\n    for key in keys:\n        del expected[key]\n        test_object.remove_metadata(key)\n        self.assertEqual(test_object.metadata, expected)\n```", "```py\nGoodBooleanOrIntEquivalents = [\n    True, False, 1, 0\n]\n```", "```py\nBadBooleanOrIntEquivalents = [\n    'true', '', (1,2), tuple()\n]\n```", "```py\nGoodWeights = [\n    0, 1, 2, 0.0, 1.0, 2.0, 1.5\n]\nBadWeights = [\n    -1, -1.0, object(), 'true', '', (1,2), tuple()\n]\nGoodMetadataDicts = [\n    {},\n    {'spam':'eggs'}\n]\nBadMetadataDicts = [\n    -1, -1.0, object(), 'true', '', (1,2), tuple()\n]\n```", "```py\ndef _set_shipping_weight(self, value:(int,float)):\n    if type(value) not in (int, float):\n        raise TypeError(\n            '%s.shipping_weight expects a non-negative numeric '\n            'value, but was passed \"%s\" (%s)' % \n            (\n                self.__class__.__name__, \n                value, type(value).__name__\n            )\n        )\n    if value < 0:\n        raise ValueError(\n            '%s.shipping_weight expects a non-negative numeric '\n            'value, but was passed \"%s\" (%s)' % \n            (\n                self.__class__.__name__, \n                value, type(value).__name__\n            )\n        )\n    self._shipping_weight = value\n```", "```py\nBadDescriptions = [\n    # Values that aren't strings at all\n    1, True, 0, False, object(), \n    # empty and whitespace-only strings\n    '', '  ',\n]\n```", "```py\nclass BaseCustomerDerived(BaseCustomer):\n    pass\n\nGoodCustomers = [\n    BaseCustomerDerived('customer name', Address('street-address', 'city'))\n]\nBadCustomers = [\n    '', 'string', 1, 0, True, False, 1.0, 0.0, object(), [],\n]\n```", "```py\ndef __init__(self, \n  name:(str,), billing_address:(Address,), \n  shipping_address:(Address,None)=None\n):\n\n   # ...\n\n   # - Prevent a direct instantiation of this class - it's \n        #   intended to be abstract, even though it has no \n        #   explicitly-abstract members:\n        if self.__class__ == BaseCustomer:\n            raise NotImplementedError(\n                'BaseCustomer is intended to be an abstract class, '\n                'even though it does not have any explicitly '\n                'abstract members, and should not be instantiated.'\n            )\n```", "```py\ndef test__init__(self):\n    # Tests the __init__ method of the BaseCustomer class\n    # - Test to make sure that BaseCustomer can't be \n    #   instantiated on its own!\n    # - Test all permutations of \"good\" argument-values:\n    # - Test all permutations of each \"bad\" argument-value \n    #   set against \"good\" values for the other arguments:\n    self.fail('test__init__ is not yet implemented')\n```", "```py\ntest_object = BaseCustomer(\n    'customer name', Address('street-address', 'city')\n)\n```", "```py\ndef test__init__(self):\n# Tests the __init__ method of the BaseCustomer class\n# - BaseCustomer is an abstract class, but has no abstract \n#   members, so this was set up to keep it from being \n#   accidentally used in an inappropriate fashion\n    try:\n       test_object = BaseCustomer(\n       'customer name', Address('street-address', 'city')\n       )\n       self.fail(\n          'BaseCustomer is expected to raise '\n          'NotImplementedError if instantiated directly, '\n                'but did not do so'\n       )\n     except NotImplementedError:\n            pass\n```", "```py\n# - Test all permutations of \"good\" argument-values:\n    for name in GoodStandardRequiredTextLines:\n       for billing_address in GoodAddresses:\n          # - Testing without a shipping-address first\n            test_object = BaseCustomerDerived(\n                name, billing_address\n            )\n            self.assertEqual(test_object.name, name)\n            self.assertEqual(\n                test_object.billing_address, \n                billing_address\n             )\n            for shipping_address in GoodAddresses:\n               test_object = BaseCustomerDerived(\n                  name, billing_address, \n                   shipping_address\n             )\n             self.assertEqual(\n                test_object.shipping_address, \n                shipping_address\n             )\n```", "```py\nGoodEmails = [\n    'someone@somewhere.com',\n    'brian.allbee+hosewp@gmail.com',\n]\nBadEmails = [\n    '', 'string', -1, -1.0, object(), 'true', '', (1,2), tuple()\n]\nGoodURLs = [\n    'http://www.google.com',\n    'https://www.google.com',\n]\nBadURLs = [\n    '', 'string', -1, -1.0, object(), 'true', '', (1,2), tuple()\n]\n```", "```py\ndef __init__(self, \n    contact_name:str, contact_email:str, \n    address:Address, company_name:str=None, \n    website:(str,)=None, \n    **products\n    ):\n\n    # ...\n\n    # - Call parent initializers if needed\n    HasProducts.__init__(self, *products)\n    # - Set default instance property-values using _del_... methods\n    self._del_address()\n    self._del_company_name()\n    self._del_contact_email()\n    self._del_contact_name()\n    self._del_website()\n    # - Set instance property-values from arguments using \n    #   _set_... methods\n    self._set_contact_name(contact_name)\n    self._set_contact_email(contact_email)\n    self._set_address(address)\n    if company_name:\n        self._set_company_name(company_name)\n    if website:\n        self._set_website(website)\n```", "```py\n#!/usr/bin/env python\n\n# - Provide an import-path for the unit-testing standards we're using:\nimport sys\nsys.path.append('../standards')\n\n# - Standard setup.py import and structure\nfrom setuptools import setup\n\n# The actual setup function call:\nsetup(\n    name='HMS-Core',\n    version='0.1.dev0',\n    author='Brian D. Allbee',\n    description='',\n    package_dir={\n        '':'src',\n    },\n    packages=[\n        'hms_core',\n    ],\n    test_suite='tests.test_hms_core',\n)\n```", "```py\npython setup.py test\n```", "```py\npython setup.py sdist\n```", "```py\npip install HMS-Core-0.1.dev0.tar.gz\n```"]