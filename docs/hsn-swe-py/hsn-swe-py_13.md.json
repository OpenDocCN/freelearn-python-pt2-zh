["```py\nclass DatastoreConfig:\n    \"\"\"\nRepresents a set of credentials for connecting to a back-end \ndatabase engine that requires host, port, database, user, and \npassword values.\n\"\"\"\n```", "```py\n    def _set_port(self, value:int) -> None:\n        if type(value) != int:\n            raise TypeError(\n                '%s.port expects an int value from 0 through 65535, '\n                'inclusive, but was passed \"%s\" (%s)' % \n                (self.__class__.__name__, value, type(value).__name__)\n            )\n        if value < 0 or value > 65535:\n            raise ValueError(\n                '%s.port expects an int value from 0 through 65535, '\n                'inclusive, but was passed \"%s\" (%s)' % \n                (self.__class__.__name__, value, type(value).__name__)\n            )\n        self._port = value\n```", "```py\n    ###################################\n    # Object initialization           #\n    ###################################\n\n    def __init__(self, \n        host=None, port=None, database=None, user=None, password=None\n    ):\n        \"\"\"\nObject initialization.\n\nself .............. (DatastoreConfig instance, required) The instance \n                    to execute against\nhost .............. (str, optional, defaults to None) the host-name \n                    (FQDN, machine network-name or IP address) where \n                    the database that the instance will use to persist \n                    state-data resides\nport .............. (int [0..65535], optional, defaults to None) the \n                    TCP/IP port on the host that the database \n                    connection will use\ndatabase .......... (str, optional, defaults to None) the name of \n                    the database that the instance will use to persist \n                    state-data\nuser .............. (str, optional, defaults to None) the user-name \n                    used to connect to the database that the instance \n                    will use to persist state-data\npassword .......... (str, optional, defaults to None) the password \n                    used to connect to the database that the instance \n                    will use to persist state-data\n\"\"\"\n```", "```py\n    ###################################\n    # Class methods                   #\n    ###################################\n\n    @classmethod\n    def from_config(cls, config_file:(str,)):\n        # - Use an explicit try/except instead of with ... as ...\n        try:\n            fp = open(config_file, 'r')\n            config_data = fp.read()\n            fp.close()\n        except (IOError, PermissionError) as error:\n            raise error.__class__(\n                '%s could not read the config-file at %s due to '\n                'an error (%s): %s' % \n                (\n                    self.__class__.__name__, config_file, \n                    error.__class__.__name__, error\n                )\n            )\n        # - For now, we'll assume that config-data is in JSON, though \n        #   other formats might be better later on (YAML, for instance)\n        load_successful = False\n        try:\n            parameters = json.loads(config_data)\n            load_successful = True\n        except Exception as error:\n            pass\n        # - YAML can go here\n        # - .ini-file format here, maybe?\n        if load_successful:\n            try:\n                return cls(**parameters)\n            except Exception as error:\n                raise RuntimeError(\n                    '%s could not load configuration-data from %s '\n                    'due to an %s: %s' % \n                    (\n                        cls.__name__, config_file, \n                        error.__class__.__name__, error\n                    )\n                )\n        else:\n            raise RuntimeError(\n                '%s did not recognize the format of the config-file '\n                'at %s' % (cls.__name__, config_file)\n            )\n```", "```py\n# - The local mongod service may not require user-name and password\nlocal_mongo = DatastoreConfig(\n    host='localhost', port=27017, database='hms_local'\n)\n```", "```py\nclient = pymongo.MongoClient()    # Using default host and port\ndatabase = client['hms_sys']      # Databases can be requested by name\nobjects = database['Objects']     # The collection of Object                                           # documents/records\n```", "```py\nclass HMSMongoDataObject(BaseDataObject, metaclass=abc.ABCMeta):\n    \"\"\"\nProvides baseline functionality, interface requirements, and \ntype-identity for objects that can persist their state-data to \na MongoDB-based back-end data-store.\n\"\"\"\n```", "```py\n    ###################################\n    # Class attributes/constants      #\n    ###################################\n\n    # - Keeps track of the global configuration for data-access\n    _configuration = None\n```", "```py\n    # - Keeps track of the keys allowed for object-creation from \n    #   retrieved data\n    _data_dict_keys = None\n```", "```py\n    # - Allows the default mongo-collection name (the __name__ \n    #   of the class) to be overridden. This should not be changed \n    #   lightly, since data saved to the old collection-name will \n    #   no longer be available!\n    _mongo_collection = None\n```", "```py\n    ###################################\n    # Property-getter methods         #\n    ###################################\n\n    def _get_collection(self) -> pymongo.collection.Collection:\n        try:\n            return self.__class__._collection\n        except AttributeError:\n            # - If the class specifies a collection-name, then use that \n            #   as the collection...\n            if self.__class__._mongo_collection:\n                self.__class__._collection = self.database[\n                    self.__class__._mongo_collection\n                ]\n            # - Otherwise, use the class-name\n            else:\n                self.__class__._collection = self.database[\n                    self.__class__.__name__\n                ]\n            return self.__class__._collection\n\n    def _get_configuration(self) -> DatastoreConfig:\n        return HMSMongoDataObject._configuration\n\n    def _get_connection(self) -> pymongo.MongoClient:\n        try:\n            return self.__class__._connection\n        except AttributeError:\n            # - Build the connection-parameters we need:\n            conn_config = []\n            # - host\n            if self.configuration.host:\n                conn_config.append(self.configuration.host)\n                # - port. Ports don't make any sense without a \n                #   host, though, so host has to be defined first...\n                if self.configuration.port:\n                    conn_config.append(self.configuration.port)\n            # - Create the connection\n            self.__class__._connection = pymongo.MongoClient(*conn_config)\n            return self.__class__._connection\n\n    def _get_database(self) -> pymongo.database.Database:\n        try:\n            return self.__class__._database\n        except AttributeError:\n            self.__class__._database = self.connection[\n                self.configuration.database\n            ]\n            return self.__class__._database\n```", "```py\n    ###################################\n    # Property-deleter methods        #\n    ###################################\n\n    def _del_collection(self) -> None:\n        # - If the collection is deleted, then the database needs \n        #   to be as well:\n        self._del_database()\n        try:\n            del self.__class__._collection\n        except AttributeError:\n            # - It may already not exist\n            pass\n\n    def _del_connection(self) -> None:\n        # - If the connection is deleted, then the collection and \n        #   database need to be as well:\n        self._del_collection()\n        self._del_database()\n        try:\n            del self.__class__._connection\n        except AttributeError:\n            # - It may already not exist\n            pass\n\n    def _del_database(self) -> None:\n        try:\n            del self.__class__._database\n        except AttributeError:\n            # - It may already not exist\n            pass\n```", "```py\n    ###################################\n    # Instance property definitions   #\n    ###################################\n\n    collection = property(\n        _get_collection, None, _del_collection, \n        'Gets or deletes the MongoDB collection that instance '\n        'state-data is stored in'\n    )\n    connection = property(\n        _get_connection, None, _del_connection, \n        'Gets or deletes the database-connection that the instance '\n        'will use to manage its persistent state-data'\n    )\n    database = property(\n        _get_database, None, _del_database, \n        'Gets or deletes the MongoDB database that instance '\n        'state-data is stored in'\n    )\n    configuration = property(\n        _get_configuration, None, None, \n        'Gets, sets or deletes the configuration-data '\n        '(DatastoreConfig) of the instance, from HMSMongoDataObject'\n    )\n```", "```py\n    ###################################\n    # Object initialization           #\n    ###################################\n\n    def __init__(self, \n        oid:(UUID,str,None)=None, \n        created:(datetime,str,float,int,None)=None, \n        modified:(datetime,str,float,int,None)=None,\n        is_active:(bool,int,None)=None, \n        is_deleted:(bool,int,None)=None,\n        is_dirty:(bool,int,None)=None, \n        is_new:(bool,int,None)=None,\n    ):\n        \"\"\"\nObject initialization.\n\nself .............. (HMSMongoDataObject instance, required) The \n                    instance to execute against\n\"\"\"\n        # - Call parent initializers if needed\n        BaseDataObject.__init__(self, \n            oid, created, modified, is_active, is_deleted, \n            is_dirty, is_new\n        )\n        # - Perform any other initialization needed\n```", "```py\n    ###################################\n    # Instance methods                #\n    ###################################\n\n    def _create(self) -> None:\n        \"\"\"\nCreates a new state-data record for the instance in the back-end \ndata-store\n\"\"\"\n        raise NotImplementedError(\n            '%s._create is not implemented, because the save '\n            'method handles all the data-writing needed for '\n            'the class. Use save() instead.' % \n            self.__class__.__name__\n        )\n\n    def _update(self) -> None:\n        \"\"\"\nUpdates an existing state-data record for the instance in the \nback-end data-store\n\"\"\"\n        raise NotImplementedError(\n            '%s._update is not implemented, because the save '\n            'method handles all the data-writing needed for '\n            'the class. Use save() instead.' % \n            self.__class__.__name__\n        )\n```", "```py\n    def save(self):\n        if self._is_new or self._is_dirty:\n            # - Make sure to update the modified time-stamp!\n            self.modified = datetime.now()\n            data_dict = self.to_data_dict()\n            data_dict['_id'] = self.oid\n            self.collection.insert_one(data_dict)\n            self._set_is_dirty(False)\n            self._set_is_new(False)\n```", "```py\n    @classmethod\n    def from_data_dict(cls, data_dict):\n        # - Assure that we have the collection of keys that are \n        #   allowed for the class!\n        if cls._data_dict_keys == None:\n            raise AttributeError(\n                '%s.from_data_dict cannot be used because the %s '\n                'class has not specified what data-store keys are '\n                'allowed to be used to create new instances from '\n                'retrieved data. Set %s._data_dict_keys to a list '\n                'or tuple of argument-names present in %s.__init__' % \n                (cls.__name__, cls.__name__, cls.__name__, cls.__name__)\n            )\n        # - Remove any keys that aren't listed in the class' \n        #   initialization arguments:\n        data_dict = dict(\n            [\n                (key, data_dict[key]) for key in data_dict.keys() \n                if key in cls._data_dict_keys\n            ]\n        )\n        # - Then create and return an instance of the class\n        return cls(**data_dict)\n```", "```py\n    ###################################\n    # Class methods                   #\n    ###################################\n\n    @classmethod\n    def configure(cls, configuration:(DatastoreConfig)):\n        \"\"\"\nSets configuration values across all classes derived from \nHMSMongoDataObject.\n\"\"\"\n        if cls != HMSMongoDataObject:\n            raise RuntimeError(\n                '%s.configure will alter *all* MongoDB configuration, '\n                'not just the configuration for %s. Please use '\n                'HMSMongoDataObject.configure instead.' % \n                (cls.__name__, cls.__name__)\n            )\n        if not isinstance(configuration, DatastoreConfig):\n            raise TypeError(\n                '%s.configure expects an instance of '\n                'DatastoreConfig, but was passed \"%s\" (%s)' % \n                (\n                    cls.__name__, configuration, \n                    type(configuration).__name__\n                )\n            )\n        HMSMongoDataObject._configuration = configuration\n```", "```py\n    @classmethod\n    def get_mongo_collection(cls) -> pymongo.collection.Collection:\n        \"\"\"\nHelper class-method that retrieves the relevant MongoDB collection for \ndata-access to state-data records for the class.\n\"\"\"\n        # - If the collection has already been created, then \n        #   return it, otherwise create it then return it\n        try:\n            return cls._collection\n        except AttributeError:\n            pass\n        if not cls._configuration:\n            raise RuntimeError(\n                '%s must be configured before the '\n                'use of %s.get will work. Call HMSMongoDataObject.'\n                'configure with a DatastoreConfig object to resolve '\n                'this issue' % (cls.__name__, cls.__name__)\n            )\n        # - With configuration established, we can create the \n        #   connection, database and collection objects we need \n        #   in order to execute the request:\n        # - Build the connection-parameters we need:\n        conn_config = []\n        # - host\n        if cls._configuration.host:\n            conn_config.append(cls.configuration.host)\n            # - port. Ports don't make any sense without a \n            #   host, though, so host has to be defined first...\n            if cls._configuration.port:\n                conn_config.append(cls.configuration.port)\n        # - Create the connection\n        cls._connection = pymongo.MongoClient(*conn_config)\n        # - Create the database\n        cls._database = cls._connection[cls._configuration.database]\n        # - and the collection\n        if cls._mongo_collection:\n            cls._collection = cls._database[cls._mongo_collection]\n        # - Otherwise, use the class-name\n        else:\n            cls._collection = cls._database[cls.__name__]\n        return cls._collection\n```", "```py\n    @classmethod\n    def delete(cls, *oids):\n        \"\"\"\nPerforms an ACTUAL record deletion from the back-end data-store \nof all records whose unique identifiers have been provided\n\"\"\"\n        # - First, we need the collection that we're working with:\n        collection = cls.get_mongo_collection()\n        if oids:\n            for oid in oids:\n                collection.remove({'oid':str(oid)})\n\n    @classmethod\n    def from_data_dict(cls, data_dict):\n        # - Assure that we have the collection of keys that are \n        #   allowed for the class!\n        if cls._data_dict_keys == None:\n            from inspect import getfullargspec\n            argspec = getfullargspec(cls.__init__)\n            init_args = argspec.args\n            try:\n                init_args.remove('self')\n            except:\n                pass\n            try:\n                init_args.remove('cls')\n            except:\n                pass\n            print(argspec)\n            if argspec.varargs:\n                init_args.append(argspec.varargs)\n            if argspec.varkw:\n                init_args.append(argspec.varkw)\n            raise AttributeError(\n                '%s.from_data_dict cannot be used because the %s '\n                'class has not specified what data-store keys are '\n                'allowed to be used to create new instances from '\n                'retrieved data. Set %s._data_dict_keys to a list '\n                'or tuple of argument-names present in %s.__init__ '\n                '(%s)' % \n                (\n                    cls.__name__, cls.__name__, cls.__name__, \n                    cls.__name__, \"'\" + \"', '\".join(init_args) + \"'\"\n                )\n            )\n        # - Remove any keys that aren't listed in the class' \n        #   initialization arguments:\n        data_dict = dict(\n            [\n                (key, data_dict[key]) for key in data_dict.keys() \n                if key in cls._data_dict_keys\n            ]\n        )\n        # - Then create and return an instance of the class\n        return cls(**data_dict)\n```", "```py\n    @classmethod\n    def get(cls, *oids, **criteria) -> list:\n        # - First, we need the collection that we're working with:\n        collection = cls.get_mongo_collection()\n        # - The first pass of the process retrieves documents based \n        #   on oids or criteria.\n```", "```py\n        # - We also need to keep track of whether or not to do a \n        #   matches call on the results after the initial data-\n        #   retrieval:\n        post_filter = False\n        if oids:\n            # - oid-based requests should usually be a fairly short \n            #   list, so finding individual items and appending them \n            #   should be OK, performance-wise.\n            data_dicts = [\n                collection.find_one({'oid':oid})\n                for oid in oids\n            ]\n```", "```py\n            # - If this becomes an issue later, consider changing \n            #   it to a variant of \n            #   collection.find({'oid':{'$in':oids}})\n            #   (the oids argument-list may need pre-processing first)\n```", "```py\n            if criteria:\n                post_filter = True\n```", "```py\n        elif criteria:\n            # - criteria-based items can do a find based on all criteria \n            #   straight away\n            data_dicts = [\n                item for item in collection.find(criteria)\n            ]\n```", "```py\n        else:\n            # - If there are no oids specified, and no criteria, \n            #   the implication is that we want *all* object-records \n            #   to be returned...\n            data_dicts = [\n                item for item in collection.find()\n            ]\n```", "```py\n# - At this point, we have data_dict values that should be \n        #   able to create instances, so create them.\n        results = [\n            cls.from_data_dict(data_dict) \n            for data_dict in data_dicts\n            if data_dict # <-- This could be None: check it!\n        ]\n```", "```py\n        # - If post_filter has been set to True, then the request \n        #   was for items by oid *and* that have certain criteria\n        if post_filter:\n            results = [\n                obj for obj in results if obj.matches(**criteria)\n            ]\n        return results\n```", "```py\nclass HMSSQLDataObject(BaseDataObject, metaclass=abc.ABCMeta):\n    \"\"\"\nProvides baseline functionality, interface requirements, and \ntype-identity for objects that can persist their state-data to \na (GENERIC) SQL-based RDBMS back-end data-store.\n\"\"\"\n```", "```py\n    ###################################\n    # Class attributes/constants      #\n    ###################################\n\n    # - Keeps track of the global configuration for data-access\n    _configuration = None\n    # - Keeps track of the keys allowed for object-creation from \n    #   retrieved data\n    _data_dict_keys = None\n    # - SQL for various expected CRUD actions:\n    _sql_create = \"\"\"Some SQL string goes here\"\"\"\n    _sql_read_oids = \"\"\"Some SQL string goes here\"\"\"\n    _sql_read_all = \"\"\"Some SQL string goes here\"\"\"\n    _sql_read_criteria = \"\"\"Some SQL string goes here\"\"\"\n    _sql_update = \"\"\"Some SQL string goes here\"\"\"\n    _sql_delete = \"\"\"Some SQL string goes here\"\"\"\n```", "```py\n    ###################################\n    # Property-getter methods         #\n    ###################################\n\n    def _get_connection(self):\n        try:\n            return self.__class__._connection\n        except AttributeError:\n            # - Most RDBMS libraries provide a \"connect\" function, or \n            #   allow the creation of a \"connection\" object, using the \n            #   parameters we've named in DatastoreConfig, or simple \n            #   variations of them, so all we need to do is connect:\n            self.__class__._connection = RDBMS.connect(\n                **self.configuration\n            )\n            return self.__class__._connection\n```", "```py\n    ###################################\n    # Property-deleter methods        #\n    ###################################\n\n    def _del_connection(self) -> None:\n        try:\n            del self.__class__._connection\n        except AttributeError:\n            # - It may already not exist\n            pass\n```", "```py\n    ###################################\n    # Instance property definitions   #\n    ###################################\n\n    connection = property(\n        _get_connection, None, _del_connection, \n        'Gets or deletes the database-connection that the instance '\n        'will use to manage its persistent state-data'\n    )\n```", "```py\n    ###################################\n    # Object initialization           #\n    ###################################\n\n    def __init__(self, \n        oid:(UUID,str,None)=None, \n        created:(datetime,str,float,int,None)=None, \n        modified:(datetime,str,float,int,None)=None,\n        is_active:(bool,int,None)=None, \n        is_deleted:(bool,int,None)=None,\n        is_dirty:(bool,int,None)=None, \n        is_new:(bool,int,None)=None,\n    ):\n        \"\"\"\nObject initialization.\n\nself .............. (HMSMongoDataObject instance, required) The \n                    instance to execute against\noid ............... (UUID|str, optional, defaults to None) The unique \n                    identifier of the object's state-data record in the \n                    back-end data-store\ncreated ........... (datetime|str|float|int, optional, defaults to None) \n                    The date/time that the object was created\nmodified .......... (datetime|str|float|int, optional, defaults to None) \n                    The date/time that the object was last modified\nis_active ......... (bool|int, optional, defaults to None) A flag \n                    indicating that the object is active\nis_deleted ........ (bool|int, optional, defaults to None) A flag \n                    indicating that the object should be considered \n                    deleted (and may be in the near future)\nis_dirty .......... (bool|int, optional, defaults to None) A flag \n                    indicating that the object's data needs to be \n                    updated in the back-end data-store\nis_new ............ (bool|int, optional, defaults to None) A flag \n                    indicating that the object's data needs to be \n                    created in the back-end data-store\n\"\"\"\n        # - Call parent initializers if needed\n        BaseDataObject.__init__(self, \n            oid, created, modified, is_active, is_deleted, \n            is_dirty, is_new\n        )\n        # - Perform any other initialization needed\n```", "```py\n    ###################################\n    # Instance methods                #\n    ###################################\n\n    def _create(self):\n        # - The base SQL is in self.__class__._sql_create, and the \n        #   field-values would be retrieved from self.to_data_dict():\n        data_dict = self.to_data_dict()\n        SQL = self.__class__._sql_create\n        # - Some process would have to add the values, if not the keys, \n        #   into the SQL, and the result sanitized, but once that was \n        #   done, it'd become a simple query-execution:\n        self.connection.execute(SQL)\n\n    def _update(self):\n        # - The base SQL is in self.__class__._sql_update, and the \n        #   field-values would be retrieved from self.to_data_dict():\n        data_dict = self.to_data_dict()\n        SQL = self.__class__._sql_update\n        # - Some process would have to add the values, if not the keys, \n        #   into the SQL, and the result sanitized, but once that was \n        #   done, it'd become a simple query-execution:\n        self.connection.execute(SQL)\n```", "```py\n    ###################################\n    # Class methods                   #\n    ###################################\n\n    @classmethod\n    def delete(cls, *oids):\n        # - First, we need the database-connection that we're \n        #   working with:\n        connection = cls.get_connection()\n        SQL = cls._sql_delete % oids\n        # - Don't forget to sanitize it before executing it!\n        result_set = connection.execute(SQL)\n```", "```py\n    @classmethod\n    def get(cls, *oids, **criteria) -> list:\n        # - First, we need the database-connection that we're \n        #   working with:\n        connection = cls.get_connection()\n        # - The first pass of the process retrieves documents based \n        #   on oids or criteria.\n        # - We also need to keep track of whether or not to do a \n        #   matches call on the results after the initial data-\n        #   retrieval:\n        post_filter = False\n```", "```py\n        # - Records are often returned as a tuple (result_set) \n        #   of tuples (rows) of tuples (field-name, field-value):\n        #   ( ..., ( ('field-name', 'value' ), (...), ... ), \u2026)\n```", "```py\n        if oids:\n            # - Need to replace any placeholder values in the raw SQL\n            #   with actual values, AND sanitize the SQL string, but \n            #   it starts with the SQL in cls._sql_read_oids\n            SQL = cls._sql_read_oids\n            result_set = connection.execute(SQL)\n            if criteria:\n                post_filter = True\n```", "```py\n        elif criteria:\n            # - The same sort of replacement would need to happen here \n            #   as happens for oids, above. If the query uses just \n            #   one criteria key/value pair initially, we can use the \n            #   match-based filtering later to filter further as needed\n            key = criteria.keys()[0]\n            value = criteria[key]\n            SQL = cls._sql_read_criteria % (key, value)\n            result_set = connection.execute(SQL)\n            if len(criteria) > 1:\n                post_filter = True\n```", "```py\n        else:\n            SQL = cls._sql_read_all\n            result_set = connection.execute(SQL)\n```", "```py\n# This is the outermost tuple, collecting all of the \n# rows returned into a result_set:\n(\n    # Each tuple at this level is a single row:\n    (\n        # Each tuple at this level is a key/value pair:\n        ('oid', '43d240cd-4c9f-44c2-a196-1c7c56068cef'),\n        ('first_name', 'John'),\n        ('last_name', 'Smith'),\n        ('email', 'john@smith.com'),\n        # ...\n    ),\n    # more rows could happen here, or not...\n)\n```", "```py\n        # - We should have a result_set value here, so we can convert \n        #   it from the tuple of tuples of tuples (or whatever) into \n        #   data_dict-compatible dictionaries:\n        data_dicts = [\n            dict(\n                [field_tuple for field_tuple in row]\n            )\n            for row in result_set\n        ]\n```", "```py\n        # - With those, we can create the initial list of instances:\n        results = [\n            cls.from_data_dict(data_dict) \n            for data_dict in data_dicts\n        ]\n        # - If post_filter has been set to True, then the request \n        #   was for items by oid *and* that have certain criteria\n        if post_filter:\n            results = [\n                obj for obj in results if obj.matches(**criteria)\n            ]\n```", "```py\n        # - Data-objects that have related child items, like the \n        #   Artisan to Product relationship, may need to acquire \n        #   those children here before returning the results. If \n        #   they do, then a structure like this should work most \n        #   of the time:\n        for artisan in results:\n            artisan._set_products(\n                Product.get(artisan_oid=artisan.oid)\n            )\n        return results\n```", "```py\nclass Artisan(BaseArtisan, HMSMongoDataObject):\n    \"\"\"\nRepresents an Artisan in the context of the Central Office \napplications and services\n\"\"\"\n```", "```py\n    ###################################\n    # Class attributes/constants      #\n    ###################################\n\n    _data_dict_keys = (\n        'contact_name', 'contact_email', 'address', 'company_name', \n        'website', 'oid', 'created', 'modified', 'is_active', \n        'is_deleted', 'products'\n    )\n```", "```py\n    ###################################\n    # Object initialization           #\n    ###################################\n\n    # TODO: Add and document arguments if/as needed\n    def __init__(self,\n        contact_name:str, contact_email:str, \n        address:Address, company_name:str=None, \n        website:(str,)=None, \n        # - Arguments from HMSMongoDataObject\n        oid:(UUID,str,None)=None, \n        created:(datetime,str,float,int,None)=None, \n        modified:(datetime,str,float,int,None)=None,\n        is_active:(bool,int,None)=None, \n        is_deleted:(bool,int,None)=None,\n        is_dirty:(bool,int,None)=None, \n        is_new:(bool,int,None)=None,\n        *products\n    ):\n        \"\"\"\nObject initialization.\n\nself .............. (Artisan instance, required) The instance to \n                    execute against\ncontact_name ...... (str, required) The name of the primary contact \n                    for the Artisan that the instance represents\ncontact_email ..... (str [email address], required) The email address \n                    of the primary contact for the Artisan that the \n                    instance represents\naddress ........... (Address, required) The mailing/shipping address \n                    for the Artisan that the instance represents\ncompany_name ...... (str, optional, defaults to None) The company-\n                    name for the Artisan that the instance represents\noid ............... (UUID|str, optional, defaults to None) The unique \n                    identifier of the object's state-data record in the \n                    back-end data-store\ncreated ........... (datetime|str|float|int, optional, defaults to None) \n                    The date/time that the object was created\nmodified .......... (datetime|str|float|int, optional, defaults to None) \n                    The date/time that the object was last modified\nis_active ......... (bool|int, optional, defaults to None) A flag \n                    indicating that the object is active\nis_deleted ........ (bool|int, optional, defaults to None) A flag \n                    indicating that the object should be considered \n                    deleted (and may be in the near future)\nis_dirty .......... (bool|int, optional, defaults to None) A flag \n                    indicating that the object's data needs to be \n                    updated in the back-end data-store\nis_new ............ (bool|int, optional, defaults to None) A flag \n                    indicating that the object's data needs to be \n                    created in the back-end data-store\nproducts .......... (BaseProduct collection) The products associated \n                    with the Artisan that the instance represents\n\"\"\"\n        # - Call parent initializers if needed\n        BaseArtisan.__init__(self, \n            contact_name, contact_email, address, company_name\n        )\n        HMSMongoDataObject.__init__(self, \n            oid, created, modified, is_active, is_deleted, \n            is_dirty, is_new\n        )\n        if products:\n            BaseArtisan._set_products(*products)\n        # - Perform any other initialization needed\n```", "```py\n    ###################################\n    # Instance methods                #\n    ###################################\n\n    def add_product(self, product:BaseProduct) -> BaseProduct:\n        return Hasproducts.add_product(self, product)\n\n    def matches(self, **criteria) -> (bool,):\n        return HMSMongoDataObject.matches(self, **criteria)\n\n    def remove_product(self, product:BaseProduct) -> None:\n        return Hasproducts.remove_product(self, product)\n```", "```py\n    def to_data_dict(self):\n        return {\n            # - BaseArtisan-derived items\n            'address':self.address.to_dict() if self.address else None,\n            'company_name':self.company_name,\n            'contact_email':self.contact_email,\n            'contact_name':self.contact_name,\n            'website':self.website, \n            # - BaseDataObject-derived items\n            'created':datetime.strftime(\n                self.created, self.__class__._data_time_string\n            ),\n            'is_active':self.is_active,\n            'is_deleted':self.is_deleted,\n            'modified':datetime.strftime(\n                self.modified, self.__class__._data_time_string\n            ),\n            'oid':str(self.oid),\n        }\n```", "```py\n    ###################################\n    # Class methods                   #\n    ###################################\n\n    @classmethod\n    def from_data_dict(cls, data_dict):\n        # - This has to be overridden because we have to pre-process \n        #   incoming address and (maybe, eventually?) product-list \n        #   values...\n        if data_dict.get('address'):\n            data_dict['address'] = Address.from_dict(data_dict['address'])\n        ####### NOTE: Changes made here, for whatever reason might \n        #       arise, may also need to be made in \n        #       HMSMongoDataObject.from_data_dict \u2013 it's the same \n        ####### process!\n        # - Assure that we have the collection of keys that are \n        #   allowed for the class!\n        if cls._data_dict_keys == None:\n            from inspect import getfullargspec\n            argspec = getfullargspec(cls.__init__)\n            init_args = argspec.args\n            try:\n                init_args.remove('self')\n            except:\n                pass\n            try:\n                init_args.remove('cls')\n            except:\n                pass\n            print(argspec)\n            if argspec.varargs:\n                init_args.append(argspec.varargs)\n            if argspec.varkw:\n                init_args.append(argspec.varkw)\n            # FullArgSpec(varargs='products', varkw=None\n            raise AttributeError(\n                '%s.from_data_dict cannot be used because the %s '\n                'class has not specified what data-store keys are '\n                'allowed to be used to create new instances from '\n                'retrieved data. Set %s._data_dict_keys to a list '\n                'or tuple of argument-names present in %s.__init__ '\n                '(%s)' % \n                (\n                    cls.__name__, cls.__name__, cls.__name__, \n                    cls.__name__, \"'\" + \"', '\".join(init_args) + \"'\"\n                )\n            )\n        # - Remove any keys that aren't listed in the class' \n        #   initialization arguments:\n        data_dict = dict(\n            [\n                (key, data_dict[key]) for key in data_dict.keys() \n                if key in cls._data_dict_keys\n            ]\n        )\n```", "```py\n        # - Then create and return an instance of the class\n        return cls(**data_dict)\n```", "```py\nclass Product(BaseProduct, HMSMongoDataObject):\n    \"\"\"\nRepresents a Product in the context of the Central Office \napplications and services\n\"\"\"\n    ###################################\n    # Class attributes/constants      #\n    ###################################\n\n    _data_dict_keys = [\n        'name', 'summary', 'available', 'store_available', \n        'description', 'dimensions', 'metadata', 'shipping_weight', \n        'oid', 'created', 'modified', 'is_active', 'is_deleted'\n    ]\n```", "```py\n    ###################################\n    # Object initialization           #\n    ###################################\n\n    def __init__(self,\n        # - Arguments from HMSMongoDataObject\n        name:(str,), summary:(str,), available:(bool,), \n        store_available:(bool,), \n        # - Optional arguments:\n        description:(str,None)=None, dimensions:(str,None)=None,\n        metadata:(dict,)={}, shipping_weight:(int,)=0, \n        # - Arguments from HMSMongoDataObject\n        oid:(UUID,str,None)=None, \n        created:(datetime,str,float,int,None)=None, \n        modified:(datetime,str,float,int,None)=None,\n        is_active:(bool,int,None)=None, \n        is_deleted:(bool,int,None)=None,\n        is_dirty:(bool,int,None)=None, \n        is_new:(bool,int,None)=None,\n    ):\n        \"\"\"\nObject initialization.\n\nself .............. (Product instance, required) The instance to \n                    execute against\nname .............. (str, required) The name of the product\nsummary ........... (str, required) A one-line summary of the \n                    product\navailable ......... (bool, required) Flag indicating whether the \n                    product is considered available by the artisan \n                    who makes it\nstore_available ... (bool, required) Flag indicating whether the \n                    product is considered available on the web-\n                    store by the Central Office\ndescription ....... (str, optional, defaults to None) A detailed \n                    description of the product\ndimensions ........ (str, optional, defaults to None) A measurement-\n                    description of the product\nmetadata .......... (dict, optional, defaults to {}) A collection \n                    of metadata keys and values describing the \n                    product\nshipping_weight ... (int, optional, defaults to 0) The shipping-\n                    weight of the product\noid ............... (UUID|str, optional, defaults to None) The unique \n                    identifier of the object's state-data record in the \n                    back-end data-store\ncreated ........... (datetime|str|float|int, optional, defaults to None) \n                    The date/time that the object was created\nmodified .......... (datetime|str|float|int, optional, defaults to None) \n                    The date/time that the object was last modified\nis_active ......... (bool|int, optional, defaults to None) A flag \n                    indicating that the object is active\nis_deleted ........ (bool|int, optional, defaults to None) A flag \n                    indicating that the object should be considered \n                    deleted (and may be in the near future)\nis_dirty .......... (bool|int, optional, defaults to None) A flag \n                    indicating that the object's data needs to be \n                    updated in the back-end data-store\nis_new ............ (bool|int, optional, defaults to None) A flag \n                    indicating that the object's data needs to be \n                    created in the back-end data-store\n\"\"\"\n        # - Call parent initializers if needed\n        BaseProduct.__init__(\n            self, name, summary, available, store_available, \n            description, dimensions, metadata, shipping_weight\n        )\n        HMSMongoDataObject.__init__(self, \n            oid, created, modified, is_active, is_deleted, \n            is_dirty, is_new\n        )\n        # - Perform any other initialization needed\n```", "```py\n    ###################################\n    # Instance methods                #\n    ###################################\n\n    def matches(self, **criteria) -> (bool,):\n        return HMSMongoDataObject.matches(self, **criteria)\n\n    def to_data_dict(self):\n        return {\n            # - BaseProduct-derived items\n            'available':self.available,\n            'description':self.description,\n            'dimensions':self.dimensions,\n            'metadata':self.metadata,\n            'name':self.name,\n            'shipping_weight':self.shipping_weight,\n            'store_available':self.store_available,\n            'summary':self.summary,\n            # - BaseDataObject-derived items\n            'created':datetime.strftime(\n                self.created, self.__class__._data_time_string\n            ),\n            'is_active':self.is_active,\n            'is_deleted':self.is_deleted,\n            'modified':datetime.strftime(\n                self.modified, self.__class__._data_time_string\n            ),\n            'oid':str(self.oid),\n        }\n```", "```py\n# - An example product - A copper-and-emerald necklace:\nproduct = Product(\n    'Necklace #1', \n    'Showing some Product.get aspects', True, True,\n    metadata={\n        'metal':'Copper',\n        'gemstone':'Emerald',\n    }\n)\nproduct.save()\n# - Silver-and-emerald necklace:\nproduct = Product(\n    'Necklace #2', \n    'Showing some Product.get aspects', True, True,\n    metadata={\n        'metal':'Silver',\n        'gemstone':'Emerald',\n    }\n)\nproduct.save()\n# - Copper-and-sapphire necklace:\nproduct = Product(\n    'Necklace #3', \n    'Showing some Product.get aspects', True, True,\n    metadata={\n        'metal':'Copper',\n        'gemstone':'Sapphire',\n    }\n)\nproduct.save()\n# - Silver-and-sapphire necklace:\nproduct = Product(\n    'Necklace #4', \n    'Showing some Product.get aspects', True, True,\n    metadata={\n        'metal':'Silver',\n        'gemstone':'Sapphire',\n    }\n)\nproduct.save()\n```", "```py\n# - importing json so we can usefully print the results:\nimport json\ncriteria = {\n    'metadata':{\n        'metal':'Silver',\n        'gemstone':'Sapphire',\n        }\n}\n```", "```py\nproducts = Product.get(**criteria)\nprint(json.dumps(\n    [product.to_data_dict() for product in products], \n    indent=4, sort_keys=True)\n)\n```", "```py\ncriteria = {\n    'metadata.metal':'Silver',\n    'metadata.gemstone':'Sapphire',\n}\n```", "```py\ndef save(self):\n    if self._is_new or self._is_dirty:\n        # - Make sure to update the modified time-stamp!\n        self.modified = datetime.now()\n        data_dict = self.to_data_dict()\n        data_dict['_id'] = self.oid\n        self.collection.insert_one(data_dict)\n        self._set_is_dirty(False)\n        self._set_is_new(False)\n```", "```py\ndef _set_name(self, value):\n    BaseProduct._set_name(self, value)\n    self._set_is_dirty(True)\n\n# ...\n\ndef _del_name(self):\n    BaseProduct._del_name(self)\n    self._set_is_dirty(True)\n\n# ...\n\nname = property(\n    # - Using the \"original\" getter-method and the \"local\" setter- \n    #   and deleter methods\n    BaseProduct._get_name, _set_name, _del_name, \n    'Gets, sets or deletes the name of the Product'\n)\n```", "```py\ndef save(self):\n    # TODO: For the time being, we're going to assume that save \n    #       operations don't need to care about whether the \n    #       object's data is new or dirty, that we wouldn't be \n    #       calling save unless we already knew that to be the \n    #       case. If that changes, we'll want to check is_dirty \n    #       and is_new, as shown below, *and* make sure that \n    #       they get modified accordingly.\n#    if self._is_new or self._is_dirty:\n    # - Make sure to update the modified time-stamp!\n    self.modified = datetime.now()\n    data_dict = self.to_data_dict()\n    data_dict['_id'] = self.oid\n    self.collection.insert_one(data_dict)\n    self._set_is_dirty(False)\n    self._set_is_new(False) \n```"]