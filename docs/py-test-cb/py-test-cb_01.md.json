["```py\nclass RomanNumeralConverter(object):\n    def __init__ (self, roman_numeral): \n        self.roman_numeral = roman_numeral \n        self.digit_map = {\"M\":1000, \"D\":500,\"C\":100,\\\n                         \"L\":50, \"X\":10, \"V\":5, \"I\":1} \n     def convert_to_decimal(self): \n        val = 0 \n        for char in self.roman_numeral: \n            val += self.digit_map[char] \n        return val \n```", "```py\nimport unittest \nclass RomanNumeralConverterTest(unittest.TestCase): \n```", "```py\n     def test_parsing_millenia(self):\n        value =RomanNumeralConverter(\"M\") \n        self.assertEqual(1000, value.convert_to_decimal()) \n     def test_parsing_century(self): \n        value =RomanNumeralConverter(\"C\") \n        self.assertEqual(100, value.convert_to_decimal()) \n     def test_parsing_half_century(self): \n        value =RomanNumeralConverter(\"L\") \n        self.assertEqual(50, value.convert_to_decimal()) \n     def test_parsing_decade(self): \n        value =RomanNumeralConverter(\"X\") \n        self.assertEqual(10, value.convert_to_decimal()) \n     def test_parsing_half_decade(self): \n        value =RomanNumeralConverter(\"V\") \n        self.assertEqual(5, value.convert_to_decimal()) \n     def test_parsing_one(self): \n        value = RomanNumeralConverter(\"I\") \n        self.assertEqual(1, value.convert_to_decimal()) \n     def test_empty_roman_numeral(self): \n        value =RomanNumeralConverter(\"\") \n        self.assertTrue(value.convert_to_decimal() == 0) \n        self.assertFalse(value.convert_to_decimal() > 0) \n     def test_no_roman_numeral(self): \n        value =RomanNumeralConverter(None) \n        self.assertRaises(TypeError, value.convert_to_decimal) \n```", "```py\nif __name__==\"__main__\": \n    unittest.main()\n```", "```py\nimport unittest \nclass BadTest(unittest.TestCase): \n  def test_no_roman_number(self): \n    value = RomanNumeralConverter(None) \n    try: \n      value.convert_to_decimal() \n      self.fail(\"Expected a TypeError\") \n    except TypeError: \n      pass \n    if  __name__==\"__main__\": \n      unittest.main()\n```", "```py\nclass RomanNumeralConverter(object): \n    def __init__(self): \n        self.digit_map = {\"M\":1000, \"D\":500, \"C\":100,\\\n                         \"L\":50, \"X\":10, \"V\":5, \"I\":1} \n    def convert_to_decimal(self, roman_numeral):\n        val = 0 \n        for char in roman_numeral: \n            val += self.digit_map[char] \n        return val \n```", "```py\nimport unittest \nclass RomanNumeralConverterTest(unittest.TestCase): \n```", "```py\n    def setUp(self): \n        print (\"Creating a new RomanNumeralConverter...\") \n        self.cvt =RomanNumeralConverter()\n```", "```py\n     def tearDown(self): \n        print (\"Destroying the RomanNumeralConverter...\") \n        self.cvt = None \n```", "```py\n     def test_parsing_millenia(self):\n        self.assertEqual(1000,\\\n                         self.cvt.convert_to_decimal(\"M\")) \n     def test_parsing_century(self): \n        self.assertEqual(100, \\\n                          self.cvt.convert_to_decimal(\"C\")) \n     def test_parsing_half_century(self): \n        self.assertEqual(50,\\\n                         self.cvt.convert_to_decimal(\"L\")) \n     def test_parsing_decade(self): \n        self.assertEqual(10,self.cvt.convert_to_decimal(\"X\")) \n     def test_parsing_half_decade(self): \n        self.assertEqual(5,self.cvt.convert_to_decimal(\"V\")) \n     def test_parsing_one(self): \n        self.assertEqual(1,self.cvt.convert_to_decimal(\"I\")) \n     def test_empty_roman_numeral(self): \n        self.assertTrue(self.cvt.convert_to_decimal() == 0) \n        self.assertFalse(self.cvt.convert_to_decimal() > 0) \n     def test_no_roman_numeral(self): \n        self.assertRaises(TypeError,\\\n                          self.cvt.convert_to_decimal,None)\n```", "```py\nif __name__==\"__main__\": \n     unittest.main()\n```", "```py\nclass RomanNumeralConverter(object): \n    def __init__(self, roman_numeral): \n        self.roman_numeral = roman_numeral \n        self.digit_map = {\"M\":1000, \"D\":500, \"C\":100, \"L\":50,\\\n                           \"X\":10,\"V\":5, \"I\":1} \n\n    def convert_to_decimal(self):\n        val = 0 \n        for char in self.roman_numeral:\n            val += self.digit_map[char] \n        return val\n```", "```py\nimport unittest\nclass RomanNumeralConverterTest(unittest.TestCase): \n```", "```py\ndef test_parsing_millenia(self): \n    value =RomanNumeralConverter(\"M\") \n    self.assertEqual(1000, value.convert_to_decimal()) \n\ndef test_parsing_century(self): \n    \"This test method is coded to fail for demo.\"\n     value =RomanNumeralConverter(\"C\") \n     self.assertEqual(10, value.convert_to_decimal()) \n```", "```py\nif __name__== \"__main__\": \n    suite = unittest.TestLoader().loadTestsFromTestCase(\\\n              RomanNumeralConverterTest) \n    unittest.TextTestRunner(verbosity=2).run(suite) \n```", "```py\nclass RomanNumeralConverter(object):\n    def __init__(self, roman_numeral): \n        self.roman_numeral = roman_numeral \n        self.digit_map = {\"M\":1000, \"D\":500,\\\n                        \"C\":100, \"L\":50, \"X\":10, \"V\":5, \"I\":1} \n\n    def convert_to_decimal(self):\n        val = 0 \n        for char in self.roman_numeral: \n            val+=self.digit_map[char]\n        return val\n```", "```py\nimport unittest \nclass RomanNumeralConverterTest(unittest.TestCase): \n```", "```py\n    def test_parsing_millenia(self):\n        value = RomanNumeralConverter(\"M\") \n        self.assertEquals(1000, value.convert_to_decimal()) \n\n    def test_parsing_century(self):\n        value = RomanNumeralConverter(\"C\") \n        self.assertEquals(100, value.convert_to_decimal()) \n```", "```py\nif __name__= \"__main__\":\n    import sys\n    suite = unittest.TestSuite()\n    if len(sys.argv) == 1:\n        suite = unittest.TestLoader().loadTestsFromTestCase(\\                                                                       RomanNumeralConverterTest) \n    else: \n        for test_name in sys.argv[1:]:\n            suite.addTest(RomanNumeralConverterTest(test_name))\n\n    unittest.TextTestRunner(verbosity=2).run(suite) \n```", "```py\nclass RomanNumeralConverter(object): \n    def __init__(self): \n            self.digit_map = {\"M\":1000, \"D\":500,\\\n                        \"C\":100, \"L\":50, \"X\":10, \"V\":5, \"I\":1} \n\n    def convert_to_decimal(self, roman_numeral):\n            val = 0 \n            for char in roman_numeral: \n                val += self.digit_map[char] \n            return val \n```", "```py\nimport unittest \nclass RomanNumeralConverterTest(unittest.TestCase): \n    def setUp(self): \n        self.cvt = RomanNumeralConverter()\n    def test_parsing_millenia(self): \n        self.assertEquals(1000, \\ \n                    self.cvt.convert_to_decimal(\"M\")) \n\n    def test_parsing_century(self): \n        self.assertEquals(100, \\ \n                    self.cvt.convert_to_decimal(\"C\")) \n\nclass RomanNumeralComboTest(unittest.TestCase):\n    def setUp(self):\n        self.cvt=RomanNumeralConverter()\n    def test_multi_millenia(self):\n        self.assertEquals(4000,\\\n    def test_multi_add_up(self): \n        self.assertEquals(2010, \\ \n        self.cvt.convert_to_decimal(\"MMX\"))\n```", "```py\nif __name__ == \"__main__\": \n    import unittest \n    from recipe5 import * \n    suite1 = unittest.TestLoader().loadTestsFromTestCase( \\  \n                RomanNumeralConverterTest) \n    suite2 = unittest.TestLoader().loadTestsFromTestCase( \\ \n                RomanNumeralComboTest) \n    suite = unittest.TestSuite([suite1, suite2])     \n    unittest.TextTestRunner(verbosity=2).run(suite)\n```", "```py\nclass RomanNumeralConverter(object): \n    def __init__(self): \n        self.digit_map = {\"M\":1000, \"D\":500, \"C\":100, \"L\":50, \"X\":10, \"V\":5, \"I\":1} \n\n    def convert_to_decimal(self, roman_numeral): \n    val = 0 \n    for char in roman_numeral: \n        val += self.digit_map[char] \n    return val \n```", "```py\nimport unittest \nclass RomanNumeralConverterTest(unittest.TestCase): \n```", "```py\nimport unittest \n\nclass RomanNumeralConverterTest(unittest.TestCase): \n    def setUp(self): \n        self.cvt = RomanNumeralConverter() \n\n    def test_parsing_millenia(self): \n        self.assertEquals(1000, \\ \n             self.cvt.convert_to_decimal(\"M\")) \n\n    def test_parsing_century(self): \n        self.assertEquals(100, \\ \n            self.cvt.convert_to_decimal(\"C\")) \n\n    def test_parsing_half_century(self): \n        self.assertEquals(50, \\ \n            self.cvt.convert_to_decimal(\"L\")) \n\n    def test_parsing_decade(self): \n        self.assertEquals(10, \\ \n            self.cvt.convert_to_decimal(\"X\")) \n\n    def test_parsing_half_decade(self): \n        self.assertEquals(5, self.cvt.convert_to_decimal(\"V\")) \n\n    def test_parsing_one(self): \n        self.assertEquals(1, self.cvt.convert_to_decimal(\"I\")) \n\n    def test_empty_roman_numeral(self):     \n        self.assertTrue(self.cvt.convert_to_decimal(\"\") == 0) \n        self.assertFalse(self.cvt.convert_to_decimal(\"\") > 0) \n\n    def test_no_roman_numeral(self): \n        self.assertRaises(TypeError, \\ \n            self.cvt.convert_to_decimal, None) \n\n    def test_combo1(self): \n        self.assertEquals(4000, \\ \n            self.cvt.convert_to_decimal(\"MMMM\")) \n\n    def test_combo2(self): \n        self.assertEquals(2010, \\ \n            self.cvt.convert_to_decimal(\"MMX\")) \n\n    def test_combo3(self): \n        self.assertEquals(4668, \\ \n            self.cvt.convert_to_decimal(\"MMMMDCLXVIII\")) \n```", "```py\ndef high_and_low(): \n    suite = unittest.TestSuite() \n    suite.addTest(\\ \n        RomanNumeralConverterTest(\"test_parsing_millenia\"))    \n    suite.addTest(\\ \n        RomanNumeralConverterTest(\"test_parsing_one\")) return suite \ndef combos(): \n    return unittest.TestSuite(map(RomanNumeralConverterTest,\\    \n        [\"test_combo1\", \"test_combo2\", \"test_combo3\"])) \ndef all(): \n    return unittest.TestLoader().loadTestsFromTestCase(\\   \n            RomanNumeralConverterTest) \n```", "```py\nif __name__ == \"__main__\": \n    for suite_func in [high_and_low, combos, all]: \n        print (\"Running test suite '%s'\" % suite_func.__name__)  \n        suite = suite_func()    \n        unittest.TextTestRunner(verbosity=2).run(suite)\n```", "```py\nclass RomanNumeralConverter(object): \n    def __init__(self): \n        self.digit_map = {\"M\":1000, \"D\":500, \"C\":100, \"L\":50, \"X\":10, \"V\":5, \"I\":1} \n\n    def convert_to_decimal(self, roman_numeral): \n        val = 0 \n        for char in roman_numeral: \n            val += self.digit_map[char] \n        return val \n```", "```py\nfrom recipe7 import * \nclass RomanNumeralTester(object): \n  def   init  (self): \n    self.cvt = RomanNumeralConverter() \n  def simple_test(self):\n    print (\"+++ Converting M to 1000\")\n    assert self.cvt.convert_to_decimal(\"M\") == 1000\n  def combo_test1(self): \n    print (\"+++ Converting MMX to 2010\") \n    assert self.cvt.convert_to_decimal(\"MMXX\") == 2010 \n  def combo_test2(self): \n    print (\"+++ Converting MMMMDCLXVIII to 4668\") \n    val = self.cvt.convert_to_decimal(\"MMMMDCLXVII\")         \n    self.check(val, 4668) \n  def other_test(self): \n    print (\"+++ Converting MMMM to 4000\") \n    val = self.cvt.convert_to_decimal(\"MMMM\") \n    self.check(val, 4000) \n  def check(self, actual, expected): \n    if (actual != expected): \n      raise AssertionError(\"%s doesn't equal %s\" % \\ \n            (actual,  expected)) \n  def test_the_system(self): \n    self.simple_test() \n    self.combo_test1() \n    self.combo_test2() \n    self.other_test() \nif __name == \"__main__\": \n  tester = RomanNumeralTester() \n  tester.test_the_system()\n```", "```py\nfrom recipe7 import * \nfrom recipe7_legacy import * import unittest \n\nif __name__ == \"__main__\":  \n    tester = RomanNumeralTester() \n    suite = unittest.TestSuite() \n    for test in [tester.simple_test, tester.combo_test1, \\ \n            tester.combo_test2, tester.other_test]: \n        testcase = unittest.FunctionTestCase(test)   \n        suite.addTest(testcase) \n    unittest.TextTestRunner(verbosity=2).run(suite)\n```", "```py\ndef combo_test1(self): \n    print (\"+++ Converting MMX to 2010\") \n    assert self.cvt.convert_to_decimal(\"MMXX\") == 2010 \ndef combo_test2(self): \n    print (\"+++ Converting MMMMDCLXVIII to 4668\")\n    val = self.cvt.convert_to_decimal(\"MMMMDCLXVII\") \n    self.check(val, 4668) \n```", "```py\nclass RomanNumeralConverter(object): \n    def __init__(self): \n        self.digit_map = {\"M\":1000, \"D\":500, \"C\":100, \"L\":50, \"X\":10, \"V\":5, \"I\":1} \n\n    def convert_to_decimal(self, roman_numeral): \n        val = 0 \n        for char in roman_numeral: \n        val += self.digit_map[char] \n    return val \n\n    def convert_to_roman(self, decimal): \n        val = \"\" \n    while decimal > 1000: \n        val += \"M\" \n        decimal -= 1000 \n    while decimal > 500: \n        val += \"D\"\n        decimal -= 500 \n    while decimal > 100: \n        val += \"C\" \n        decimal -= 100 \n    while decimal > 50: \n        val += \"L\" \n        decimal -= 50 \n    while decimal > 10: \n        val += \"X\" \n        decimal -= 10 \n    while decimal > 5: \n        val += \"V\" \n        decimal -= 5 \n    while decimal > 1: \n        val += \"I\" \n        decimal -= 1 \n    return val \n```", "```py\nimport unittest \nfrom recipe8 import * \n\nclass RomanNumeralTest(unittest.TestCase): \n    def setUp(self): \n        self.cvt = RomanNumeralConverter() \n\n    def test_convert_to_decimal(self): \n        self.assertEquals(0, self.cvt.convert_to_decimal(\"\"))     \n        self.assertEquals(1, self.cvt.convert_to_decimal(\"I\"))    \n        self.assertEquals(2010, \\ \n            self.cvt.convert_to_decimal(\"MMX\")) \n        self.assertEquals(4000, \\ \n            self.cvt.convert_to_decimal(\"MMMM\")) \n    def test_convert_to_roman(self): \n        self.assertEquals(\"\", self.cvt.convert_to_roman(0)) \n        self.assertEquals(\"II\", self.cvt.convert_to_roman(2))     \n        self.assertEquals(\"V\", self.cvt.convert_to_roman(5))    \n        self.assertEquals(\"XII\", \\ \n            self.cvt.convert_to_roman(12)) \n        self.assertEquals(\"MMX\", \\ \n            self.cvt.convert_to_roman(2010)) \n        self.assertEquals(\"MMMM\", \\ \n            self.cvt.convert_to_roman(4000))\n\nif __name__ == \"__main__\":  \n    unittest.main()\n```", "```py\nimport unittest \nfrom recipe8 import * \n\nclass RomanNumeralTest(unittest.TestCase): \n    def setUp(self): \n        self.cvt = RomanNumeralConverter() \n\n    def test_to_decimal1(self): \n        self.assertEquals(0, self.cvt.convert_to_decimal(\"\")) \n\n    def test_to_decimal2(self): \n        self.assertEquals(1, self.cvt.convert_to_decimal(\"I\")) \n\n    def test_to_decimal3(self): \n        self.assertEquals(2010, \\ \n            self.cvt.convert_to_decimal(\"MMX\")) \n\n    def test_to_decimal4(self): \n        self.assertEquals(4000, \\ \n            self.cvt.convert_to_decimal(\"MMMM\")) \n\n    def test_convert_to_roman1(self): \n        self.assertEquals(\"\", self.cvt.convert_to_roman(0)) \n\n    def test_convert_to_roman2(self): \n        self.assertEquals(\"II\", self.cvt.convert_to_roman(2)) \n\n    def test_convert_to_roman3(self): \n        self.assertEquals(\"V\", self.cvt.convert_to_roman(5)) \n\n    def test_convert_to_roman4(self): \n        self.assertEquals(\"XII\", \\ \n                    self.cvt.convert_to_roman(12)) \n\n    def test_convert_to_roman5(self): \n        self.assertEquals(\"MMX\", \\ \n                    self.cvt.convert_to_roman(2010)) \n\n    def test_convert_to_roman6(self): \n        self.assertEquals(\"MMMM\", \\ \n                    self.cvt.convert_to_roman(4000)) \n\nif __name__ == \"__main__\": \nunittest.main() \n```", "```py\nwhile decimal > 1000: \nwhile decimal > 500: \nwhile decimal > 100: \nwhile decimal > 50: \nwhile decimal > 10: \nwhile decimal > 5: \nwhile decimal > 1:\n```", "```py\nclass RomanNumeralConverter(object): \n    def __init__(self): \n      self.digit_map = {\"M\":1000, \"D\":500, \"C\":100, \"L\":50, \"X\":10, \"V\":5, \"I\":1} \n    def convert_to_decimal(self, roman_numeral): \n        val = 0 \n        for char in roman_numeral: \n            val += self.digit_map[char] \n        if val > 4000: \n        raise Exception(\"We don't handle values over 4000\") \n    return val\n\n    def convert_to_roman(self, decimal): \n        if decimal > 4000: \n            raise Exception(\"We don't handle values over 4000\") \n        val = \"\" \n        mappers = [(1000,\"M\"), (500,\"D\"), (100,\"C\"), (50,\"L\"), \n(10,\"X\"), (5,\"V\"), (1,\"I\")] \n        for (mapper_dec, mapper_rom) in mappers: \n            while decimal >= mapper_dec: \n                val += mapper_rom \n                decimal -= mapper_dec \n        return val \n```", "```py\nimport unittest \n\nclass RomanNumeralTest(unittest.TestCase): \n    def setUp(self): \n      self.cvt = RomanNumeralConverter() \n```", "```py\ndef test_to_roman_bottom(self): \n    self.assertEquals(\"I\", self.cvt.convert_to_roman(1))  \n\ndef test_to_roman_below_bottom(self): \n    self.assertEquals(\"\", self.cvt.convert_to_roman(0)) \n\ndef test_to_roman_negative_value(self): \n    self.assertEquals(\"\", self.cvt.convert_to_roman(-1)) \n\ndef test_to_roman_top(self): \n    self.assertEquals(\"MMMM\", \\ \n                self.cvt.convert_to_roman(4000)) \n\ndef test_to_roman_above_top(self): \n    self.assertRaises(Exception, \\ \n                self.cvt.convert_to_roman, 4001) \n```", "```py\ndef test_to_decimal_bottom(self): \n    self.assertEquals(1, self.cvt.convert_to_decimal(\"I\")) \n\ndef test_to_decimal_below_bottom(self): \n    self.assertEquals(0, self.cvt.convert_to_decimal(\"\")) \n\ndef test_to_decimal_top(self):  \n    self.assertEquals(4000, \\ \n                self.cvt.convert_to_decimal(\"MMMM\")) \n\ndef test_to_decimal_above_top(self):      \n    self.assertRaises(Exception, \\ \n                self.cvt.convert_to_decimal, \"MMMMI\")\n```", "```py\ndef test_to_roman_tier1(self): \n    self.assertEquals(\"V\", self.cvt.convert_to_roman(5)) \n\ndef test_to_roman_tier2(self): \n    self.assertEquals(\"X\", self.cvt.convert_to_roman(10)) \n\ndef test_to_roman_tier3(self): \n    self.assertEquals(\"L\", self.cvt.convert_to_roman(50)) \n\ndef test_to_roman_tier4(self): \n    self.assertEquals(\"C\", self.cvt.convert_to_roman(100)) \n\ndef test_to_roman_tier5(self): \n    self.assertEquals(\"D\", self.cvt.convert_to_roman(500)) \n\ndef test_to_roman_tier6(self): \n    self.assertEquals(\"M\", \\ \n                self.cvt.convert_to_roman(1000)) \n```", "```py\ndef test_to_roman_bad_inputs(self): \n    self.assertEquals(\"\", self.cvt.convert_to_roman(None))     \n    self.assertEquals(\"I\", self.cvt.convert_to_roman(1.2)) \n\ndef test_to_decimal_bad_inputs(self):   \n    self.assertRaises(TypeError, \\ \n                self.cvt.convert_to_decimal, None) \n    self.assertRaises(TypeError, \\ \n                self.cvt.convert_to_decimal, 1.2) \n```", "```py\nif __name__ == \"__main__\": \n  unittest.main() \n```", "```py\nclass RomanNumeralConverter(object): \n    def __init__(self): \n        self.digit_map = {\"M\":1000, \"D\":500, \"C\":100, \"L\":50, \"X\":10, \"V\":5, \"I\":1} \n\n    def convert_to_decimal(self, roman_numeral): \n        val = 0 \n        for char in roman_numeral: \n            val += self.digit_map[char] \n        if val > 4000: \n            raise Exception(\\ \n                \"We don't handle values over 4000\") \n        return val \n\n    def convert_to_roman(self, decimal): \n        if decimal > 4000: \n            raise Exception(\\ \n                \"We don't handle values over 4000\") \n        val = \"\"  \n        mappers = [(1000,\"M\"), (500,\"D\"), (100,\"C\"), (50,\"L\"), \n(10,\"X\"), (5,\"V\"), (1,\"I\")] \n        for (mapper_dec, mapper_rom) in mappers: \n            while decimal >= mapper_dec: \n                val += mapper_rom \n                decimal -= mapper_dec \n        return val \n```", "```py\nimport unittest \n\nclass RomanNumeralTest(unittest.TestCase): \n    def setUp(self): \n        self.cvt = RomanNumeralConverter()\n```", "```py\ndef test_edges(self): \n    r = self.cvt.convert_to_roman \n    d = self.cvt.convert_to_decimal \n    edges = [(\"equals\", r, \"I\", 1),\\ \n          (\"equals\", r, \"\", 0),\\ \n          (\"equals\", r, \"\", -1),\\ \n          (\"equals\", r, \"MMMM\", 4000),\\ \n          (\"raises\", r, Exception, 4001),\\ \n          (\"equals\", d, 1, \"I\"),\\ \n          (\"equals\", d, 0, \"\"),\\ \n          (\"equals\", d, 4000, \"MMMM\"),\\\n          (\"raises\", d, Exception, \"MMMMI\") \n         ] \n    [self.checkout_edge(edge) for edge in edges\n```", "```py\ndef test_tiers(self):\n    r = self.cvt.convert_to_roman\n    edges = [(\"equals\", r, \"V\", 5),\\\n         (\"equals\", r, \"VIIII\", 9),\\\n         (\"equals\", r, \"X\", 10),\\\n         (\"equals\", r, \"XI\", 11),\\\n         (\"equals\", r, \"XXXXVIIII\", 49),\\\n         (\"equals\", r, \"L\", 50),\\\n         (\"equals\", r, \"LI\", 51),\\\n         (\"equals\", r, \"LXXXXVIIII\", 99),\\\n         (\"equals\", r, \"C\", 100),\\\n         (\"equals\", r, \"CI\", 101),\\\n         (\"equals\", r, \"CCCCLXXXXVIIII\", 499),\\\n         (\"equals\", r, \"D\", 500),\\\n         (\"equals\", r, \"DI\", 501),\\\n         (\"equals\", r, \"M\", 1000)\\\n        ]\n    [self.checkout_edge(edge) for edge in edges]\n```", "```py\ndef test_bad_inputs(self): \n    r = self.cvt.convert_to_roman \n    d = self.cvt.convert_to_decimal \n    edges = [(\"equals\", r, \"\", None),\\ \n        (\"equals\", r, \"I\", 1.2),\\ \n        (\"raises\", d, TypeError, None),\\ \n        (\"raises\", d, TypeError, 1.2)\\ \n       ] \n    [self.checkout_edge(edge) for edge in edges]\n```", "```py\ndef checkout_edge(self, edge): \n    if edge[0] == \"equals\": \n      f, output, input = edge[1], edge[2], edge[3]    \n      print(\"Converting %s to %s...\" % (input, output))    \n      self.assertEquals(output, f(input)) \n    elif edge[0] == \"raises\": \n      f, exception, args = edge[1], edge[2], edge[3:]    \n      print(\"Converting %s, expecting %s\" % \\ \n                      (args, exception)) \n      self.assertRaises(exception, f, *args)\n```", "```py\n  if __name__ == \"__main__\": \n    suite = unittest.TestLoader().loadTestsFromTestCase( \\    \n                RomanNumeralTest) \n    unittest.TextTestRunner(verbosity=2).run(suite)\n```", "```py\ndef test_bad_inputs(self): \n    r = self.cvt.convert_to_roman \n    d = self.cvt.convert_to_decimal \n    edges = [(\"equals\", r, \"\", None),\\ \n         (\"equals\", r, \"I\", 1.2),\\ \n         (\"raises\", d, TypeError, None),\\ \n         (\"raises\", d, TypeError, 1.2)\\ \n        ] \n\n    [self.checkout_edge(edge) for edge in edges] \n```"]