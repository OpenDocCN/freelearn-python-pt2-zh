["```py\npublic class FooTest extends TestCase  {\n    public void testIsASingleton() {}\n    public void testAReallyLongNameIsAGoodThing() {}\n}\n```", "```py\nFoo\n-is a singleton\n-a really long name is a good thing\n```", "```py\nclass ShoppingCart(object):\n    def __init__(self):\n       self.items = []\n    def add(self, item, price):\n       for cart_item in self.items:\n           # Since we found the item, we increment\n           # instead of append\n           if cart_item.item == item: \n              cart_item.q += 1\n              return self\n       # If we didn't find, then we append \n       self.items.append(Item(item, price))\n       return self\n    def item(self, index):\n        return self.items[index-1].item\n    def price(self, index):\n        return self.items[index-1].price * self.items[index-1].q\n    def total(self, sales_tax):\n        sum_price=sum([item.price*item.q for item in self.items])\n        return sum_price*(1.0 + sales_tax/100.0)\n    def __len__(self):\n        return sum([item.q for item in self.items])\nclass Item(object):\n    def __int__(self,item,price,q=1):\n        self.item=item\n        self.price=price\n        self.q=q\n```", "```py\nimport unittest\nfrom cart import *\nclass CartWithOneItem(unittest.TestCase):\n      def setUp(self):\n          self.cart = ShoppingCart().add(\"tuna sandwich\", 15.00)\n      def test_when_checking_the_size_should_be_one_based(self):\n          self.assertEquals(1, len(self.cart))\n      def test_when_looking_into_cart_should_be_one_based(self):\n          self.assertEquals(\"tuna sandwich\", self.cart.item(1))\n          self.assertEquals(15.00, self.cart.price(1))\n      def test_total_should_have_in_sales_tax(self):\n          self.assertAlmostEquals(15.0*1.0925, \\\n                              self.cart.total(9.25), 2)\n```", "```py\nclass CartWithTwoItems(unittest.TestCase):\n     def setUp(self):\n         self.cart = ShoppingCart()\\\n                       .add(\"tuna sandwich\", 15.00)\\\n                       .add(\"rootbeer\", 3.75) \n    def test_when_checking_size_should_be_two(self):\n        self.assertEquals(2, len(self.cart))\n    def test_items_should_be_in_same_order_as_entered(self):\n       self.assertEquals(\"tuna sandwich\", self.cart.item(1))\n       self.assertAlmostEquals(15.00, self.cart.price(1), 2)\n       self.assertEquals(\"rootbeer\", self.cart.item(2)) \n       self.assertAlmostEquals(3.75, self.cart.price(2), 2)\n   def test_total_price_should_have_in_sales_tax(self):\n       self.assertAlmostEquals((15.0+3.75)*1.0925,self.cart.total(9.25),2)\n```", "```py\nclass CartWithNoItems(unittest.TestCase): \n    def setUp(self):\n       self.cart = ShoppingCart()\n   def test_when_checking_size_should_be_empty(self): \n      self.assertEquals(0, len(self.cart))\n   def test_finding_item_out_of_range_should_raise_error(self):\n      self.assertRaises(IndexError, self.cart.item, 2)\n   def test_finding_price_out_of_range_should_raise_error(self): \n      self.assertRaises(IndexError, self.cart.price, 2)\n   def test_when_looking_at_total_price_should_be_zero(self):\n      self.assertAlmostEquals(0.0, self.cart.total(9.25), 2)\n   def test_adding_items_returns_back_same_cart(self): \n      empty_cart = self.cart\n      cart_with_one_item=self.cart.add(\"tuna sandwich\",15.00)\n      self.assertEquals(empty_cart, cart_with_one_item) \n      cart_with_two_items = self.cart.add(\"rootbeer\", 3.75) \n      self.assertEquals(empty_cart, cart_with_one_item)\n      self.assertEquals(cart_with_one_item, cart_with_two_items)\n```", "```py\nimport sys\nerr = sys.stderr\nimport nose\nimport re\nfrom nose.plugins import Plugin\nclass BddPrinter(Plugin): \n     name = \"bdd\"\n     def __init__(self): \n         Plugin.__init__(self) \n         self.current_module = None\n```", "```py\ndef beforeTest(self, test): \n    test_name = test.address()[-1]\n    module, test_method = test_name.split(\".\") \n    if self.current_module != module:\n       self.current_module = module\n    fmt_mod = re.sub(r\"([A-Z])([a-z]+)\", r\"\\1\\2 \", module)\n    err.write(\"\\nGiven %s\" % fmt_mod[:-1].lower()) \n    message = test_method[len(\"test\"):]\n    message = \" \".join(message.split(\"_\")) err.write(\"\\n- %s\" % message)\n```", "```py\ndef addSuccess(self, *args, **kwargs): \n    test = args[0]\n    err.write(\" : Ok\")\ndef addError(self, *args, **kwargs): \n    test, error = args[0], args[1] \n    err.write(\" : ERROR!\\n\")\ndef addFailure(self, *args, **kwargs): \n    test, error = args[0], args[1] \n    err.write(\" : Failure!\\n\")\n```", "```py\nif __name__ == \"__main__\": \n   import nose\n   from recipe26_plugin import *\n   nose.run(argv=[\"\", \"recipe26\", \"--with-bdd\"], plugins=[BddPrinter()])\n```", "```py\n def test_when_checking_the_size_should_be_one_based(self):\n        self.assertEquals(2, len(self.cart))\n...\n    def test_items_should_be_in_same_order_as_entered(self): \n        self.assertEquals(\"tuna sandwich\", self.cart.item(1)) \n        self.assertAlmostEquals(14.00, self.cart.price(1), 2) \n        self.assertEquals(\"rootbeer\", self.cart.item(2)) \n        self.assertAlmostEquals(3.75, self.cart.price(2), 2)\n```", "```py\nThis is a way to exercise the shopping cart \nfrom a pure text file containing tests.\nFirst, we need to import the modules \n>>> from cart import *\nNow, we can create an instance of a cart \n>>> cart = ShoppingCart()\nHere we use the API to add an object. Because it returns back the cart, we have to deal with the output\n>>> cart.add(\"tuna sandwich\", 15.00) #doctest:+ELLIPSIS \n<cart.ShoppingCart object at ...>\nNow we can check some other outputs\n>>> cart.item(1) \n'tuna sandwich' \n>>> cart.price(1) \n15.0\n>>> cart.total(0.0) \n15.0\n```", "```py\nThis is a way to exercise the shopping cart \nfrom a pure text file containing tests.\nFirst, we need to import the modules \n>>> from cart import *\nNow, we can create an instance of a cart \n>>> cart = ShoppingCart()\nNow we try to access an item out of range, expecting an exception.\n>>> cart.item(5)\nTraceback (most recent call last): \n...\nIndexError: list index out of range\nWe also expect the price method to fail in a similar way.\n>>> cart.price(-2)\nTraceback (most recent call last): \n...\nIndexError: list index out of range\n```", "```py\nif __name__ == \"__main__\":\n   import doctest\n   from glob import glob\n   for file in glob(\"recipe27*.doctest\"):\n      print (\"Running tests found in %s\" % file) \n      doctest.testfile(file)\n```", "```py\nif __name__ == \"__main__\":\n   import doctest\n   doctest.testfile(\"recipe27_bad_scenario.txt\")\n\n```", "```py\nThis scenario demonstrates a testable story.\nFirst, we need to import the modules \n>>> from cart import *\n>>> cart = ShoppingCart()\n#when we add an item\n>>> cart.add(\"carton of milk\", 2.50) #doctest:+ELLIPSIS \n<cart.ShoppingCart object at ...>\n#the first item is a carton of milk \n>>> cart.item(1)\n'carton of milk'\n#the first price is $2.50 \n>>> cart.price(1)\n2.5\n#there is only one item \n>>> len(cart)\nThis shopping cart lets us grab more than one of a particular item.\n#when we add a second carton of milk\n>>> cart.add(\"carton of milk\", 2.50) #doctest:+ELLIPSIS \n<cart.ShoppingCart object at ...>\n#the first item is still a carton of milk \n>>> cart.item(1)\n'carton of milk'\n#but the price is now $5.00 \n>>> cart.price(1)\n5.0\n#and the cart now has 2 items \n>>> len(cart)\n2\n#for a total (with 10% taxes) of $5.50 \n>>> cart.total(10.0)\n5.5\n```", "```py\nimport doctest\nclass BddDocTestRunner(doctest.DocTestRunner): \n      \"\"\"\n      This is a customized test runner. It is meant \n      to run code examples like DocTestRunner,\n      but if a line preceeds the code example \n      starting with '#', then it prints that \n      comment.\n      If the line starts with '#when', it is printed \n      out like a sentence, but with no outcome.\n      If the line starts with '#', but not '#when'\n      it is printed out indented, and with the outcome.\n      \"\"\"\n```", "```py\ndef report_start(self, out, test, example):\n    prior_line = example.lineno-1\n    line_before = test.docstring.splitlines()[prior_line] \n    if line_before.startswith(\"#\"):\n       message = line_before[1:]\n       if line_before.startswith(\"#when\"):\n          out(\"* %s\\n\" % message) \n          example.silent = True \n          example.indent = False\n       else:\n         out(\" - %s: \" % message) \n         example.silent = False \n         example.indent = True\n   else:\n     example.silent = True \n     example.indent = False\n\n   doctest.DocTestRunner(out, test, example)\n```", "```py\ndef report_success(self, out, test, example, got):\n    if not example.silent:\n       out(\"ok\\n\")\n    if self._verbose:\n       if example.indent: out(\" \") \n          out(\">>> %s\\n\" % example.source[:-1])\n```", "```py\ndef report_failure(self, out, test, example, got):\n    if not example.silent:\n       out(\"FAIL\\n\")\n    if self._verbose:\n       if example.indent: out(\" \") \n           out(\">>> %s\\n\" % example.source[:-1])\n```", "```py\nif __name__ == \"__main__\":\n   from glob import glob\n   doctest.DocTestRunner = BddDocTestRunner\n   for file in glob(\"recipe28*.doctest\"):\n       given = file[len(\"recipe28_\"):]\n       given = given[:-len(\".doctest\")]\n       given = \" \".join(given.split(\"_\"))\n       print (\"===================================\")\n       print (\"Given a %s...\" % given)\n       print (\"===================================\")\n       doctest.testfile(file)\n```", "```py\n#there is only one item \n>>> len(cart)\n4668\n```", "```py\nif __name__ == \"__main__\":\n   from glob import glob\n   doctest.DocTestRunner = BddDocTestRunner\n   for file in glob(\"recipe29*.doctest\"):\n given = file[len(\"recipe29_\"):] \n       given = given[:-len(\".doctest\")]\n       given = \" \".join(given.split(\"_\"))\n       print (\"===================================\")\n       print (\"Given a %s...\" % given)\n       print (\"===================================\")\n       doctest.testfile(file)\n```", "```py\n>>> from cart import *\n>>> cart = ShoppingCart()\n#when we add an item\n>>> cart.add(\"carton of milk\", 2.50) #doctest:+ELLIPSIS\n<cart.ShoppingCart object at ...>\n#the first item is a carton of milk\n>>> cart.item(1)\n'carton of milk'\n#the first price is $2.50\n>>> cart.price(1)\n2.5\n#there is only one item\n>>> len(cart)\n1\nThis shopping cart let's us grab more than one of a particular item.\n#when we add a second carton of milk\n>>> cart.add(\"carton of milk\", 2.50) #doctest:+ELLIPSIS\n<cart.ShoppingCart object at ...>\n#the first item is still a carton of milk\n>>> cart.item(1) \n'carton of milk'\n#but the price is now $5.00\n>>> cart.price(1)\n5.0\n#and the cart now has 2 items\n>>> len(cart)\n2\n#for a total (with 10% taxes) of $5.50\n>>> cart.total(10.0)\n5.5\n\n```", "```py\n>>> from cart import *\n>>> cart = ShoppingCart()\n#when we add a carton of milk...\n>>> cart.add(\"carton of milk\", 2.50) #doctest:+ELLIPSIS \n<cart.ShoppingCart object at ...>\n#when we add a frozen pizza...\n>>> cart.add(\"frozen pizza\", 3.00) #doctest:+ELLIPSIS\n <cart.ShoppingCart object at ...>\n#the first item is the carton of milk\n>>> cart.item(1)\n'carton of milk'\n#the second item is the frozen pizza\n>>> cart.item(2)\n'frozen pizza'\n#the first price is $2.50\n>>> cart.price(1)\n2.5\n#the second price is $3.00\n>>> cart.price(2)\n3.0\n#the total with no tax is $5.50\n>>> cart.total(0.0)\n5.5\n#the total with 10% tax is $6.05\n>>> print (round(cart.total(10.0), 2) )\n6.05\n```", "```py\n>>>from cart import *\n#when we create an empty shopping cart \n>>> cart = ShoppingCart()\n#accessing an item out of range generates an exception\n>>> cart.item(5)\nTraceback (most recent call last):\n...\nIndexError: list index out of range\n#accessing a price with a negative index causes an exception\n>>> cart.price(-2)\nTraceback (most recent call last):\n...\nIndexError: list index out of range\n#calculating a price with no tax results in $0.00\n>>> cart.total(0.0)\n0.0\n#calculating a price with a tax results in $0.00\n>>> cart.total(10.0)\n0.0\n```", "```py\nrecipe29_cart_we_will_load_with_identical_items.doctest\nrecipe29_cart_we_will_load_with_two_different_items.doctest\nrecipe29_cart_that_we_intend_to_keep_empty.doctest\n```", "```py\nclass ShoppingCart(object):\n     def __init__(self, storer=None):\n        self.items = []\n        self.storer = storer\n```", "```py\n    def store(self):\n        return self.storer.store_cart(self)\n```", "```py\n    def restore(self, id):\n       self.items = self.storer.retrieve_cart(id).items \n       return self\n```", "```py\nclass DataAccess(object):\n     def store_cart(self,cart):\n         pass\n     def retrieve_cart(self,id):\n         pass\n```", "```py\nimport unittest\nfrom copy import deepcopy \nfrom recipe30_cart import *\nfrom mock import Mock\nclass CartThatWeWillSaveAndRestoreUsingVoidspaceMock(unittest. TestCase):\n      def test_fill_up_a_cart_then_save_it_and_restore_it(self):\n          # Create an empty shopping cart\n          cart = ShoppingCart(DataAccess())\n          # Add a couple of items \n          cart.add(\"carton of milk\", 2.50) \n          cart.add(\"frozen pizza\", 3.00)\n          self.assertEquals(2, len(cart))\n          # Create a clone of the cart for mocking \n          # purposes.\n          original_cart = deepcopy(cart)\n          # Save the cart at this point in time into a database \n          # using a mock\n          cart.storer.store_cart = Mock()\n          cart.storer.store_cart.return_value = 1 \n          cart.storer.retrieve_cart = Mock() \n          cart.storer.retrieve_cart.return_value = original_cart\n          id = cart.store()\n          self.assertEquals(1, id)\n          # Add more items to cart \n          cart.add(\"cookie dough\", 1.75) \n          cart.add(\"ginger ale\", 3.25)\n          self.assertEquals(4, len(cart))\n          # Restore the cart to the last point in time \n          cart.restore(id)\n          self.assertEquals(2, len(cart))\n          cart.storer.store_cart.assert_called_with(cart)\n          cart.storer.retrieve_cart.assert_called_with(1)\n```", "```py\ncart.storer.store_cart.assert_called_with(cart)\ncart.storer.retrieve_cart.assert_called_with(1)\n```", "```py\nclass ShoppingCart(object):\n    def __init__(self, storer=None):\n    self.items = []\n    self.storer = storer\n```", "```py\n   def store(self):\n       return self.storer.store_cart(self)\n```", "```py\n  def restore(self, id):\n      self.items = self.storer.retrieve_cart(id).items\n      return self\n```", "```py\nclass DataAccess(object):\n     def store_cart(self, cart):\n         pass\n     def retrieve_cart(self, id):\n         pass\n```", "```py\nimport unittest\nfrom copy import deepcopy\nfrom recipe31_cart import *\nfrom mockito import *\nclass CartThatWeWillSaveAndRestoreUsingMockito(unittest.TestCase):\n      def test_fill_up_a_cart_then_save_it_and_restore_it(self):\n          # Create an empty shopping cart\n          cart = ShoppingCart(DataAccess())\n          # Add a couple of items\n          cart.add(\"carton of milk\", 2.50)\n          cart.add(\"frozen pizza\", 3.00)\n          self.assertEquals(2, len(cart))\n         # Create a clone of the cart for mocking\n         # purposes.\n         original_cart = deepcopy(cart)\n         # Save the cart at this point in time into a database\n         # using a mock\n         cart.storer = mock()\n         when(cart.storer).store_cart(cart).thenReturn(1)\n         when(cart.storer).retrieve_cart(1). \\   \n                             thenReturn(original_cart)\n         id = cart.store()\n         self.assertEquals(1, id)\n         # Add more items to cart\n         cart.add(\"cookie dough\", 1.75)\n         cart.add(\"ginger ale\", 3.25)\n         self.assertEquals(4, len(cart))\n         # Restore the cart to the last point in time\n         cart.restore(id)\n         self.assertEquals(2, len(cart))\n         verify(cart.storer).store_cart(cart)\n         verify(cart.storer).retrieve_cart(1)\n\n```", "```py\n         cart.storer.store_cart = Mock()\n         cart.storer.store_cart.return_value = 1\n         cart.storer.retrieve_cart = Mock()\n         cart.storer.retrieve_cart.return_value = original_cart\n```", "```py\n         cart.storer = mock()\n         when(cart.storer).store_cart(cart).thenReturn(1)\n         when(cart.storer).retrieve_cart(1).thenReturn(original_cart)\n```", "```py\nFeature: Shopping cart As a shopper\n   I want to load up items in my cart\n   So that I can check out and pay for them\n```", "```py\n       Scenario: Empty cart\n            Given an empty cart\n            Then looking up the fifth item causes an error\n            And looking up a negative price causes an error\n            And the price with no taxes is $0.00\n            And the price with taxes is $0.00\n```", "```py\n       Scenario: Cart getting loaded with multiple of the same \n            Given an empty cart\n            When I add a carton of milk for $2.50\n            And I add another carton of milk for $2.50 \n            Then the first item is a carton of milk\n            And the price is $5.00 And the cart has 2 items\n            And the total cost with 10% taxes is $5.50\n```", "```py\n    Scenario: Cart getting loaded with different items \n            Given an empty cart\n            When I add a carton of milk\n            And I add a frozen pizza\n            Then the first item is a carton of milk\n            And the second item is a frozen pizza\n            And the first price is $2.50\n            And the second price is $3.00\n            And the total cost with no taxes is $5.50\n            And the total cost with 10% taes is $6.05\n```", "```py\nfrom lettuce import *\nfrom cart import *\n@step(\"an empty cart\")\ndef an_empty_cart(step):\n   world.cart = ShoppingCart()\n```", "```py\n@step(\"looking up the fifth item causes an error\") \ndef looking_up_fifth_item(step):\n    try:\n      world.cart.item(5)\n      raise AssertionError(\"Expected IndexError\") \n    except IndexError, e:\n      pass\n@step(\"looking up a negative price causes an error\")\n    def looking_up_negative_price(step):\n        try:\n          world.cart.price(-2)\n             raise AssertionError(\"Expected IndexError\")\n        except IndexError, e:\n          pass\n@step(\"the price with no taxes is (.*)\")\n    def price_with_no_taxes(step, total):\n       assert world.cart.total(0.0) == float(total)\n@step(\"the price with taxes is (.*)\")\n    def price_with_taxes(step, total):\n        assert world.cart.total(10.0) == float(total)\n\n```", "```py\n@step(\"I add a carton of milk for (.*)\")\ndef add_a_carton_of_milk(step, price):\n    world.cart.add(\"carton of milk\", float(price))\n@step(\"I add another carton of milk for (.*)\")\ndef add_another_carton_of_milk(step, price):\n    world.cart.add(\"carton of milk\", float(price))\n@step(\"the first item is a carton of milk\")\ndef check_first_item(step):\n    assert world.cart.item(1) == \"carton of milk\"\n@step(\"the price is (.*)\")\ndef check_first_price(step, price):\n    assert world.cart.price(1) == float(price)\n@step(\"the cart has (.*) items\")\ndef check_size_of_cart(step, num_items): \n    assert len(world.cart) == float(num_items)\n@step(\"the total cost with (.*)% taxes is (.*)\")\ndef check_total_cost(step, tax_rate, total):\n    assert world.cart.total(float(tax_rate))==float(total)\n```", "```py\n@step(\"I add a carton of milk\")\ndef add_a_carton_of_milk(step):\n    world.cart.add(\"carton of milk\", 2.50)\n@step(\"I add a frozen pizza\")\ndef add_a_frozen_pizza(step):\n    world.cart.add(\"frozen pizza\", 3.00)\n@step(\"the second item is a frozen pizza\")\ndef check_the_second_item(step):\n    assert world.cart.item(2) == \"frozen pizza\"\n@step(\"the first price is (.*)\")\ndef check_the_first_price(step, price):\n   assert world.cart.price(1) == float(price)\n@step(\"the second price is (.*)\")\ndef check_the_second_price(step, price): \n    assert world.cart.price(2) == float(price)\n@step(\"the total cost with no taxes is (.*)\")\ndef check_total_cost_with_no_taxes(step, total):\n    assert world.cart.total(0.0) == float(total)\n@step(\"the total cost with (.*)% taxes is (.*)\")\ndef check_total_cost_with_taxes(step, tax_rate, total):\n    assert round(world.cart.total(float(tax_rate)),2) == float(total)\n```", "```py\n@step(\"the total cost with (.*)% taxes is (.*)\")\ndef check_total_cost(step, tax_rate, total):\n   assert world.cart.total(float(tax_rate)) == float(total)\n\n```", "```py\nFeature: Shopping cart\n  As a shopper\n  I want to load up items in my cart\n  So that I can check out and pay for them\n     Scenario: Empty cart\n        Given an empty cart\n        Then looking up the fifth item causes an error\n        And looking up a negative price causes an error\n        And the price with no taxes is 0.0\n        And the price with taxes is 0.0\n     Scenario: Cart getting loaded with multiple of the same\n        Given an empty cart\n        When I add a carton of milk for 2.50\n        And I add another carton of milk for 2.50\n        Then the first item is a carton of milk\n        And the price is 5.00\n        And the cart has 2 items\n        And the total cost with 10% taxes is 5.50\n     Scenario: Cart getting loaded with different items\n        Given an empty cart\n        When I add a carton of milk\n        And I add a frozen pizza\n        Then the first item is a carton of milk\n        And the second item is a frozen pizza \n        And the first price is 2.50\n        And the second price is 3.00\n        And the total cost with no taxes is 5.50\n        And the total cost with 10% taxes is 6.05\n```", "```py\nfrom lettuce import *\nfrom should_dsl import should, should_not\nfrom cart import *\n@step(\"an empty cart\")\ndef an_empty_cart(step):\n    world.cart = ShoppingCart()\n@step(\"looking up the fifth item causes an error\")\ndef looking_up_fifth_item(step):\n   (world.cart.item, 5) |should| throw(IndexError)\n@step(\"looking up a negative price causes an error\")\ndef looking_up_negative_price(step):\n   (world.cart.price, -2) |should| throw(IndexError)\n@step(\"the price with no taxes is (.*)\")\ndef price_with_no_taxes(step, total):\n   world.cart.total(0.0) |should| equal_to(float(total))\n@step(\"the price with taxes is (.*)\")\ndef price_with_taxes(step, total):\n   world.cart.total(10.0) |should| equal_to(float(total))\n@step(\"I add a carton of milk for 2.50\")\ndef add_a_carton_of_milk(step):\n   world.cart.add(\"carton of milk\", 2.50)\n@step(\"I add another carton of milk for 2.50\")\ndef add_another_carton_of_milk(step):\n   world.cart.add(\"carton of milk\", 2.50)\n@step(\"the first item is a carton of milk\")\ndef check_first_item(step):\n   world.cart.item(1) |should| equal_to(\"carton of milk\")\n@step(\"the price is 5.00\")\ndef check_first_price(step):\n   world.cart.price(1) |should| equal_to(5.0)\n@step(\"the cart has 2 items\")\ndef check_size_of_cart(step):\n   len(world.cart) |should| equal_to(2)\n@step(\"the total cost with 10% taxes is 5.50\")\ndef check_total_cost(step):\n   world.cart.total(10.0) |should| equal_to(5.5)\n@step(\"I add a carton of milk\")\ndef add_a_carton_of_milk(step):\n   world.cart.add(\"carton of milk\", 2.50)\n@step(\"I add a frozen pizza\")\ndef add_a_frozen_pizza(step):\n   world.cart.add(\"frozen pizza\", 3.00)\n@step(\"the second item is a frozen pizza\")\ndef check_the_second_item(step):\n   world.cart.item(2) |should| equal_to(\"frozen pizza\")\n@step(\"the first price is 2.50\")\ndef check_the_first_price(step):\n   world.cart.price(1) |should| equal_to(2.5)\n@step(\"the second price is 3.00\")\ndef check_the_second_price(step):\n   world.cart.price(2) |should| equal_to(3.0)\n@step(\"the total cost with no taxes is 5.50\")\ndef check_total_cost_with_no_taxes(step):\n   world.cart.total(0.0) |should| equal_to(5.5)\n@step(\"the total cost with 10% taxes is (.*)\")\ndef check_total_cost_with_taxes(step, total):\n   world.cart.total(10.0) |should| close_to(float(total),\\\ndelta=0.1)\n```", "```py\nassert len(context.cart) == 2\n```", "```py\nlen(context.cart) |should| equal_to(2)\n```", "```py\ntry:\n  world.cart.price(-2)\n  raise AssertionError(\"Expected an IndexError\") \nexcept IndexError, e:\n   pass\n```", "```py\n(world.cart.price, -2) |should| throw(IndexError)\n```", "```py\nimport getopt\nimport logging \nimport nose \nimport os \nimport os.path \nimport re \nimport sys \nimport lettuce \nimport doctest\nfrom glob import glob\ndef usage(): \n    print()\n    print(\"Usage: python recipe34.py [command]\" \n    print()\n    print \"\\t--help\" \n    print \"\\t--test\" \n    print \"\\t--package\" \n    print \"\\t--publish\" \n    print \"\\t--register\" \n    print()\n    try:\n      optlist, args = getopt.getopt(sys.argv[1:], \n               \"h\",\n              [\"help\", \"test\", \"package\", \"publish\", \"register\"]) \n   except getopt.GetoptError:\n       # print help information and exit:\n       print \"Invalid command found in %s\" % sys.argv \n       usage()\n       sys.exit(2)\n```", "```py\ndef test_with_bdd():\n    from recipe26_plugin import BddPrinter\n    suite = [\"recipe26\", \"recipe30\", \"recipe31\"] \n    print(\"Running suite %s\" % suite)\n    args = [\"\"] \n    args.extend(suite) \n    args.extend([\"--with-bdd\"])\n    nose.run(argv=args, plugins=[BddPrinter()])\n```", "```py\ndef test_plain_old_doctest():\n   for extension in [\"doctest\", \"txt\"]:\n       for doc in glob(\"recipe27*.%s\" % extension): \n           print(\"Testing %s\" % doc) \n           doctest.testfile(doc)\n```", "```py\ndef test_customized_doctests():\n    def test_customized_doctests():\n    from recipe28 import BddDocTestRunner\n    old_doctest_runner = doctest.DocTestRunner \n    doctest.DocTestRunner = BddDocTestRunner\n    for recipe in [\"recipe28\", \"recipe29\"]:\n        for file in glob(\"%s*.doctest\" % recipe): \n            given = file[len(\"%s_\" % recipe):] \n            given = given[:-len(\".doctest\")] \n            given = \" \".join(given.split(\"_\"))\n            print(\"===================================\") \n            print(\"%s: Given a %s...\" % (recipe, given)) \n            print( \"===================================\") \n            doctest.testfile(file)\n            print()\n    doctest.DocTestRunner = old_doctest_runner\n```", "```py\ndef test_lettuce_scenarios():\n    print(\"Running suite recipe32\")\n    lettuce.Runner(os.path.abspath(\"recipe32\"), verbosity=3).run()\n    print()\n    print(\"Running suite recipe33\") \n    lettuce.Runner(os.path.abspath(\"recipe33\"), verbosity=3).run() \n    print()\n```", "```py\ndef test():\n    def test(): \n        test_with_bdd()\n        test_plain_old_doctest() \n        test_customized_doctests() \n        test_lettuce_scenarios()\n```", "```py\ndef package():\n    print \"This is where we can plug in code to run \" + \\ \n          \"setup.py to generate a bundle.\"\ndef publish():\n    print \"This is where we can plug in code to upload \" + \\ \n          \"our tarball to S3 or some other download site.\"\ndef register():\n    print \"setup.py has a built in function to \" + \\ \n          \"'register' a release to PyPI. It's \" + \\ \n          \"convenient to put a hook in here.\"\n    # os.system(\"%s setup.py register\" % sys.executable)\n```", "```py\nif len(optlist) == 0:\n   usage()\n   sys.exit(1)\n# Check for help requests, which cause all other\n# options to be ignored.\nfor option in optlist:\n   if option[0] in (\"--help\", \"-h\"):\n      usage()\n      sys.exit(1)\n# Parse the arguments, in order\nfor option in optlist:\n   if option[0] in (\"--test\"):\n      test()\n   if option[0] in (\"--package\"):\n      package()\n   if option[0] in (\"--publish\"):\n      publish()\n   if option[0] in (\"--register\"):\n      registe\n```", "```py\n(ptc)gturnquist-mbp:04 gturnquist$ python recipe34.py --test Running suite ['recipe26', 'recipe30', 'recipe31']\n...\n  Scenario: Cart getting loaded with different items        #\nrecipe33/recipe33.feature:22\n     Given an empty cart                                    #\nrecipe33/steps.py:6\n     When I add a carton of milk                            #\nrecipe33/steps.py:50\n     And I add a frozen pizza                               #\nrecipe33/steps.py:54\n     Then the first item is a carton of milk                #\nrecipe33/steps.py:34\n     And the second item is a frozen pizza                  #\nrecipe33/steps.py:58\n     And the first price is 2.50                            #\nrecipe32/steps.py:69\n     And the second price is 3.00                           #\nrecipe33/steps.py:66\n     And the total cost with no taxes is 5.50               #\nrecipe33/steps.py:70\n     And the total cost with 10% taxes is 6.05              #\nrecipe33/steps.py:74\n1 feature (1 passed)\n3 scenarios (3 passed)\n21 steps (21 passed) \n```"]