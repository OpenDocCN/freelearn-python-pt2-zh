["```py\n**from functools import lru_cache**\n**@lru_cache(128)**\n**def fibc(n):**\n **\"\"\"Fibonacci numbers with naive recursion and caching**\n **>>> fibc(20)**\n **6765**\n **>>> fibc(1)**\n **1**\n **\"\"\"**\n **if n == 0: return 0**\n **if n == 1: return 1**\n **return fibc(n-1) + fibc(n-2)**\n\n```", "```py\n**Card1 = namedtuple(\"Card1\", (\"rank\", \"suit\"))**\n\n```", "```py\n**>>> c2s= Card1(2, '\\u2660')**\n**>>> c2h= Card1(2, '\\u2665')**\n**>>> c2h == c2s**\n**False**\n\n```", "```py\n**@total_ordering**\n**class Card(tuple):**\n **__slots__ = ()**\n **def __new__( class_, rank, suit ):**\n **obj= tuple.__new__(Card, (rank, suit))**\n **return obj**\n **def __repr__(self):**\n **return \"{0.rank}{0.suit}\".format(self)**\n **@property**\n **def rank(self):**\n **return self[0]**\n **@property**\n **def suit(self):**\n **return self[1]**\n\n```", "```py\n **def __eq__(self, other):**\n **if isinstance(other,Card):**\n **return self.rank == other.rank**\n **elif isinstance(other,Number):**\n **return self.rank == other**\n **def __lt__(self, other):**\n **if isinstance(other,Card):**\n **return self.rank < other.rank**\n **elif isinstance(other,Number):**\n **return self.rank < other**\n\n```", "```py\n**>>> c2s= Card(2, '\\u2660')**\n**>>> c2h= Card(2, '\\u2665')**\n**>>> c2h == c2s**\n**True**\n**>>> c2h == 2**\n**True**\n\n```", "```py\n**>>> c2s= Card(2, '\\u2660')**\n**>>> c3h= Card(3, '\\u2665')**\n**>>> c4c= Card(4, '\\u2663')**\n**>>> c2s <= c3h < c4c**\n**True**\n**>>> c3h >= c3h**\n**True**\n**>>> c3h > c2s**\n**True**\n**>>> c4c != c2s**\n**True**\n\n```", "```py\n**>>> exp2= partial(pow, 2)**\n**>>> exp2(12)**\n**4096**\n**>>> exp2(17)-1**\n**131071**\n\n```", "```py\n**exp2= lambda y: pow(2,y)**\n\n```", "```py\n**d = [2, 4, 4, 4, 5, 5, 7, 9]**\n\n```", "```py\n**2+4+4+4+5+5+7+9**\n\n```", "```py\n**((((((2+4)+4)+4)+5)+5)+7)+9**\n\n```", "```py\n**reduce(lambda x,y: x+y**2, iterable, 0)**\n\n```", "```py\n**0+ 2**2+ 4**2+ 4**2+ 4**2+ 5**2+ 5**2+ 7**2+ 9**2**\n\n```", "```py\n**2+ 4**2+ 4**2+ 4**2+ 5**2+ 5**2+ 7**2+ 9**2**\n\n```", "```py\n**sum2= lambda iterable: reduce(lambda x,y: x+y**2, iterable, 0)**\n**sum= lambda iterable: reduce(lambda x, y: x+y, iterable)**\n**count= lambda iterable: reduce(lambda x, y: x+1, iterable, 0)**\n**min= lambda iterable: reduce(lambda x, y: x if x < y else y, iterable)**\n**max= lambda iterable: reduce(lambda x, y: x if x > y else y, iterable)**\n\n```", "```py\n**def map_reduce(map_fun, reduce_fun, iterable):**\n **return reduce(reduce_fun, map(map_fun, iterable))**\n\n```", "```py\n**def sum2_mr(iterable):**\n **return map_reduce(lambda y: y**2, lambda x,y: x+y, iterable)**\n\n```", "```py\n**import operator**\n**def sum2_mr2(iterable):**\n **return map_reduce(lambda y: y**2, operator.add, iterable)**\n\n```", "```py\n**def count_mr(iterable):**\n **return map_reduce(lambda y: 1, operator.add, iterable)**\n\n```", "```py\n**reduce(operator.add, [\"1\", \",\", \"2\", \",\", \"3\"], \"\")**\n\n```", "```py\n**sum2= partial(reduce, lambda x,y: x+y**2)**\n**count= partial(reduce, lambda x,y: x+1)**\n\n```", "```py\n**def comma_fix(data):**\n **try:**\n **return float(data)**\n **except ValueError:**\n **return float(data.replace(\",\", \"\"))**\n**def clean_sum(cleaner, data):**\n **return reduce(operator.add, map(cleaner, data))**\n\n```", "```py\n**>>> d = ('1,196', '1,176', '1,269', '1,240', '1,307', ... '1,435', '1,601', '1,654', '1,803', '1,734')**\n**>>> clean_sum(comma_fix, d)**\n**14415.0**\n\n```", "```py\n**comma_fix_squared = lambda x: comma_fix(x)**2**\n\n```", "```py\n**>>> data = [('4', 6.1), ('1', 4.0), ('2', 8.3), ('2', 6.5), ... ('1', 4.6), ('2', 6.8), ('3', 9.3), ('2', 7.8), ('2', 9.2), ... ('4', 5.6), ('3', 10.5), ('1', 5.8), ('4', 3.8), ('3', 8.1), ... ('3', 8.0), ('1', 6.9), ('3', 6.9), ('4', 6.2), ('1', 5.4), ... ('4', 5.8)]**\n\n```", "```py\n**from collections import defaultdict**\n**def partition(iterable, key=lambda x:x):**\n **\"\"\"Sort not required.\"\"\"**\n **pd = defaultdict(list)**\n **for row in iterable:**\n **pd[key(row)].append(row)**\n **for k in sorted(pd):**\n **yield k, iter(pd[k])**\n\n```", "```py\n**def partition_s(iterable, key= lambda x:x):**\n **\"\"\"Sort required\"\"\"**\n **return groupby(iterable, key)**\n\n```", "```py\n**mean= lambda seq: sum(seq)/len(seq)**\n**var= lambda mean, seq: sum( (x-mean)**2/mean for x in seq)**\n**def summarize( key_iter ):**\n **key, item_iter= key_iter**\n **values= tuple((v for k,v in item_iter))**\n **\u03bc= mean(values)**\n **return key, \u03bc, var(\u03bc, values)**\n\n```", "```py\n**map(snd, item_iter)**\n\n```", "```py\n**>>> partition1= partition(list(data), key=lambda x:x[0])**\n**>>> groups= map(summarize, partition1)**\n\n```", "```py\n**>>> partition2= partition_s(sorted(data), key=lambda x:x[0])**\n**>>> groups= map(summarize, partition2)**\n\n```", "```py\n**1 5.34 0.93**\n**2 7.72 0.63**\n**3 8.56 0.89**\n**4 5.5 0.7**\n\n```"]