["```py\n**def add(a,b):**\n **if a == 0: return b**\n **else: return add(a-1, b+1)**\n\n```", "```py\n**def fact(n):**\n **if n == 0: return 1**\n **else: return n*fact(n-1)**\n\n```", "```py\n**def facti(n):**\n **if n == 0: return 1**\n **f= 1**\n **for i in range(2,n):**\n **f= f*i**\n **return f**\n\n```", "```py\n**def fastexp(a, n):**\n **if n == 0: return 1**\n **elif n % 2 == 1: return a*fastexp(a,n-1)**\n **else:**\n **t= fastexp(a,n//2)**\n **return t*t**\n\n```", "```py\n**def fib(n):**\n **if n == 0: return 0**\n **if n == 1: return 1**\n **return fib(n-1) + fib(n-2)**\n\n```", "```py\n**def fibi(n):**\n **if n == 0: return 0**\n **if n == 1: return 1**\n **f_n2, f_n1 = 1, 1**\n **for i in range(3, n+1):**\n **f_n2, f_n1 = f_n1, f_n2+f_n1**\n **return f_n1**\n\n```", "```py\n**def mapr(f, collection):**\n **if len(collection) == 0: return []**\n **return mapr(f, collection[:-1]) + [f(collection[-1])]**\n\n```", "```py\n**def mapf(f, C):**\n **return (f(x) for x in C)**\n\n```", "```py\n**def mapg(f, C):**\n **for x in C:**\n **yield f(x)**\n\n```", "```py\n**>>> list(mapg(lambda x:2**x, [0, 1, 2, 3, 4]))**\n**[1, 2, 4, 8, 16]**\n\n```", "```py\n**def prodrc(collection):**\n **if len(collection) == 0: return 1**\n **return collection[0] * prodrc(collection[1:])**\n\n```", "```py\n**def prodri(iterable):**\n **try:**\n **head= next(iterable)**\n **except StopIteration:**\n **return 1**\n **return head*prodri(iterable)**\n\n```", "```py\n**>>> prodri(iter([1,2,3,4,5,6,7]))**\n**5040**\n\n```", "```py\n**def prodi(iterable):**\n **p= 1**\n **for n in iterable:**\n **p *= n**\n **return p**\n\n```", "```py\n**(((37.5490162, -76.330295), (37.840832, -76.273834), 17.7246), ((37.840832, -76.273834), (38.331501, -76.459503), 30.7382), ((38.331501, -76.459503), (38.845501, -76.537331), 31.0756), ... ((38.330166, -76.458504), (38.976334, -76.473503), 38.8019))**\n\n```", "```py\n**quantized= (5*(dist//5) for start,stop,dist in trip)**\n\n```", "```py\n**quantized= (5*(dist//5) for start,stop,dist in trip)**\n\n```", "```py\n**from collections import Counter**\n**Counter(quantized)**\n\n```", "```py\n**[(30.0, 15), (15.0, 9), (35.0, 5), (5.0, 5), (10.0, 5), (20.0, 5), (25.0, 5), (0.0, 4), (40.0, 3), (45.0, 3), (50.0, 3), (60.0, 3), (70.0, 2), (65.0, 1), (80.0, 1), (115.0, 1), (85.0, 1), (55.0, 1), (125.0, 1)]**\n\n```", "```py\n**(35.0, 5), (5.0, 5), (10.0, 5), (20.0, 5), (25.0, 5)**\n\n```", "```py\n**def group_sort(trip):**\n **def group(data):**\n **previous, count = None, 0**\n **for d in sorted(data):**\n **if d == previous:**\n **count += 1**\n **elif previous is not None: # and d != previous**\n **yield previous, count**\n **previous, count = d, 1**\n **elif previous is None:**\n **previous, count = d, 1**\n **else:**\n **raise Exception(\"Bad bad design problem.\")**\n **yield previous, count**\n **quantized= (5*(dist//5) for start,stop,dist in trip)**\n **return dict(group(quantized))**\n\n```", "```py\n **def group(data):**\n **sorted_data= iter(sorted(data))**\n **previous, count = next(sorted_data), 1**\n **for d in sorted_data:**\n **if d == previous:**\n **count += 1**\n **elif previous is not None: # and d != previous**\n **yield previous, count**\n **previous, count = d, 1**\n **else:**\n **raise Exception(\"Bad bad design problem.\")**\n **yield previous, count**\n\n```", "```py\n**>>> C= [1,2,3,4,5]**\n**>>> head, *tail= C**\n**>>> head**\n**1**\n**>>> tail**\n**[2, 3, 4, 5]**\n\n```", "```py\n**def group_by(key, data):**\n **def group_into(key, collection, dictionary):**\n **if len(collection) == 0:** \n **return dictionary**\n **head, *tail= collection**\n **dictionary[key(head)].append(head)**\n **return group_into(key, tail, dictionary)**\n **return group_into(key, data, defaultdict(list))**\n\n```", "```py\n**def group_by(key, data, dictionary=defaultdict(list)):**\n\n```", "```py\n**binned_distance = lambda leg: 5*(leg[2]//5)**\n**by_distance= group_by(binned_distance, trip)**\n\n```", "```py\n**import pprint**\n**for distance in sorted(by_distance):**\n **print(distance)**\n **pprint.pprint(by_distance[distance])**\n\n```", "```py\n**0.0**\n**[((35.505665, -76.653664), (35.508335, -76.654999), 0.1731), ((35.028175, -76.682495), (35.031334, -76.682663), 0.1898), ((25.4095, -77.910164), (25.425833, -77.832664), 4.3155), ((25.0765, -77.308167), (25.080334, -77.334), 1.4235)]**\n**5.0**\n**[((38.845501, -76.537331), (38.992832, -76.451332), 9.7151), ((34.972332, -76.585167), (35.028175, -76.682495), 5.8441), ((30.717167, -81.552498), (30.766333, -81.471832), 5.103), ((25.471333, -78.408165), (25.504833, -78.232834), 9.7128), ((23.9555, -76.31633), (24.099667, -76.401833), 9.844)] ... 125.0**\n**[((27.154167, -80.195663), (29.195168, -81.002998), 129.7748)]**\n\n```", "```py\n**def partition(key, data):**\n **dictionary= defaultdict(list)**\n **for head in data:**\n **dictionary[key(head)].append(head)**\n **return dictionary**\n\n```", "```py\n**start = lambda s, e, d: s**\n**end = lambda s, e, d: e**\n**dist = lambda s, e, d: d**\n**latitude = lambda lat, lon: lat**\n**longitude = lambda lat, lon: lon**\n\n```", "```py\n**>>> point = ((35.505665, -76.653664), (35.508335, -76.654999), 0.1731)**\n**>>> start(*point)**\n**(35.505665, -76.653664)**\n**>>> end(*point)**\n**(35.508335, -76.654999)**\n**>>> dist(*point)**\n**0.1731**\n**>>> latitude(*start(*point))**\n**35.505665**\n\n```", "```py\n**for distance in sorted(by_distance):**\n **print(distance, max(by_distance[distance], key=lambda pt: latitude(*start(*pt))))**\n\n```", "```py\n**0.0 ((35.505665, -76.653664), (35.508335, -76.654999), 0.1731)**\n**5.0 ((38.845501, -76.537331), (38.992832, -76.451332), 9.7151)**\n**10.0 ((36.444168, -76.3265), (36.297501, -76.217834), 10.2537)**\n**...** \n**125.0 ((27.154167, -80.195663), (29.195168, -81.002998), 129.7748)**\n\n```", "```py\n**def s0(data):**\n **return sum(1 for x in data) # or len(data)**\n**def s1(data):**\n **return sum(x for x in data) # or sum(data)**\n**def s2(data):**\n **return sum(x*x for x in data)**\n\n```", "```py\n**def sum_f(function, data):**\n **return sum(function(x) for x in data)**\n\n```", "```py\n**N= sum_f(lambda x: 1, data) # x**0**\n**S= sum_f(lambda x: x, data) # x**1**\n**S2= sum_f( lambda x: x*x, data ) # x**2**\n\n```", "```py\n**def sum_filter_f(filter, function, data):**\n **return sum(function(x) for x in data if filter(x))**\n\n```", "```py\n**count_= lambda x: 1**\n**sum_ = lambda x: x**\n**valid = lambda x: x is not None**\n**N = sum_filter_f(valid, count_, data)**\n\n```", "```py\n**Def lexical_scan( some_source ):**\n **for char in some_source:**\n **if some_pattern completed: yield token**\n **else: accumulate token**\n\n```", "```py\n**def comma_split(text):**\n **return text.split(\",\")**\n**def row_iter_kml(file_obj):**\n **ns_map={**\n **\"ns0\": \"http://www.opengis.net/kml/2.2\",**\n **\"ns1\": \"http://www.google.com/kml/ext/2.2\"}**\n **doc= XML.parse(file_obj)**\n **return (comma_split(coordinates.text)**\n **for coordinates in doc.findall(\"./ns0:Document/ns0:Folder/ns0:Placemark/ns0:Point/ns0:coordinates\", ns_map)**\n\n```", "```py\n**def pick_lat_lon(lon, lat, alt):**\n **return lat, lon**\n**def float_lat_lon(row_iter):**\n **return (tuple(map(float, pick_lat_lon(*row)))for row in row_iter)**\n\n```", "```py\n**with urllib.request.urlopen(\"file:./Winter%202012-2013.kml\") as source:**\n **trip = tuple(float_lat_lon(row_iter_kml(source)))**\n\n```", "```py\n**Anscombe's quartet**\n**I  II  III  IV**\n**x  y  x  y  x  y  x  y**\n**10.0  8.04  10.0  9.14  10.0  7.46  8.0  6.58**\n**8.0  6.95  8.0  8.14  8.0  6.77  8.0  5.76**\n**...** \n**5.0  5.68  5.0  4.74  5.0  5.73  8.0  6.89**\n\n```", "```py\n**def row_iter_csv(source):**\n **rdr= csv.reader(source, delimiter=\"\\t\")**\n **return rdr**\n\n```", "```py\n**def float_none(data):**\n **try:**\n **data_f= float(data)**\n **return data_f**\n **except ValueError:**\n **return None**\n\n```", "```py\n**float_row = lambda row: list(map(float_none, row))**\n\n```", "```py\n**all_numeric = lambda row: all(row) and len(row) == 8**\n\n```", "```py\n**def head_filter_map(validator, converter, validator, row_iter):**\n **return filter(all_validator, map(converter, row_iter))**\n\n```", "```py\nGIMP Palette\nName: Crayola\nColumns: 16\n#\n239 222 205  Almond\n205 149 117  Antique Brass\n```", "```py\n**def row_iter_gpl(file_obj):**\n **header_pat= re.compile(r\"GIMP Palette\\nName:\\s*(.*?)\\nColumns:\\s*(.*?)\\n#\\n\", re.M)**\n **def read_head(file_obj):**\n **match= header_pat.match(\"\".join( file_obj.readline() for _ in range(4)))**\n **return (match.group(1), match.group(2)), file_obj**\n **def read_tail(headers, file_obj):**\n **return headers, (next_line.split() for next_line in file_obj)**\n **return read_tail(*read_head(file_obj))**\n\n```", "```py\n**def color_palette(headers, row_iter):**\n **name, columns = headers**\n **colors = tuple(Color(int(r), int(g), int(b), \" \".join(name))for r,g,b,*name in row_iter)**\n **return name, columns, colors**\n\n```", "```py\n**with open(\"crayola.gpl\") as source:**\n **name, columns, colors = color_palette(*row_iter_gpl(source))**\n **print(name, columns, colors)**\n\n```"]