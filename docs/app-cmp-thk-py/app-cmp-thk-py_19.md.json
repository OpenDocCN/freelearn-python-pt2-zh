["```py\nimport math\nimport cmath\nimport cairo\n```", "```py\n#Define the configuration of the image. \ncanvas_size = (500, 500)\nnumberSubdivisions = 4\n```", "```py\n#Define the Golden Ratio - gr\ngr = (1 + math.sqrt(5)) / 2\n```", "```py\ndef subdivide(triangles):\n    result = []\n    for color, A, B, C in triangles:\n        if color == 0:\n            P = A + (B - A) / gr\n            result += [(0, C, P, B), (1, P, C, A)]\n        else:\n            Q = B + (A - B) / gr\n            R = B + (C - B) / gr\n            result += [(1, R, C, A), (1, Q, R, B), (0, R, Q, A)]\n    return result\n```", "```py\n#Wheel of teal triangles\ntriangles = []\nfor i in range(10):\n    B = cmath.rect(1, (2*i - 1) * math.pi / 10)\n    C = cmath.rect(1, (2*i + 1) * math.pi / 10)\n    if i % 2 == 0:\n        B, C = C, B  # Make sure to mirror every second triangle\n    triangles.append((0, 0j, B, C))\nfor i in range(numberSubdivisions):\n    triangles = subdivide(triangles)\n```", "```py\nsurface = cairo.ImageSurface(cairo.FORMAT_ARGB32, canvas_size[0], canvas_size[1])\ncr = cairo.Context(surface)\ncr.translate(canvas_size[0] / 2.0, canvas_size[1] / 2.0)\nwheelRadius = 1.2 * math.sqrt((canvas_size[0] / 2.0) ** 2 + (canvas_size[1] / 2.0) ** 2)\ncr.scale(wheelRadius, wheelRadius)\n```", "```py\n#Define the teal triangles\nfor color, A, B, C in triangles:\n    if color == 0:\n        cr.move_to(A.real, A.imag)\n        cr.line_to(B.real, B.imag)\n        cr.line_to(C.real, C.imag)\n        cr.close_path()\ncr.set_source_rgb(.2, .8, .8)\ncr.fill()    \n#Define the purple triangles\nfor color, A, B, C in triangles:\n    if color == 1:\n        cr.move_to(A.real, A.imag)\n        cr.line_to(B.real, B.imag)\n        cr.line_to(C.real, C.imag)\n        cr.close_path()\ncr.set_source_rgb(0.7, 0, 0.7)\ncr.fill()\ncolor, A, B, C = triangles[0]\ncr.set_line_width(abs(B - A) / 10.0)\ncr.set_line_join(cairo.LINE_JOIN_ROUND)\n```", "```py\n#Triangle borders\nfor color, A, B, C in triangles:\n    cr.move_to(C.real, C.imag)\n    cr.line_to(A.real, A.imag)\n    cr.line_to(B.real, B.imag)\ncr.set_source_rgb(0.3, 0.5, 0.3)\ncr.stroke()\n```", "```py\nsurface.write_to_png('tessellation.png')\n```", "```py\n#Import libraries needed\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\n```", "```py\n#Get data set. Remember to check your directory and/or add the full location of the file.\ndataset = pd.read_csv('C:\\\\... \\\\breast-cancer.csv')\ndataset.head()\ndataset.isnull().sum()\n```", "```py\n#Create count variable for diagnosis\ncount = dataset.diagnosis.value_counts()\ncount\n```", "```py\n#Create bargraph of the diagnosis values\ncount.plot(kind = 'bar')\nplt.title('Tumor distribution (malignant: 1, benign: 0)')\nplt.xlabel('Diagnosis')\nplt.ylabel('count')\nplt.show()\n```", "```py\ny_target = dataset['diagnosis']\ndataset.columns.values\ndataset['target'] = dataset['diagnosis'].map({0:'B',1:'M'})\n#Create scatterplot of mean perimeter and mean texture\nsns.scatterplot(x = 'perimeter_mean', y = 'texture_mean', data = dataset, hue = 'diagnosis', palette = 'bright');\n```", "```py\nimport pandas as pd\nimport matplotlib.pyplot as plt\n```", "```py\ndf = pd.read_csv('C:\\\\...\\\\us-PuertoRico.csv')\n```", "```py\nplt.scatter(df['date'], df['deaths'])\nplt.xticks(rotation = 90)\nplt.title('Deaths per day during October 2020 due to COVID19 in Puerto Rico')\nplt.ylabel('Number of Deaths')\nfig.tight_layout()\nplt.show()\nplt.savefig('COVID_PR.png')\n```", "```py\nimport pandas as pd\nimport matplotlib.pyplot as plt\n```", "```py\ndf = pd.read_csv('C:\\\\...\\\\brooklyn_sales_map.csv')\n```", "```py\nbins = [-100000000,20000,40000,60000,80000,100000,1000000,10000000,500000000]\nranges_prices = ['$0-$200k','$200k-$400k','$400k-$600k','$600k-$800k','$800k-$1mlln','$1mlln-$10mlln','$10mlln-$100mlln','$100mlln-$500mlln']\ndf['price_range'] = pd.cut(df['sale_price'], bins = bins, labels = ranges_prices)\n```", "```py\ndef convert(year):\n    return df[df['year_of_sale'] == year].groupby('price_range').size()\npercent_total = [x/sum(x)*100 for x in [convert(2003),convert(2004),convert(2005),convert(2006),convert(2007),convert(2008),convert(2009),convert(2010),convert(2011),convert(2012),convert(2013),convert(2014),convert(2015),convert(2016),convert(2017)]]\nyear_names = list(range(2003,2018))\nhousing_df = pd.DataFrame(percent_total, index = year_names)\nax_two = housing_df.plot(kind = 'barh', stacked = True, width = 0.9, cmap = 'Spectral')\nplt.legend(bbox_to_anchor = (1.45, 1), loc='upper right')\nax_two.set_xlabel('Percentages', fontname='Arial', fontsize = 12)\nax_two.set_ylabel('Years', fontname='Arial', fontsize = 12)\nax_two.set_title('Housing Sale ')\n```", "```py\ndf.groupby(['neighborhood','price_range']).size().unstack().plot.bar(stacked = True, cmap = 'rainbow')\nplt.legend(bbox_to_anchor = (1.45, 1), loc = 'upper right')\nplt.title('Pricing by Neighborhoods in Brooklyn from 2003 to 2017')\nplt.ylabel('Price Range')\nplt.xticks(fontsize = 6)\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport random\n```", "```py\nnp.seterr(divide='ignore', invalid='ignore')\n#Define the size of the electric field lines grid\nN = 20\nM = 25\n#Set the x and y coordinates\nx_coor = np.arange(0, M, 1)\ny_coor = np.arange(0, N, 1)\nx_coor, y_coor = np.meshgrid(x_coor, y_coor)\nE_x = np.zeros((N, M))\nE_y = np.zeros((N, M))\n```", "```py\n#Set the number of total charges to plot\nnq = 8\n#Create empty lists to store coordinates of charges\nqq = [[], []]  \nfor dummy in range(nq): \n    q = random.choice([-1, 1])\n    q_x, q_y = random.randrange(1, N), random.randrange(1, M)\n    qq[0].append(q_y)\n    qq[1].append(q_x)\n    for i in range(N):\n        for j in range(M):\n            denom = ((i - q_x) ** 2 + (j - q_y) ** 2) ** 1.5\n            if denom != 0: \n                E_x[i, j] += q * (j - q_y) / denom\n                E_y[i, j] += q * (i - q_x) / denom\n```", "```py\nC = np.hypot(E_x, E_y)\nE = (E_x ** 2 + E_y ** 2) ** .5\nE_x = E_x / E\nE_y = E_y / E\nplt.figure(figsize=(12, 8))\n#Plot charges\nplt.plot(*qq, 'ms')\n#Create 2D array\nrr = plt.quiver(x_coor, y_coor, E_x, E_y, C, pivot='middle')\ncbar = plt.colorbar()\ncbar.ax.set_ylabel('Magnitude')\n#Label graph\nplt.title('Electric Field Lines in Python')\nplt.axis('equal')\nplt.axis('off')\nplt.show()\n```", "```py\nimport seaborn as sns\nimport pandas as pd\ndf = pd.read_csv('C:\\\\...\\\\Data_Cortex_Nuclear.csv')\nsns.pairplot(df, hue = 'Treatment')\n```", "```py\nimport pandas as pd\nimport scipy.stats as stats\nimport matplotlib.pyplot as plt\nimport seaborn as sns\ndf = pd.read_csv('C:\\\\...\\\\Data_Cortex_Nuclear.csv')\nprotein = df[['NR2A_N', 'class']].dropna()\nsns.boxplot(x='class', y='NR2A_N', data = protein)\nplt.show\n```", "```py\nimport quandl\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.svm import SVR\nfrom sklearn.model_selection import train_test_split\n#Get data from Quandl. Note that you'll need your own API to substitute in the api.key below.\nquandl.ApiConfig.api_key = '…'\nVZ = quandl.get('EOD/VZ')\nprint(VZ.head())\n```", "```py\n#Grab the Adj_Close column\nVZ = VZ[['Adj_Close']]\nprint(VZ.head())\n```", "```py\nVZ[\"Date\"]=pd.to_datetime(VZ.Date,format=\"%Y-%m-%d\")\nVZ.index=VZ['Date']\nplt.figure(figsize=(16,8))\nplt.plot(VZ[\"Close\"],label='Close price history')\nplt.title('Closing price over time', fontsize = 20)\nplt.xlabel('Time', fontsize = 15)\nplt.ylabel('Closing price', fontsize = 15)\nplt.show()\n```", "```py\nVZ3=VZ2.values\ntrain_data=VZ3[0:750,:]\nvalid_data=VZ3[750:,:]\nVZ2.index=VZ2.Date\nVZ2.drop(\"Date\",axis=1,inplace=True)\nscaler=MinMaxScaler(feature_range=(0,1))\nscaled_data=scaler.fit_transform(VZ2)\nx_train_data,y_train_data=[],[]\nfor i in range(60,len(train_data)):\n    x_train_data.append(scaled_data[i-60:i,0])\n    y_train_data.append(scaled_data[i,0])\n\nx_train_data,y_train_data=np.array(x_train_data),np.array(y_train_data)\nx_train_data=np.reshape(x_train_data,(x_train_data.shape[0],x_train_data.shape[1],1))\n```", "```py\nfrom keras.datasets import mnist\n#Grab the testing and training data from existing dataset\n(X_train, y_train), (X_test, y_test) = mnist.load_data()\nimport matplotlib.pyplot as plt\n#Take a look at the first item in the dataset\nplt.imshow(X_train[0], cmap='Greys')\n```", "```py\n#Reshape the model \nX_train = X_train.reshape(60000,28,28,1)\nX_test = X_test.reshape(10000,28,28,1)\nfrom keras.utils import to_categorical\n#Use One-Hot encoding\ny_train = to_categorical(y_train)\ny_test = to_categorical(y_test)\ny_train[0]\n```", "```py\n#Creating the model\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Conv2D, Flatten\nmodel = Sequential()\nmodel.add(Conv2D(64, kernel_size=3, activation='relu', input_shape=(28,28,1)))\nmodel.add(Conv2D(32, kernel_size=3, activation='relu'))\nmodel.add(Flatten())\nmodel.add(Dense(10, activation='softmax'))\n#Compile the model\nmodel.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])\n```", "```py\n#train the model\nmodel.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=3)\n```", "```py\n#Predict last 4 images\nmodel.predict(X_test[9996:])\n```", "```py\nplt.imshow(X_test[9996], cmap='Greys')\n```"]