["```py\n    import math\n    import cmath\n    import cairo\n    ```", "```py\n    #Define the configuration of the image. \n    canvas_size = (500, 500)\n    numberSubdivisions = 4\n    ```", "```py\n    #Define the Golden Ratio - gr\n    gr = (1 + math.sqrt(5)) / 2\n    ```", "```py\n    def subdivide(triangles):\n    \u00a0\u00a0\u00a0\u00a0result = []\n    \u00a0\u00a0\u00a0\u00a0for color, A, B, C in triangles:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if color == 0:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P = A + (B - A) / gr\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result += [(0, C, P, B), (1, P, C, A)]\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q = B + (A - B) / gr\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0R = B + (C - B) / gr\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result += [(1, R, C, A), (1, Q, R, B), (0, R, Q, A)]\n    \u00a0\u00a0\u00a0\u00a0return result\n    ```", "```py\n    #Wheel of teal triangles\n    triangles = []\n    for i in range(10):\n    \u00a0\u00a0\u00a0\u00a0B = cmath.rect(1, (2*i - 1) * math.pi / 10)\n    \u00a0\u00a0\u00a0\u00a0C = cmath.rect(1, (2*i + 1) * math.pi / 10)\n    \u00a0\u00a0\u00a0\u00a0if i % 2 == 0:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0B, C = C, B\u00a0\u00a0# Make sure to mirror every second triangle\n    \u00a0\u00a0\u00a0\u00a0triangles.append((0, 0j, B, C))\n    for i in range(numberSubdivisions):\n    \u00a0\u00a0\u00a0\u00a0triangles = subdivide(triangles)\n    ```", "```py\n    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, canvas_size[0], canvas_size[1])\n    cr = cairo.Context(surface)\n    cr.translate(canvas_size[0] / 2.0, canvas_size[1] / 2.0)\n    wheelRadius = 1.2 * math.sqrt((canvas_size[0] / 2.0) ** 2 + (canvas_size[1] / 2.0) ** 2)\n    cr.scale(wheelRadius, wheelRadius)\n    ```", "```py\n    #Define the teal triangles\n    for color, A, B, C in triangles:\n    \u00a0\u00a0\u00a0\u00a0if color == 0:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cr.move_to(A.real, A.imag)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cr.line_to(B.real, B.imag)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cr.line_to(C.real, C.imag)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cr.close_path()\n    cr.set_source_rgb(.2, .8, .8)\n    cr.fill()\u00a0\u00a0\u00a0\u00a0\n    #Define the purple triangles\n    for color, A, B, C in triangles:\n    \u00a0\u00a0\u00a0\u00a0if color == 1:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cr.move_to(A.real, A.imag)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cr.line_to(B.real, B.imag)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cr.line_to(C.real, C.imag)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cr.close_path()\n    cr.set_source_rgb(0.7, 0, 0.7)\n    cr.fill()\n    color, A, B, C = triangles[0]\n    cr.set_line_width(abs(B - A) / 10.0)\n    cr.set_line_join(cairo.LINE_JOIN_ROUND)\n    ```", "```py\n    #Triangle borders\n    for color, A, B, C in triangles:\n    \u00a0\u00a0\u00a0\u00a0cr.move_to(C.real, C.imag)\n    \u00a0\u00a0\u00a0\u00a0cr.line_to(A.real, A.imag)\n    \u00a0\u00a0\u00a0\u00a0cr.line_to(B.real, B.imag)\n    cr.set_source_rgb(0.3, 0.5, 0.3)\n    cr.stroke()\n    ```", "```py\n    surface.write_to_png('tessellation.png')\n    ```", "```py\n    #Import libraries needed\n    import pandas as pd\n    import matplotlib.pyplot as plt\n    import seaborn as sns\n    %matplotlib inline\n    ```", "```py\n    #Get data set. Remember to check your directory and/or add the full location of the file.\n    dataset = pd.read_csv('C:\\\\... \\\\breast-cancer.csv')\n    dataset.head()\n    dataset.isnull().sum()\n    ```", "```py\n    #Create count variable for diagnosis\n    count = dataset.diagnosis.value_counts()\n    count\n    ```", "```py\n    #Create bargraph of the diagnosis values\n    count.plot(kind = 'bar')\n    plt.title('Tumor distribution (malignant: 1, benign: 0)')\n    plt.xlabel('Diagnosis')\n    plt.ylabel('count')\n    plt.show()\n    ```", "```py\n    y_target = dataset['diagnosis']\n    dataset.columns.values\n    dataset['target'] = dataset['diagnosis'].map({0:'B',1:'M'})\n    #Create scatterplot of mean perimeter and mean texture\n    sns.scatterplot(x = 'perimeter_mean', y = 'texture_mean', data = dataset, hue = 'diagnosis', palette = 'bright');\n    ```", "```py\n    import pandas as pd\n    import matplotlib.pyplot as plt\n    ```", "```py\n    df = pd.read_csv('C:\\\\...\\\\us-PuertoRico.csv')\n    ```", "```py\n    plt.scatter(df['date'], df['deaths'])\n    plt.xticks(rotation = 90)\n    plt.title('Deaths per day during October 2020 due to COVID19 in Puerto Rico')\n    plt.ylabel('Number of Deaths')\n    fig.tight_layout()\n    plt.show()\n    plt.savefig('COVID_PR.png')\n    ```", "```py\n    import pandas as pd\n    import matplotlib.pyplot as plt\n    ```", "```py\n    df = pd.read_csv('C:\\\\...\\\\brooklyn_sales_map.csv')\n    ```", "```py\n    bins = [-100000000,20000,40000,60000,80000,100000,1000000,10000000,500000000]\n    ranges_prices = ['$0-$200k','$200k-$400k','$400k-$600k','$600k-$800k','$800k-$1mlln','$1mlln-$10mlln','$10mlln-$100mlln','$100mlln-$500mlln']\n    df['price_range'] = pd.cut(df['sale_price'], bins = bins, labels = ranges_prices)\n    ```", "```py\n    def convert(year):\n    \u00a0\u00a0\u00a0\u00a0return df[df['year_of_sale'] == year].groupby('price_range').size()\n    percent_total = [x/sum(x)*100 for x in [convert(2003),convert(2004),convert(2005),convert(2006),convert(2007),convert(2008),convert(2009),convert(2010),convert(2011),convert(2012),convert(2013),convert(2014),convert(2015),convert(2016),convert(2017)]]\n    year_names = list(range(2003,2018))\n    housing_df = pd.DataFrame(percent_total, index = year_names)\n    ax_two = housing_df.plot(kind = 'barh', stacked = True, width = 0.9, cmap = 'Spectral')\n    plt.legend(bbox_to_anchor = (1.45, 1), loc='upper right')\n    ax_two.set_xlabel('Percentages', fontname='Arial', fontsize = 12)\n    ax_two.set_ylabel('Years', fontname='Arial', fontsize = 12)\n    ax_two.set_title('Housing Sale ')\n    ```", "```py\n    df.groupby(['neighborhood','price_range']).size().unstack().plot.bar(stacked = True, cmap = 'rainbow')\n    plt.legend(bbox_to_anchor = (1.45, 1), loc = 'upper right')\n    plt.title('Pricing by Neighborhoods in Brooklyn from 2003 to 2017')\n    plt.ylabel('Price Range')\n    plt.xticks(fontsize = 6)\n    ```", "```py\n    import numpy as np\n    import matplotlib.pyplot as plt\n    import random\n    ```", "```py\n    np.seterr(divide='ignore', invalid='ignore')\n    #Define the size of the electric field lines grid\n    N = 20\n    M = 25\n    #Set the x and y coordinates\n    x_coor = np.arange(0, M, 1)\n    y_coor = np.arange(0, N, 1)\n    x_coor, y_coor = np.meshgrid(x_coor, y_coor)\n    E_x = np.zeros((N, M))\n    E_y = np.zeros((N, M))\n    ```", "```py\n    #Set the number of total charges to plot\n    nq = 8\n    #Create empty lists to store coordinates of charges\n    qq = [[], []]\u00a0\u00a0\n    for dummy in range(nq): \n    \u00a0\u00a0\u00a0\u00a0q = random.choice([-1, 1])\n    \u00a0\u00a0\u00a0\u00a0q_x, q_y = random.randrange(1, N), random.randrange(1, M)\n    \u00a0\u00a0\u00a0\u00a0qq[0].append(q_y)\n    \u00a0\u00a0\u00a0\u00a0qq[1].append(q_x)\n    \u00a0\u00a0\u00a0\u00a0for i in range(N):\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(M):\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0denom = ((i - q_x) ** 2 + (j - q_y) ** 2) ** 1.5\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if denom != 0: \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0E_x[i, j] += q * (j - q_y) / denom\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0E_y[i, j] += q * (i - q_x) / denom\n    ```", "```py\n    C = np.hypot(E_x, E_y)\n    E = (E_x ** 2 + E_y ** 2) ** .5\n    E_x = E_x / E\n    E_y = E_y / E\n    plt.figure(figsize=(12, 8))\n    #Plot charges\n    plt.plot(*qq, 'ms')\n    #Create 2D array\n    rr = plt.quiver(x_coor, y_coor, E_x, E_y, C, pivot='middle')\n    cbar = plt.colorbar()\n    cbar.ax.set_ylabel('Magnitude')\n    #Label graph\n    plt.title('Electric Field Lines in Python')\n    plt.axis('equal')\n    plt.axis('off')\n    plt.show()\n    ```", "```py\n    import seaborn as sns\n    import pandas as pd\n    df = pd.read_csv('C:\\\\...\\\\Data_Cortex_Nuclear.csv')\n    sns.pairplot(df, hue = 'Treatment')\n    ```", "```py\nimport pandas as pd\nimport scipy.stats as stats\nimport matplotlib.pyplot as plt\nimport seaborn as sns\ndf = pd.read_csv('C:\\\\...\\\\Data_Cortex_Nuclear.csv')\nprotein = df[['NR2A_N', 'class']].dropna()\nsns.boxplot(x='class', y='NR2A_N', data = protein)\nplt.show\n```", "```py\n    import quandl\n    import numpy as np\n    from sklearn.linear_model import LinearRegression\n    from sklearn.svm import SVR\n    from sklearn.model_selection import train_test_split\n    #Get data from Quandl. Note that you'll need your own API to substitute in the api.key below.\n    quandl.ApiConfig.api_key = '\u2026'\n    VZ = quandl.get('EOD/VZ')\n    print(VZ.head())\n    ```", "```py\n    #Grab the Adj_Close column\n    VZ = VZ[['Adj_Close']]\n    print(VZ.head())\n    ```", "```py\n    VZ[\"Date\"]=pd.to_datetime(VZ.Date,format=\"%Y-%m-%d\")\n    VZ.index=VZ['Date']\n    plt.figure(figsize=(16,8))\n    plt.plot(VZ[\"Close\"],label='Close price history')\n    plt.title('Closing price over time', fontsize = 20)\n    plt.xlabel('Time', fontsize = 15)\n    plt.ylabel('Closing price', fontsize = 15)\n    plt.show()\n    ```", "```py\n    VZ3=VZ2.values\n    train_data=VZ3[0:750,:]\n    valid_data=VZ3[750:,:]\n    VZ2.index=VZ2.Date\n    VZ2.drop(\"Date\",axis=1,inplace=True)\n    scaler=MinMaxScaler(feature_range=(0,1))\n    scaled_data=scaler.fit_transform(VZ2)\n    x_train_data,y_train_data=[],[]\n    for i in range(60,len(train_data)):\n    \u00a0\u00a0\u00a0\u00a0x_train_data.append(scaled_data[i-60:i,0])\n    \u00a0\u00a0\u00a0\u00a0y_train_data.append(scaled_data[i,0])\n\n    x_train_data,y_train_data=np.array(x_train_data),np.array(y_train_data)\n    x_train_data=np.reshape(x_train_data,(x_train_data.shape[0],x_train_data.shape[1],1))\n    ```", "```py\n    from keras.datasets import mnist\n    #Grab the testing and training data from existing dataset\n    (X_train, y_train), (X_test, y_test) = mnist.load_data()\n    import matplotlib.pyplot as plt\n    #Take a look at the first item in the dataset\n    plt.imshow(X_train[0], cmap='Greys')\n    ```", "```py\n    #Reshape the model \n    X_train = X_train.reshape(60000,28,28,1)\n    X_test = X_test.reshape(10000,28,28,1)\n    from keras.utils import to_categorical\n    #Use One-Hot encoding\n    y_train = to_categorical(y_train)\n    y_test = to_categorical(y_test)\n    y_train[0]\n    ```", "```py\n    #Creating the model\n    from keras.models import Sequential\n    from keras.layers import Dense, Conv2D, Flatten\n    model = Sequential()\n    model.add(Conv2D(64, kernel_size=3, activation='relu', input_shape=(28,28,1)))\n    model.add(Conv2D(32, kernel_size=3, activation='relu'))\n    model.add(Flatten())\n    model.add(Dense(10, activation='softmax'))\n    #Compile the model\n    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])\n    ```", "```py\n    #train the model\n    model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=3)\n    ```", "```py\n    #Predict last 4 images\n    model.predict(X_test[9996:])\n    ```", "```py\n    plt.imshow(X_test[9996], cmap='Greys')\n    ```"]